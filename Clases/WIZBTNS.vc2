*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.21" SourceFile="wizbtns.vcx" CPID="1252" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS addrecord AS form 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="Shape1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Commandgroup1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Text1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Label1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Label2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Label3" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Label4" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: setkeyfield
		*p: ckeyfield
		*p: ckeyvalue
		*p: oretvalue
	*</DefinedPropArrayMethod>

	*<PropValue>
		AutoCenter = .T.
		BorderStyle = 2
		Caption = "Agregar registro"
		ckeyvalue = 
		DoCreate = .T.
		Height = 174
		MaxButton = .F.
		MinButton = .F.
		Name = "addrecord"
		ShowWindow = 1
		Width = 341
		WindowType = 1
	*</PropValue>

	ADD OBJECT 'Commandgroup1' AS commandgroup WITH ;
		BackStyle = 0, ;
		BorderStyle = 0, ;
		ButtonCount = 2, ;
		ControlSource = "nBtnAction", ;
		Height = 33, ;
		Left = 168, ;
		Name = "Commandgroup1", ;
		TabIndex = 2, ;
		Top = 134, ;
		Value =       1.00, ;
		Width = 161, ;
		Command1.Caption = "Ag\<regar", ;
		Command1.FontName = "MS Sans Serif", ;
		Command1.FontSize = 8, ;
		Command1.Height = 23, ;
		Command1.Left = 5, ;
		Command1.Name = "Command1", ;
		Command1.TabIndex = 1, ;
		Command1.Top = 5, ;
		Command1.Width = 72, ;
		Command2.Cancel = .T., ;
		Command2.Caption = "Cancelar", ;
		Command2.FontName = "MS Sans Serif", ;
		Command2.FontSize = 8, ;
		Command2.Height = 23, ;
		Command2.Left = 84, ;
		Command2.Name = "Command2", ;
		Command2.TabIndex = 2, ;
		Command2.Top = 5, ;
		Command2.Width = 72
		*< END OBJECT: BaseClass="commandgroup" />

	ADD OBJECT 'Label1' AS label WITH ;
		AutoSize = .T., ;
		BackStyle = 0, ;
		Caption = "\<Valor de clave:", ;
		FontName = "MS Sans Serif", ;
		FontSize = 8, ;
		Height = 15, ;
		Left = 24, ;
		Name = "Label1", ;
		TabIndex = 3, ;
		Top = 100, ;
		Width = 73
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'Label2' AS label WITH ;
		BackStyle = 0, ;
		Caption = "Para agregar un registro nuevo debe proporcionar un valor único para el campo clave de abajo.", ;
		FontName = "MS Sans Serif", ;
		FontSize = 8, ;
		Height = 36, ;
		Left = 12, ;
		Name = "Label2", ;
		TabIndex = 4, ;
		Top = 12, ;
		Width = 324, ;
		WordWrap = .T.
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'Label3' AS label WITH ;
		BackStyle = 0, ;
		Caption = "Etiqueta3", ;
		FontItalic = .T., ;
		FontName = "MS Sans Serif", ;
		FontSize = 8, ;
		Height = 16, ;
		Left = 102, ;
		Name = "Label3", ;
		TabIndex = 5, ;
		Top = 72, ;
		Width = 192
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'Label4' AS label WITH ;
		AutoSize = .T., ;
		BackStyle = 0, ;
		Caption = "Campo clave:", ;
		FontName = "MS Sans Serif", ;
		FontSize = 8, ;
		Height = 15, ;
		Left = 24, ;
		Name = "Label4", ;
		TabIndex = 6, ;
		Top = 72, ;
		Width = 67
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'Shape1' AS shape WITH ;
		Height = 68, ;
		Left = 16, ;
		Name = "Shape1", ;
		SpecialEffect = 0, ;
		Top = 60, ;
		Width = 308
		*< END OBJECT: BaseClass="shape" />

	ADD OBJECT 'Text1' AS textbox WITH ;
		Alignment = 0, ;
		FontName = "MS Sans Serif", ;
		FontSize = 8, ;
		Height = 24, ;
		Left = 102, ;
		Name = "Text1", ;
		TabIndex = 1, ;
		Top = 96, ;
		Width = 204
		*< END OBJECT: BaseClass="textbox" />
	
	PROCEDURE QueryUnload
		THIS.CommandGroup1.Value=2
		THIS.Release()
	ENDPROC

	PROCEDURE Release
		THIS.oRetValue.AddProperty("cKeyValue",THIS.Text1.Value)
		THIS.oRetValue.AddProperty("nBtnAction",THIS.CommandGroup1.Value)
		
	ENDPROC

	PROCEDURE setkeyfield
	ENDPROC

	PROCEDURE Show
		LPARAMETERS nStyle
		
		THIS.Label3.Caption = THIS.cKeyField
		
		DO CASE
		CASE TYPE('THIS.cKeyValue') = "C"
			THIS.Text1.Value = ""
		CASE ATC(TYPE('THIS.cKeyValue'),"NYIBF") # 0
			THIS.Text1.Value = 0
		CASE ATC(TYPE('THIS.cKeyValue'),"DT") # 0
			THIS.Text1.Value = {//}
		CASE TYPE('THIS.cKeyValue') = "L"
			THIS.Text1.Value = .T.
		ENDCASE
		
	ENDPROC

	PROCEDURE Commandgroup1.Click
		THISFORM.Release()
		
	ENDPROC

ENDDEFINE

DEFINE CLASS grid1 AS grid 
 	*< CLASSDATA: Baseclass="grid" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<PropValue>
		FontName = "MS Sans Serif"
		FontSize = 8
		Height = 152
		Name = "grid1"
		RecordSource = "customer"
		Width = 397
	*</PropValue>

ENDDEFINE

DEFINE CLASS gridaddform AS form 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="Shape1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Optiongroup1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Commandgroup1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Text1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Label1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Label2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Label3" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Label4" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Label5" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*p: ckeyvalue
	*</DefinedPropArrayMethod>

	*<PropValue>
		AutoCenter = .T.
		BorderStyle = 3
		Caption = "Agregar registro"
		DoCreate = .T.
		Height = 235
		MaxButton = .F.
		MinButton = .F.
		Name = "gridaddform"
		ScaleMode = 3
		ShowWindow = 1
		Width = 309
		WindowType = 1
	*</PropValue>

	ADD OBJECT 'Commandgroup1' AS commandgroup WITH ;
		BackStyle = 0, ;
		BorderStyle = 0, ;
		ButtonCount = 2, ;
		ControlSource = "nBtnAction", ;
		Height = 33, ;
		Left = 142, ;
		Name = "Commandgroup1", ;
		Top = 198, ;
		Value =       1.00, ;
		Width = 161, ;
		Command1.Caption = "Ag\<regar", ;
		Command1.FontName = "MS Sans Serif", ;
		Command1.FontSize = 8, ;
		Command1.Height = 23, ;
		Command1.Left = 5, ;
		Command1.Name = "Command1", ;
		Command1.TabIndex = 1, ;
		Command1.Top = 5, ;
		Command1.Width = 72, ;
		Command2.Cancel = .T., ;
		Command2.Caption = "Cancelar", ;
		Command2.FontName = "MS Sans Serif", ;
		Command2.FontSize = 8, ;
		Command2.Height = 23, ;
		Command2.Left = 84, ;
		Command2.Name = "Command2", ;
		Command2.TabIndex = 2, ;
		Command2.Top = 5, ;
		Command2.Width = 72
		*< END OBJECT: BaseClass="commandgroup" />

	ADD OBJECT 'Label1' AS label WITH ;
		AutoSize = .T., ;
		BackStyle = 0, ;
		Caption = "\<Valor de clave:", ;
		FontName = "MS Sans Serif", ;
		FontSize = 8, ;
		Height = 15, ;
		Left = 18, ;
		Name = "Label1", ;
		Top = 165, ;
		Width = 73
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'Label2' AS label WITH ;
		Caption = "Seleccione una opción para agregar registros:", ;
		FontName = "MS Sans Serif", ;
		FontSize = 8, ;
		Height = 15, ;
		Left = 16, ;
		Name = "Label2", ;
		Top = 17, ;
		Width = 224
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'Label3' AS label WITH ;
		BackStyle = 0, ;
		Caption = "Etiqueta3", ;
		FontItalic = .T., ;
		FontName = "MS Sans Serif", ;
		FontSize = 8, ;
		Height = 16, ;
		Left = 90, ;
		Name = "Label3", ;
		Top = 141, ;
		Width = 145
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'Label4' AS label WITH ;
		AutoSize = .T., ;
		BackStyle = 0, ;
		Caption = "Campo clave:", ;
		FontName = "MS Sans Serif", ;
		FontSize = 8, ;
		Height = 15, ;
		Left = 18, ;
		Name = "Label4", ;
		Top = 141, ;
		Width = 67
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'Label5' AS label WITH ;
		Caption = "Escriba un valor de clave que vincule registros primarios y secundarios:", ;
		FontName = "MS Sans Serif", ;
		FontSize = 8, ;
		Height = 27, ;
		Left = 16, ;
		Name = "Label5", ;
		Top = 107, ;
		Width = 183, ;
		WordWrap = .T.
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'Optiongroup1' AS optiongroup WITH ;
		BackStyle = 0, ;
		BorderStyle = 1, ;
		ButtonCount = 3, ;
		ControlSource = "nAddAction", ;
		Height = 72, ;
		Left = 10, ;
		Name = "Optiongroup1", ;
		SpecialEffect = 0, ;
		TabIndex = 1, ;
		Top = 24, ;
		Value = 2, ;
		Width = 288, ;
		Option1.AutoSize = .T., ;
		Option1.BackStyle = 0, ;
		Option1.Caption = "Agr\<egar registro sólo a registro primario", ;
		Option1.FontName = "MS Sans Serif", ;
		Option1.FontSize = 8, ;
		Option1.Height = 15, ;
		Option1.Left = 5, ;
		Option1.Name = "Option1", ;
		Option1.Top = 11, ;
		Option1.Value = 0, ;
		Option1.Width = 199, ;
		Option2.AutoSize = .T., ;
		Option2.BackStyle = 0, ;
		Option2.Caption = "Agregar registro sólo a registro \<secundario (cuadrícula)", ;
		Option2.FontName = "MS Sans Serif", ;
		Option2.FontSize = 8, ;
		Option2.Height = 15, ;
		Option2.Left = 5, ;
		Option2.Name = "Option2", ;
		Option2.Top = 31, ;
		Option2.Value = 1, ;
		Option2.Width = 275, ;
		Option3.AutoSize = .T., ;
		Option3.BackStyle = 0, ;
		Option3.Caption = "Agregar registro a \<ambos", ;
		Option3.FontName = "MS Sans Serif", ;
		Option3.FontSize = 8, ;
		Option3.Height = 15, ;
		Option3.Left = 5, ;
		Option3.Name = "Option3", ;
		Option3.Top = 51, ;
		Option3.Value = 0, ;
		Option3.Width = 135
		*< END OBJECT: BaseClass="optiongroup" />

	ADD OBJECT 'Shape1' AS shape WITH ;
		Height = 73, ;
		Left = 10, ;
		Name = "Shape1", ;
		SpecialEffect = 0, ;
		Top = 120, ;
		Width = 288
		*< END OBJECT: BaseClass="shape" />

	ADD OBJECT 'Text1' AS textbox WITH ;
		Alignment = 0, ;
		FontName = "MS Sans Serif", ;
		FontSize = 8, ;
		Height = 24, ;
		Left = 90, ;
		Name = "Text1", ;
		TabIndex = 3, ;
		Top = 161, ;
		Width = 196
		*< END OBJECT: BaseClass="textbox" />
	
	PROCEDURE Init
		LPARAMETERS cFldKey,cKeyValue,nBtnAction,nAddAction,lChildPrimaryKey,lUpdatableParentKey,lNoSendUpdates
		
		IF PARAMETERS() # 7
			RETURN .F.
		ENDIF
		
		THIS.CommandGroup1.Value = 0
		THIS.Label3.Caption = m.cFldKey
		THIS.cKeyValue = m.cKeyValue
		
		DO CASE
		CASE m.lNoSendUpdates
			* Send Parent Updates
			THIS.Optiongroup1.Option1.Enabled = .F.
			THIS.Optiongroup1.Option3.Enabled = .F.
		CASE !m.lUpdatableParentKey
			* Updatable parent key
			THIS.Optiongroup1.Option3.Enabled = .F.
		ENDCASE
		
		* Has a primary key
		IF m.lChildPrimaryKey
			THIS.Optiongroup1.Option2.Enabled = .F.
		ENDIF
		
		DO CASE
		CASE TYPE('THIS.cKeyValue') = "C"
			THIS.Text1.Value = ""
		CASE ATC(TYPE('THIS.cKeyValue'),"NYIBF") # 0
			THIS.Text1.Value = 0
		CASE ATC(TYPE('THIS.cKeyValue'),"DT") # 0
			THIS.Text1.Value = {//}
		CASE TYPE('THIS.cKeyValue') = "L"
			THIS.Text1.Value = .T.
		ENDCASE
		
	ENDPROC

	PROCEDURE QueryUnload
		nBtnAction = 2
		THISFORM.Release()
	ENDPROC

	PROCEDURE Commandgroup1.Click
		cKeyValue = THIS.Parent.Text1.Value
		nAddAction = THIS.Parent.OptionGroup1.Value
		nBtnAction = THIS.Value
		THISFORM.Release()
	ENDPROC

	PROCEDURE Optiongroup1.InteractiveChange
		DO CASE
		CASE THIS.Value = 2
			THISFORM.Text1.Value = THISFORM.cKeyValue
		CASE TYPE('THISFORM.cKeyValue') = "C"
			THISFORM.Text1.Value = ""
		CASE ATC(TYPE('THISFORM.cKeyValue'),"NYIBF") # 0
			THISFORM.Text1.Value = 0
		CASE ATC(TYPE('THISFORM.cKeyValue'),"DT") # 0
			THISFORM.Text1.Value = {//}
		CASE TYPE('THISFORM.cKeyValue') = "L"
			THISFORM.Text1.Value = .T.
		ENDCASE
		
		THISFORM.Text1.ReadOnly = (THIS.Value = 2)
		
	ENDPROC

ENDDEFINE

DEFINE CLASS gridaddrec AS custom 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: runaddform
		*p: addoption
		*p: childprimarykey
		*p: keyfield
		*p: keyvalue
		*p: nosendupdates
		*p: updatableparentkey
	*</DefinedPropArrayMethod>

	*<PropValue>
		Height = 22
		Name = "gridaddrec"
		Width = 39
	*</PropValue>
	
	PROCEDURE runaddform
		#DEFINE C_NOOBJ_LOC	"Falló la creación de la clase de formulario Agregar registro. Compruebe o vuelva a instalar el archivo WIZSTYLE.VCX."
		
		PRIVATE cFldKey,cKeyValue,nBtnAction,nAddAction,oGridAddForm 
		
		IF TYPE("THIS.KeyField") # "C"
			THIS.KeyField = ""
		ENDIF
		
		cFldKey = THIS.KeyField
		cKeyValue = THIS.KeyValue
		nBtnAction = 1
		nAddAction = 1
		
		oGridAddForm = CREATE("gridaddform",m.cFldKey,m.cKeyValue,;
			m.nBtnAction,m.nAddAction,THIS.ChildPrimaryKey,THIS.UpdatableParentKey,THIS.NoSendUpdates)
		
		IF TYPE("m.oGridAddForm") # "O"
			=MESSAGEBOX(C_NOOBJ_LOC)
			THIS.AddOption = 0
			RETURN
		ENDIF
		
		IF THIS.NoSendUpdates
			oGridAddForm.OptionGroup1.Value = 2
			oGridAddForm.Text1.Value = m.cKeyValue
		ENDIF
		
		oGridAddForm.Show()
		
		THIS.AddOption = IIF(m.nBtnAction=1,m.nAddAction,0)
		THIS.KeyValue = m.cKeyValue
		
	ENDPROC

ENDDEFINE

DEFINE CLASS gridbtns AS container 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" ProjectClassIcon="stylebmp\textbttn.bmp" ClassIcon="stylebmp\textbttn.bmp" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="cmdFind" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdPrint" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdExit" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdAdd" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdDelete" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: addrec		&& Adds a new record.
		*m: checkerror
		*m: deleterec		&& Deletes current record.
		*m: initvars		&& Saves and sets certain environment variables.
		*m: updaterows		&& Handles add, edit and delete operations of records to tables.
		*p: haderror		&& Whether an error occurred.
		*p: hasgeneral		&& Whether the form has general field oleboundcontrol object (set internally).
		*p: hasmemo		&& Whether the form has memo field editbox object (set internally).
		*p: lautobuffer		&& Whether to always buffer data.
		*p: lnorptscope		&& Whether to hide scope for reporting dialog.
		*p: lnorptsource		&& Whether to hide source for reporting dialog.
		*p: lpromptkey		&& Whether to prompt for primary key when adding new record.
		*p: lstarttop		&& Whether to always start at first record.
		*p: nworkarea		&& Saves old workarea (set internally).
		*p: oldalias		&& Saves alias when editing to restore with 1-Many forms (set internally).
		*p: oldbuffering		&& Saves table buffering state (set internally).
		*p: oldmultilocks		&& Saves SET MULTILOCKS (set internally).
		*p: oldrec		&& Saves record number (set internally).
		*p: oldrefresh		&& Saves SET REFRESH (set internally).
		*p: oldreprocess		&& Saves SET REPROCESS (set internally).
		*p: oldsetdelete		&& Saves SET DELETED (set internally).
		*p: oldsetfields		&& Saves SET FIELDS (set internally).
		*p: oldtalk		&& Saves SET TALK (set internally).
		*p: previewinit		&& For use with Preview button on wizard (set internally).
		*p: previewmode		&& Whether the form is in preview mode for use with Preview button on Wizard (set internally).
		*p: usedataenv		&& Whether the form has a data environment object attached (set internally).
	*</DefinedPropArrayMethod>

	*<PropValue>
		BackStyle = 0
		BorderWidth = 0
		Height = 26
		lautobuffer = .T.
		lpromptkey = .T.
		Name = "gridbtns"
		nworkarea = 0
		oldbuffering = 1
		oldrec = 0
		oldrefresh = 0
		oldreprocess = 0
		previewinit = .T.
		previewmode = .F.
		TabIndex = 1
		usedataenv = .T.
		Visible = .T.
		Width = 296
	*</PropValue>

	ADD OBJECT 'cmdAdd' AS commandbutton WITH ;
		Caption = "\<Agregar", ;
		Enabled = .T., ;
		FontName = "MS Sans Serif", ;
		FontSize = 8, ;
		Height = 24, ;
		Left = 116, ;
		Name = "cmdAdd", ;
		StatusBarText = "Agregar nuevo registro/Guardar modificaciones", ;
		TabIndex = 7, ;
		ToolTipText = "", ;
		Top = 2, ;
		Width = 53
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdDelete' AS commandbutton WITH ;
		Caption = "\<Eliminar", ;
		Enabled = .T., ;
		FontName = "MS Sans Serif", ;
		FontSize = 8, ;
		Height = 24, ;
		Left = 178, ;
		Name = "cmdDelete", ;
		StatusBarText = "Eliminar un registro existente", ;
		TabIndex = 9, ;
		ToolTipText = "", ;
		Top = 2, ;
		Width = 53
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdExit' AS commandbutton WITH ;
		Caption = "\<Salir", ;
		Enabled = .T., ;
		FontName = "MS Sans Serif", ;
		FontSize = 8, ;
		Height = 24, ;
		Left = 240, ;
		Name = "cmdExit", ;
		StatusBarText = "Salir del formulario de entrada", ;
		TabIndex = 10, ;
		ToolTipText = "", ;
		Top = 2, ;
		Width = 53
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdFind' AS commandbutton WITH ;
		Caption = "\<Buscar", ;
		Enabled = .T., ;
		FontName = "MS Sans Serif", ;
		FontSize = 8, ;
		Height = 24, ;
		Left = 0, ;
		Name = "cmdFind", ;
		StatusBarText = "Buscar registros", ;
		TabIndex = 5, ;
		ToolTipText = "", ;
		Top = 2, ;
		Width = 49
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdPrint' AS commandbutton WITH ;
		Caption = "\<Imprimir", ;
		Enabled = .T., ;
		FontName = "MS Sans Serif", ;
		FontSize = 8, ;
		Height = 24, ;
		Left = 58, ;
		Name = "cmdPrint", ;
		StatusBarText = "Imprimir a un informe", ;
		TabIndex = 6, ;
		ToolTipText = "", ;
		Top = 2, ;
		Width = 49
		*< END OBJECT: BaseClass="commandbutton" />
	
	PROCEDURE addrec		&& Adds a new record.
		#DEFINE C_NOUPDATE_LOC	"No puede agregar un nuevo registro porque las vistas seleccionadas no envían actualizaciones."
		
		IF EMPTY(ALIAS())
			RETURN .F.
		ENDIF
		
		LOCAL lnSaveRec,lcSaveData,loAddRec,loCustom,cPapaKey
		
		IF EOF() OR BOF()
			GO TOP
		ENDIF
		lnSaveRec = RECNO()
		
		DO CASE
		CASE CURSORGETPROP("SourceType")#3 AND ;
		  !CURSORGETPROP("offline") AND ;
		  !CURSORGETPROP("SendUpdates")
			MESSAGEBOX(C_NOUPDATE_LOC)
			RETURN .F.
		CASE EMPTY(CURSORGETPROP("database")) 
			* Free table
			APPEND BLANK
		CASE CURSORGETPROP("SourceType")#3
			* View
			APPEND BLANK
		CASE CURSORGETPROP("buffering")#1 AND !THIS.lPromptKey
			* buffered data
			APPEND BLANK
		OTHERWISE
			lcSaveData = SET("DATABASE")
			SET DATABASE TO CURSORGETPROP("database")
			cPapaKey = DBGETPROP(CURSORGETPROP("sourcename"),"Table","PrimaryKey")
			SET DATABASE TO &lcSaveData
			IF EMPTY(cPapakey)
				APPEND BLANK
			ELSE
				loAddRec=NewObject("AddRecord",THIS.ClassLibrary,"")
				loCustom = Create('custom')
				loAddRec.cKeyField = cPapaKey
				loAddRec.cKeyValue = EVAL(cPapaKey)
				loAddRec.oRetValue = loCustom
				loAddRec.Show()
				IF loCustom.nBtnAction=1
					INSERT INTO (ALIAS()) ((cPapaKey)) VALUES(loCustom.cKeyValue)
				ELSE
					THIS.HadError = .T.	
				ENDIF
			ENDIF
		ENDCASE
		
		IF THIS.HadError
			THIS.HadError = .F.
			GO lnSaveRec
			RETURN .F.
		ENDIF
		
		THISFORM.Refresh()
	ENDPROC

	PROCEDURE checkerror
		#DEFINE ERR_UNIQUEKEY3_LOC  "Se ha producido una infracción de error de clave única. Se deshará el registro."
		
		AERROR(aGetErrors)
		IF aGetErrors[1] = 1884
			* Uniqueness ID error
			MESSAGEBOX(ERR_UNIQUEKEY3_LOC)
			TABLEREVERT(.T.)
		ENDIF
		
	ENDPROC

	PROCEDURE deleterec		&& Deletes current record.
		#DEFINE MSGBOX_YES		6
		#DEFINE C_MSGBOX1		36
		#DEFINE C_DELETE_LOC	"¿Desea eliminar este registro?"
		
		IF EMPTY(ALIAS())
			RETURN .F.
		ENDIF
		
		IF MESSAGEBOX(C_DELETE_LOC,C_MSGBOX1) = MSGBOX_YES
			DELETE
			IF THIS.UpdateRows()  &&success
				* Success
				IF !EOF()
					SKIP 1
				ENDIF
				IF EOF() AND !BOF()
					SKIP -1
				ENDIF
			ENDIF
			THISFORM.REFRESH()
		ENDIF
		
		IF THISFORM.ShowWindow = 2
			Activate Window (THISFORM.Name)
		ENDIF
		
	ENDPROC

	PROCEDURE Destroy
		* Restore various settings
		LOCAL nTablesUsed,aTablesUsed,i,nDECursors,aDECursors,cDataEnvRef 
		DIMENSION aTablesUsed[1]
		nDECursors = 0
		
		IF TYPE('THIS.Parent') # "O"
			RETURN
		ENDIF
		
		IF TYPE("THIS.oldTalk") = "C" AND THIS.oldTalk="ON"
			SET TALK ON
		ENDIF
		
		IF THIS.UseDataEnv
			DIMENSION aDECursors[1]
			DO CASE
			CASE TYPE("THISFORM.DataEnvironment") = "O"
				nDECursors = AMEMBERS(aDECursors,THISFORM.DataEnvironment,2)
				cDataEnvRef = "THISFORM.DataEnvironment"
			CASE TYPE("THISFORMSET.DataEnvironment") = "O"
				nDECursors = AMEMBERS(aDECursors,THISFORMSET.DataEnvironment,2)
				cDataEnvRef = "THISFORMSET.DataEnvironment"
			ENDCASE
			FOR i = 1 TO m.nDECursors
				WITH EVAL(m.cDataEnvRef + "." + aDECursors[m.i])
					IF USED(.ALIAS) AND ATC("CURSOR",.BaseClass)#0 AND ;
					  CursorGetProp("sourcetype",.ALIAS)=3 AND ;
					  CursorGetProp("buffering",.ALIAS)>1
						IF !TableUpdate(.T.,.T.,.ALIAS)  && update on exit
							THIS.CheckError()
						ENDIF
						* If your form has General fields, there is a possibility
						* that certain OLE Servers supporting the General fields
						* can send data back to General fields even though they
						* are not in Edit Mode. If you experience problems in
						* closing the form because of thie, you might want to
						* uncomment the line below to resolve this. 
						*
						* CursorSetProp("buffering",1,.ALIAS)	&&optimistic table buffering
					ENDIF
				ENDWITH
			ENDFOR
		ENDIF
		
		* Skip if using preview mode
		IF THIS.PreviewMode
			RETURN
		ENDIF
		
		IF THIS.oldSetDelete = "OFF"
			SET DELETED OFF
		ENDIF
		SET REPROCESS TO THIS.oldReprocess
		SET MESSAGE TO
		SELECT (THIS.nWorkArea)
		
		IF THIS.UseDataEnv AND (!THIS.lAutoBuffer OR nDECursors#0)
			RETURN
		ENDIF
		
		* The following code is here to support forms not using a DataEnvironment.
		m.nTablesUsed = AUSED(aTablesUsed)
		FOR i = 1 TO m.nTablesUsed
			IF CursorGetProp('sourcetype',aTablesUsed[m.i,1])=3	&&skip for views
				IF !TableUpdate(.T.,.T.,aTablesUsed[m.i,1])  && update on exit
					THIS.CheckError()
				ENDIF
				IF THIS.oldBuffering=1
					CursorSetProp("buffering",1,aTablesUsed[m.i,1])	&&optimistic table buffering
				ENDIF
			ENDIF
		ENDFOR
		
		IF THIS.oldBuffering=1 AND THIS.oldSetFields = "ON"
			SET FIELDS ON
		ENDIF
		
	ENDPROC

	PROCEDURE Error
		#DEFINE ERR_UNIQUEKEY_LOC   "Se ha producido una infracción de error de clave única."
		#DEFINE ERR_UNIQUEKEY2_LOC  "¿Desea deshacer los cambios?"
		
		Parameters nError, cMethod, nLine
		LOCAL aFoxErr,nTotErr
		DIMENSION aFoxErr[1]
		nTotErr = AERROR(aFoxErr)
		THIS.HadError = .T.
		
		
		DO CASE
		CASE INLIST(m.nError,1733,1734)  &&property not found -- traps SETALL()
			RETURN
		CASE m.nError=1938  &&no parent
			RETURN
		CASE m.nError=1938  &&no parent
			RETURN
		CASE nToterr>0 AND aFoxErr[1,1] = 1420
			* Corrupt Ole object in General field.
			MESSAGEBOX(aFoxErr[1,2])
			RETURN
		CASE nError = 5  &&record out of range
			IF EOF()
				GO BOTTOM
			ELSE
				GO TOP
			ENDIF
			RETURN
		CASE nError = 1884
			* Uniqueness ID error
			IF CURSORGETPROP("buffering")=1
				MESSAGEBOX(ERR_UNIQUEKEY_LOC)
				RETURN
			ENDIF
			IF MESSAGEBOX(ERR_UNIQUEKEY_LOC+" "+ERR_UNIQUEKEY2_LOC,36)=6
				TABLEREVERT(.T.)
			ENDIF
			RETURN
		ENDCASE
		
		**** Error Dialog ******
		MESSAGEBOX(MESSAGE(1)+CHR(13)+;
			"Error: "+STR(nError)+CHR(13)+;
			MESSAGE()+CHR(13)+;
			"Method: "+cMethod+CHR(13)+;
			"Line: "+STR(nLine))
		
		RETURN
		
	ENDPROC

	PROCEDURE Init
		#DEFINE C_WIZSTYLE			"WIZBTNS.VCX"
		#DEFINE C_WIZDIR 			"WIZARDS\"
		#DEFINE C_PROMPT1_LOC		"Buscar: "
		#DEFINE E_NOSTYLE_LOC		"No se pudo encontrar la biblioteca de clases (WIZBTNS.VCX) necesaria para este formulario. "+"Búsquela."
		
		
		LOCAL cWizHomePath,separator,cWizStyFile
		
		
		IF TYPE('THIS.Parent') # "O"
			RETURN
		ENDIF
		
		IF SET("TALK") = "ON"
			SET TALK OFF
			THIS.oldTalk = "ON"
		ELSE
			THIS.oldTalk = "OFF"
		ENDIF
		
		
		IF ATC(C_WIZSTYLE,SET("CLASSLIB")) = 0
			* Returns just the pathname
			cWizHomePath = _WIZARD
			IF '\' $ cWizHomePath
			   cWizHomePath = SUBSTR(m.cWizHomePath,1,RAT('\',m.cWizHomePath))
			   IF RIGHT(m.cWizHomePath,1) = '\' AND LEN(m.cWizHomePath) > 1 ;
			            AND SUBSTR(m.cWizHomePath,LEN(m.cWizHomePath)-1,1) <> ':'
			         cWizHomePath = SUBSTR(m.cWizHomePath,1,LEN(m.cWizHomePath)-1)
			   ENDIF
			ELSE
			   cWizHomePath = ''
			ENDIF
		
			* Add a backslash unless there is one already there.
			separator = IIF(_MAC,":","\")
			IF !(RIGHT(m.cWizHomePath,1) $ '\:') AND !EMPTY(m.cWizHomePath)
			   m.cWizHomePath= m.cWizHomePath+ m.separator
			ENDIF
		
			DO CASE
			CASE FILE(C_WIZSTYLE)
				cWizFile = C_WIZSTYLE
			CASE FILE(m.cWizHomePath+C_WIZSTYLE)
				cWizFile = m.cWizHomePath+C_WIZSTYLE
			CASE FILE(m.cWizHomePath+C_WIZDIR+C_WIZSTYLE)
				cWizFile = m.cWizHomePath+C_WIZDIR+C_WIZSTYLE	
			CASE FILE(HOME()+C_WIZSTYLE)
				cWizFile = HOME()+C_WIZSTYLE
			CASE FILE(HOME()+C_WIZDIR+C_WIZSTYLE)
				cWizFile = HOME()+C_WIZDIR+C_WIZSTYLE
			OTHERWISE
				=MESSAGEBOX(E_NOSTYLE_LOC)
				cWizFile = GETFILE("VCX",C_PROMPT1_LOC+C_WIZSTYLE)
			ENDCASE
			
			IF ATC(C_WIZSTYLE,m.cWizFile)#0
				SET CLASS TO (m.cWizFile) ADDITIVE
			ELSE
				* Failed to get classlib file
				RETURN .F.
			ENDIF
			
		ENDIF
		
		THIS.InitVars()
		
		IF !EMPTY(ALIAS()) AND ((EOF() OR BOF()) OR THIS.lStartTop)
			GO TOP
		ENDIF
		
	ENDPROC

	PROCEDURE initvars		&& Saves and sets certain environment variables.
		#DEFINE C_NOUPDATEVIEW_LOC	"Puede que las modificaciones en una o más de las vistas no sean permanentes."+"Para solucionarlo, asegúrese de que la casilla de verificación Enviar actualizaciones SQL de la vista está activada en el Diseñador de vistas."
		
		#DEFINE C_READONLY_LOC		"La tabla es de sólo lectura. No podrá modificarla."
		
		LOCAL aTablesUsed,nTablesUsed,i,aMems,nTotMem,cWizFile,lShowedMess,cDataEnvRef
		DIMENSION aTablesUsed[1]
		DIMENSION aMems[1]
		
		THIS.nWorkArea = SELECT()
		THIS.oldSetDelete = SET("DELETED")
		SET DELETED ON
		THIS.oldReprocess = SET("REPROCESS")
		SET REPROCESS TO 0
		THIS.oldSetFields = SET("FIELDS")
		THIS.oldMultiLocks = SET("MULTILOCKS")
		
		* These properties should not be used. They are reserved for use by
		* the Preview button of the Form Wizards.
		THIS.PreviewMode = IIF(TYPE("THIS.PreviewMode")#"L",.F.,THIS.PreviewMode)
		THIS.PreviewInit = IIF(TYPE("THIS.PreviewInit")#"L",.T.,THIS.PreviewInit)
		
		* Check for data environment
		DO CASE
		CASE TYPE("THISFORM.DataEnvironment") = "O"
			THIS.UseDataEnv = .T.
			nTotMem = AMEMBERS(aMems,THISFORM.DataEnvironment,2)
			cDataEnvRef = "THISFORM.DataEnvironment"
		CASE TYPE("THISFORMSET.DataEnvironment") = "O"
			THIS.UseDataEnv = .T.
			nTotMem = AMEMBERS(aMems,THISFORMSET.DataEnvironment,2)
			cDataEnvRef = "THISFORMSET.DataEnvironment"
			IF TYPE("THISFORM")="O" AND !THISFORM.VISIBLE 
				THISFORM.VISIBLE = .T.
			ENDIF
		OTHERWISE
			THIS.UseDataEnv = .F.
		ENDCASE
		
		IF THIS.UseDataEnv
			WITH EVAL(m.cDataEnvRef)
				* Check for Views
				FOR i = 1 TO m.nTotMem
					IF UPPER(EVAL("."+aMems[m.i]+".BaseClass")) = "CURSOR"
						WITH EVAL("."+aMems[m.i])
							IF CURSORGETPROP("SourceType",.Alias)#3
								* Check if we need to requery for deleted records.
								* -- Note: Parameterized views are not requeried so all records will be brought over.
								* To remedy this situation you can place a SET DELETED ON command in the
								* BeforeOpenTables event of the DataEnvironment.
								IF THIS.oldSetDelete = "OFF" AND ATC("?",CURSORGETPROP("SQL",.Alias))=0
									=REQUERY(.Alias)
								ENDIF
								* Check if updates are made
								IF !CURSORGETPROP("SendUpdates",.Alias) AND !m.lShowedMess
									=MESSAGEBOX(C_NOUPDATEVIEW_LOC)
									lShowedMess = .T.
								ENDIF
							ENDIF
						ENDWITH
					ENDIF
				ENDFOR
			ENDWITH
		ENDIF
		
		IF ISREADONLY()
			WAIT WINDOW C_READONLY_LOC TIMEOUT 2
		ENDIF
		
		* Disable appropriate buttons
		THIS.cmdAdd.Enabled = !ISREADONLY()
		THIS.cmdDelete.Enabled = !ISREADONLY()
		
		IF THIS.PreviewMode
			RETURN
		ENDIF
		
		IF (THIS.UseDataEnv AND !THIS.lAutoBuffer) OR EMPTY(ALIAS())
			RETURN
		ENDIF
		
		* The following code is here to support forms not using a DataEnvironment.
		
		THIS.oldBuffering=CursorGetProp("buffering")
		IF THIS.oldBuffering#1
			RETURN
		ENDIF
		
		SET FIELDS OFF
		SET MULTILOCKS ON
		
		m.nTablesUsed = AUSED(aTablesUsed)
		FOR i = 1 TO m.nTablesUsed
			IF CursorGetProp('sourcetype',aTablesUsed[m.i,1])=3	&&skip for views
				CursorSetProp("buffering",5,aTablesUsed[m.i,1])	&&optimistic table buffering
			ENDIF
		ENDFOR
		
	ENDPROC

	PROCEDURE Refresh
		**** Special Preview Mode Handling ****
		IF THIS.PreviewMode AND THIS.PreviewInit
			THIS.PreviewInit = .F.
			THIS.cmdAdd.Enabled = .F.
			THIS.cmdDelete.Enabled = .F.
			THIS.cmdFind.Enabled = .F.
			THIS.cmdPrint.Enabled = .F.
			THIS.cmdExit.Enabled = .F.
			THIS.nWorkArea = SELECT()
		ENDIF
		
	ENDPROC

	PROCEDURE updaterows		&& Handles add, edit and delete operations of records to tables.
		#DEFINE	E_FAIL_LOC			"No se pudo actualizar la tabla:"
		#DEFINE E_PRIMARYKEY_LOC	"Infracción de clave primaria única."
		#DEFINE	E_TRIGGERFAIL_LOC	"Falló el desencadenante."
		#DEFINE	E_FIELDNULL_LOC		"El campo no acepta NULL"
		#DEFINE	E_FIELDRULE_LOC		"Se ha infringido la regla del campo"
		#DEFINE	E_RECORDLOCK_LOC	"Hay otra persona usando ese registro"
		#DEFINE	E_ROWRULE_LOC		"Se ha infringido la regla de la fila"
		#DEFINE	E_UNIQUEINDEX_LOC	"Infracción de índice único"
		#DEFINE	E_DIRTYREC_LOC		"Otro usuario ha modificado los datos. ¿Desea sobrescribir los cambios con sus modificaciones?"
		#DEFINE	E_NOFORCE_LOC		"No se puede forzar actualizaciones de tablas."
		#DEFINE E_PROMPT_LOC	 	"Error: "
		#DEFINE MSGBOX_YES			6
		
		LOCAL aErrors,cErrorMessage,aTablesUsed,nTablesUsed,nTotErr 
		LOCAL nFld,i,nOldArea,lSuccess,lInDBC,lOverwrite,lHadMessage
		
		DIMENSION aTablesUsed[1]
		DIMENSION aErrors[1]
		m.cErrorMessage=""
		m.lSuccess = .T.
		m.nOldArea = SELECT()
		m.nTablesUsed = AUSED(aTablesUsed)
		
		* Can wrap everything in transaction if using strictly DBCs
		
		FOR i = 1 TO m.nTablesUsed
		
			SELECT (aTablesUsed[m.i,1])
		
			m.lInDBC = !EMPTY(CURSORGETPROP("Database"))
			m.cErrorMessage = ""
			m.lOverwrite = .F.
			m.lHadMessage = .F.
		
			DO CASE
			CASE CURSORGETPROP("Buffering") = 1
				* Skip if buffering not on
				LOOP
			CASE GetFldState(0) = 2			&&deleted record
				* Only delete current record and force it
				m.lSuccess = TableUpdate(.F.,.T.)
				IF m.lSuccess				&&successful update
					LOOP
				ENDIF
			CASE !m.lInDBC AND (ATC("2",GetFldState(-1))#0 OR;
				 ATC("3",GetFldState(-1))#0)	
				* Field was edited - in Free Table
				* Since free tables are not supported by transactions,
				* we must process record by record
				m.nModRecord = GetNextMod(0)
				DO WHILE m.nModRecord # 0	&&loop locks all records
					GO m.nModRecord
					m.lSuccess = RLOCK()	&&try to lock record
					IF !m.lSuccess			&&failed to lock record
						m.cErrorMessage = E_RECORDLOCK_LOC
						UNLOCK ALL
						EXIT
					ENDIF
					IF !m.lHadMessage	&&so we don't repeat alert
						* See if record(s) modified by another user
						FOR m.nFld = 1 TO FCOUNT()
							IF TYPE(FIELD(m.nFld)) = "G"	&&skip for General fields
								LOOP					
							ENDIF
							IF OLDVAL(FIELD(m.nFld)) # CURVAL(FIELD(m.nFld))
								m.lHadMessage = .T.
								IF MESSAGEBOX(E_DIRTYREC_LOC,4+48) = MSGBOX_YES
									m.lOverwrite = .T.
								ELSE
									m.lSuccess = .F.
									UNLOCK ALL
									EXIT
								ENDIF
							ENDIF
						ENDFOR
					ENDIF
					m.nModRecord = GetNextMod(m.nModRecord)
				ENDDO
				IF m.lSuccess 	&&was able to lock all records
					m.lSuccess = TableUpdate(.T.,m.lOverwrite)
					IF m.lSuccess &&was able to update all records
						LOOP
					ENDIF	
					UNLOCK ALL
				ENDIF
			CASE m.lInDBC
				BEGIN TRANSACTION
				* Try to update all records in selected table
				m.lSuccess = TableUpdate(.T.,.F.)	&&successful update
				IF m.lSuccess
					END TRANSACTION
					LOOP
				ENDIF
				ROLLBACK
			ENDCASE
		
			* Handle errors
			nTotErr =AERROR(aErrors)
			DO CASE
			CASE nTotErr = 0
			CASE aErrors[1,1] = 1547				&& Unique primary key violation
				m.cErrorMessage = E_PRIMARYKEY_LOC
			CASE aErrors[1,1] = 1539				&& Trigger failed
				m.cErrorMessage = E_TRIGGERFAIL_LOC
			CASE aErrors[1,1] = 1581				&& Field doesn't accept NULL
				m.cErrorMessage = E_FIELDNULL_LOC
			CASE aErrors[1,1] = 1582				&& Field rule violated
				m.cErrorMessage = E_FIELDRULE_LOC
			CASE aErrors[1,1] = 1700				&& Record in use by another user
				m.cErrorMessage = E_RECORDLOCK_LOC
			CASE aErrors[1,1] = 1583				&& Row rule violated
				m.cErrorMessage = E_ROWRULE_LOC
			CASE aErrors[1,1] = 1884				&& Unique index violation
				m.cErrorMessage = E_UNIQUEINDEX_LOC
			CASE aErrors[1,1] = 1585				&& Record changed by another user
		
				IF m.lInDBC		&&handle free tables above
					* Display conflict alert
					IF MESSAGEBOX(E_DIRTYREC_LOC,4+48) = MSGBOX_YES
						*Try to force update
						BEGIN TRANSACTION				
						m.lSuccess = TABLEUPDATE(.T.,.T.)
						IF m.lSuccess
							END TRANSACTION
							LOOP
						ELSE
							ROLLBACK
							=MESSAGEBOX(E_NOFORCE_LOC)
						ENDIF			
					ENDIF
				ENDIF
		
			OTHERWISE
				IF !EMPTY(m.cErrorMessage)	&&for free table handling above
					m.cErrorMessage = E_PROMPT_LOC+aErrors[1,2]
				ENDIF
			ENDCASE
		
			* Had an error we couldn't handle
			=TABLEREVERT(.T.)  &&revert all records
			m.lSuccess = .F.
			IF !EMPTY(m.cErrorMessage)
				=MESSAGEBOX(E_FAIL_LOC+m.cErrorMessage)
			ENDIF
		
		ENDFOR
		
		SELECT (m.nOldArea)
		RETURN m.lSuccess
		
	ENDPROC

	PROCEDURE cmdAdd.Click
		THIS.Parent.AddRec()
	ENDPROC

	PROCEDURE cmdAdd.Error
		LPARAMETERS nError, cMethod, nLine
		this.parent.error(m.nError, m.cMethod, m.nLine)
	ENDPROC

	PROCEDURE cmdDelete.Click
		THIS.Parent.DeleteRec()
		
	ENDPROC

	PROCEDURE cmdDelete.Error
		LPARAMETERS nError, cMethod, nLine
		this.parent.error(m.nError, m.cMethod, m.nLine)
	ENDPROC

	PROCEDURE cmdExit.Click
		THISFORM.Release()
		
	ENDPROC

	PROCEDURE cmdExit.Error
		LPARAMETERS nError, cMethod, nLine
		this.parent.error(m.nError, m.cMethod, m.nLine)
	ENDPROC

	PROCEDURE cmdFind.Click
		LOCAL lVisChange,lStateChange,oSearchDlog
		
		IF EMPTY(ALIAS())
			RETURN .F.
		ENDIF
		
		* Check if SDI Window
		IF THISFORM.ShowWindow = 2 
			IF !_VFP.Visible
				_VFP.Visible = .T.
				lVisChange = .T.
			ENDIF
			IF _SCREEN.WindowState = 1
				_SCREEN.WindowState = 0
				lStateChange = .T.
			ENDIF
		ENDIF
		
		oSearchDlog = CREATE("searchform")
		oSearchDlog.SHOW()
		THISFORM.REFRESH()
		
		IF m.lVisChange
			_VFP.Visible = .F.
		ENDIF
		IF m.lStateChange 
			_SCREEN.WindowState = 1
		ENDIF
		IF THISFORM.ShowWindow = 2 
			Activate Window (THISFORM.Name)
		ENDIF
		
	ENDPROC

	PROCEDURE cmdFind.Error
		LPARAMETERS nError, cMethod, nLine
		this.parent.error(m.nError, m.cMethod, m.nLine)
	ENDPROC

	PROCEDURE cmdPrint.Click
		#DEFINE DIALOG_CLASS "_outputdialog"
		#DEFINE DIALOG_CLASSLIB "_reports.vcx"
		
		LOCAL lcRepName,loOutputDialog,lcDClass
		
		DO CASE
		CASE EMPTY(ALIAS())
			lcRepName = ""
		CASE CURSORGETPROP("sourcetype")=3	&& tables
			lcRepName = FORCEEXT(DBF(),"FRX")
		OTHERWISE
			lcRepName = LEFT(ALIAS(),8)+".FRX"
		ENDCASE
		
		DO CASE
		CASE FILE(DIALOG_CLASSLIB)
			lcDClass = DIALOG_CLASSLIB
		CASE FILE(HOME()+"FFC\"+DIALOG_CLASSLIB)
			lcDClass = HOME()+"FFC\"+DIALOG_CLASSLIB
		CASE FILE("..\FFC\"+DIALOG_CLASSLIB)
			lcDClass = "..\FFC\"+DIALOG_CLASSLIB
		OTHERWISE
			RETURN
		ENDCASE
		
		loOutputDialog = NewObject(DIALOG_CLASS,lcDClass)
		IF VARTYPE(loOutputDialog) # "O"
			RETURN
		ENDIF
		
		IF THIS.Parent.lNoRptSource AND !FILE(lcRepName)
			THIS.Parent.lNoRptSource=.F.
		ENDIF
			
		WITH loOutputDialog
			.cReport= IIF(FILE(lcRepName),lcRepName,"")
			.lPreventSourceChanges=THIS.Parent.lNoRptSource
			.lPreventScopeChanges=THIS.Parent.lNoRptScope
		ENDWITH
		loOutputDialog.Show(1)
		
	ENDPROC

	PROCEDURE cmdPrint.Error
		LPARAMETERS nError, cMethod, nLine
		this.parent.error(m.nError, m.cMethod, m.nLine)
	ENDPROC

ENDDEFINE

DEFINE CLASS nobtns AS baseform OF "wizbase.vcx" 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="Shape1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Shape2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Label1" UniqueID="" Timestamp="" />

	*<PropValue>
		DoCreate = .T.
		Name = "nobtns"
	*</PropValue>

	ADD OBJECT 'Label1' AS label WITH ;
		AutoSize = .T., ;
		BackStyle = 0, ;
		Caption = "Etiqueta1", ;
		FontSize = 14, ;
		Height = 25, ;
		Left = 27, ;
		Name = "Label1", ;
		Top = 12, ;
		Width = 60
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'Shape1' AS shape WITH ;
		Height = 2, ;
		Left = 1, ;
		Name = "Shape1", ;
		Top = 48, ;
		Width = 584
		*< END OBJECT: BaseClass="shape" />

	ADD OBJECT 'Shape2' AS shape WITH ;
		Height = 2, ;
		Left = 3, ;
		Name = "Shape2", ;
		Top = 264, ;
		Width = 584
		*< END OBJECT: BaseClass="shape" />

ENDDEFINE

DEFINE CLASS picbtns AS txtbtns OF "wizbtns.vcx" 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" ProjectClassIcon="stylebmp\picbttns.bmp" ClassIcon="stylebmp\picbttns.bmp" />

	*<DefinedPropArrayMethod>
		*p: wizbmppath
	*</DefinedPropArrayMethod>

	*<PropValue>
		Height = 29
		Name = "picbtns"
		Width = 513
		wizbmppath = (HOME()+"WIZARDS\WIZBMPS\")
		cmdPrev.Caption = ""
		CMDPREV.Left = 51
		cmdPrev.Name = "cmdPrev"
		cmdPrev.Picture = (HOME()+"WIZARDS\WIZBMPS\WZBACK.BMP")
		CMDPREV.ToolTipText = "Registro anterior"
		CMDPREV.Top = 4
		CMDPREV.Width = 50
		cmdNext.Caption = ""
		cmdNext.ColorSource = 0
		CMDNEXT.Left = 102
		cmdNext.Name = "cmdNext"
		cmdNext.Picture = (HOME()+"WIZARDS\WIZBMPS\WZNEXT.BMP")
		CMDNEXT.ToolTipText = "Registro siguiente"
		CMDNEXT.Top = 4
		CMDNEXT.Width = 50
		cmdTop.Caption = ""
		CMDTOP.Left = 0
		cmdTop.Name = "cmdTop"
		cmdTop.Picture = (HOME()+"WIZARDS\WIZBMPS\WZTOP.BMP")
		CMDTOP.ToolTipText = "Primer registro"
		CMDTOP.Top = 4
		CMDTOP.Width = 50
		cmdEnd.Caption = ""
		CMDEND.Left = 153
		cmdEnd.Name = "cmdEnd"
		cmdEnd.Picture = (HOME()+"WIZARDS\WIZBMPS\WZEND.BMP")
		CMDEND.ToolTipText = "Último registro"
		CMDEND.Top = 4
		CMDEND.Width = 50
		cmdFind.Caption = ""
		CMDFIND.Left = 204
		cmdFind.Name = "cmdFind"
		cmdFind.Picture = (HOME()+"WIZARDS\WIZBMPS\WZLOCATE.BMP")
		CMDFIND.ToolTipText = "Buscar registros"
		CMDFIND.Top = 4
		CMDFIND.Width = 50
		cmdPrint.Caption = ""
		CMDPRINT.Left = 255
		cmdPrint.Name = "cmdPrint"
		cmdPrint.Picture = (HOME()+"WIZARDS\WIZBMPS\WZPRINT.BMP")
		CMDPRINT.ToolTipText = "Imprimir informe"
		CMDPRINT.Top = 4
		CMDPRINT.Width = 50
		cmdExit.Caption = ""
		CMDEXIT.Left = 459
		cmdExit.Name = "cmdExit"
		cmdExit.Picture = (HOME()+"WIZARDS\WIZBMPS\WZCLOSE.BMP")
		CMDEXIT.ToolTipText = "Salir del formulario"
		CMDEXIT.Top = 4
		CMDEXIT.Width = 50
		cmdAdd.Caption = ""
		CMDADD.Left = 306
		cmdAdd.Name = "cmdAdd"
		cmdAdd.Picture = (HOME()+"WIZARDS\WIZBMPS\WZNEW.BMP")
		CMDADD.ToolTipText = "Agregar/Guardar registro"
		CMDADD.Top = 4
		CMDADD.Width = 50
		cmdDelete.Caption = ""
		CMDDELETE.Left = 408
		cmdDelete.Name = "cmdDelete"
		cmdDelete.Picture = (HOME()+"WIZARDS\WIZBMPS\WZDELETE.BMP")
		CMDDELETE.ToolTipText = "Eliminar registro"
		CMDDELETE.Top = 4
		CMDDELETE.Width = 50
		cmdEdit.Caption = ""
		CMDEDIT.Left = 357
		cmdEdit.Name = "cmdEdit"
		cmdEdit.Picture = (HOME()+"WIZARDS\WIZBMPS\WZEDIT.BMP")
		CMDEDIT.ToolTipText = "Modificar/Revertir registro"
		CMDEDIT.Top = 4
		CMDEDIT.Width = 50
	*</PropValue>
	
	PROCEDURE Init
		
		TxtBtns::Init()
		THISFORM.ShowTips = .T.
		
	ENDPROC

	PROCEDURE setcaption
		IF !THIS.EditMode
			THIS.cmdAdd.Picture = THIS.wizbmppath+"wznew.bmp"
			THIS.cmdEdit.Picture = THIS.wizbmppath+"wzedit.bmp"
			THIS.cmdAdd.DownPicture = THIS.wizbmppath+"wznew.bmp"
			THIS.cmdEdit.DownPicture = THIS.wizbmppath+"wzedit.bmp"
		ELSE
			THIS.cmdAdd.Picture = THIS.wizbmppath+"wzsave.bmp"
			THIS.cmdEdit.Picture = THIS.wizbmppath+"wzundo.bmp"
			THIS.cmdAdd.DownPicture = THIS.wizbmppath+"wzsave.bmp"
			THIS.cmdEdit.DownPicture = THIS.wizbmppath+"wzundo.bmp"
		ENDIF
	ENDPROC

ENDDEFINE

DEFINE CLASS picformbtns AS gridbtns OF "wizbtns.vcx" 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<PropValue>
		Name = "picformbtns"
		Width = 210
		cmdFind.Caption = ""
		cmdFind.Name = "cmdFind"
		cmdFind.Picture = wizbmps\wzlocate.bmp
		cmdFind.Width = 37
		cmdPrint.Caption = ""
		cmdPrint.Left = 42
		cmdPrint.Name = "cmdPrint"
		cmdPrint.Picture = wizbmps\wzprint.bmp
		cmdPrint.Top = 2
		cmdPrint.Width = 38
		cmdExit.Caption = ""
		cmdExit.Left = 171
		cmdExit.Name = "cmdExit"
		cmdExit.Picture = wizbmps\wzclose.bmp
		cmdExit.Top = 2
		cmdExit.Width = 38
		cmdAdd.Caption = ""
		cmdAdd.Left = 85
		cmdAdd.Name = "cmdAdd"
		cmdAdd.Picture = wizbmps\wznew.bmp
		cmdAdd.Top = 2
		cmdAdd.Width = 38
		cmdDelete.Caption = ""
		cmdDelete.Left = 128
		cmdDelete.Name = "cmdDelete"
		cmdDelete.Picture = wizbmps\wzdelete.bmp
		cmdDelete.Top = 2
		cmdDelete.Width = 38
	*</PropValue>

ENDDEFINE

DEFINE CLASS scrollgrid AS grid 
 	*< CLASSDATA: Baseclass="grid" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="Column1.Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Column1.Container1" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*p: wizbtnstyle
	*</DefinedPropArrayMethod>

	*<PropValue>
		AllowHeaderSizing = .F.
		AllowRowSizing = .F.
		BackColor = 192,192,192
		ColumnCount = 1
		DeleteMark = .F.
		HeaderHeight = 0
		Height = 178
		Highlight = .F.
		HighlightRow = .F.
		Name = "scrollgrid"
		RecordMark = .F.
		RowHeight = 300
		ScrollBars = 2
		SplitBar = .F.
		Width = 369
		wizbtnstyle = gridbtns
		Column1.BackColor = 192,192,192
		Column1.Name = "Column1"
		Column1.Sparse = .F.
		Column1.Width = 500
	*</PropValue>

	ADD OBJECT 'Column1.Container1' AS container WITH ;
		BackStyle = 1, ;
		Height = 200, ;
		Left = 15, ;
		Name = "Container1", ;
		Top = 23, ;
		Width = 200
		*< END OBJECT: BaseClass="container" />

	ADD OBJECT 'Column1.Header1' AS header WITH ;
		Caption = "Encabezado1", ;
		Name = "Header1"
		*< END OBJECT: BaseClass="header" />

ENDDEFINE

DEFINE CLASS scrollgrid2 AS scrollgrid OF "wizbtns.vcx" 
 	*< CLASSDATA: Baseclass="grid" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*p: wizrowstretch
	*</DefinedPropArrayMethod>

	*<PropValue>
		Name = "scrollgrid2"
		wizrowstretch = .T.
		Column1.Container1.Name = "Container1"
		Column1.Header1.Name = "Header1"
		Column1.Name = "Column1"
	*</PropValue>

ENDDEFINE

DEFINE CLASS searchclass AS container 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" ProjectClassIcon="stylebmp\searchcl.bmp" ClassIcon="stylebmp\searchcl.bmp" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="cboFields1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cboOperators1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtExpr1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cboFields2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cboOperators2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtExpr2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="optgrpAndOr" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="label1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="label2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="label3" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="label4" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="label5" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="label6" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkCaseSensitive" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: dataexpr
		*m: searchexpr
		*m: searchitem
		*p: remotedelimeter
	*</DefinedPropArrayMethod>

	*<PropValue>
		BackColor = 192,192,192
		BackStyle = 0
		Height = 160
		Name = "searchclass"
		remotedelimeter = (.F.)
		TabIndex = 1
		Width = 452
	*</PropValue>

	ADD OBJECT 'cboFields1' AS combobox WITH ;
		ControlSource = "", ;
		FontName = "MS Sans Serif", ;
		FontSize = 8, ;
		Height = 23, ;
		Left = 11, ;
		Name = "cboFields1", ;
		Style = 2, ;
		TabIndex = 1, ;
		Top = 25, ;
		Width = 141
		*< END OBJECT: BaseClass="combobox" />

	ADD OBJECT 'cboFields2' AS combobox WITH ;
		FontName = "MS Sans Serif", ;
		FontSize = 8, ;
		Height = 23, ;
		Left = 11, ;
		Name = "cboFields2", ;
		Style = 2, ;
		TabIndex = 4, ;
		Top = 117, ;
		Width = 141
		*< END OBJECT: BaseClass="combobox" />

	ADD OBJECT 'cboOperators1' AS combobox WITH ;
		Alignment = 0, ;
		FontName = "MS Sans Serif", ;
		FontSize = 8, ;
		Height = 23, ;
		Left = 158, ;
		Name = "cboOperators1", ;
		Style = 2, ;
		TabIndex = 2, ;
		Top = 25, ;
		Width = 96
		*< END OBJECT: BaseClass="combobox" />

	ADD OBJECT 'cboOperators2' AS combobox WITH ;
		FontName = "MS Sans Serif", ;
		FontSize = 8, ;
		Height = 23, ;
		Left = 160, ;
		Name = "cboOperators2", ;
		Style = 2, ;
		TabIndex = 5, ;
		Top = 117, ;
		Width = 96
		*< END OBJECT: BaseClass="combobox" />

	ADD OBJECT 'chkCaseSensitive' AS checkbox WITH ;
		AutoSize = .T., ;
		BackStyle = 0, ;
		Caption = "\<Distinguir MAY/min", ;
		FontName = "MS Sans Serif", ;
		FontSize = 8, ;
		Height = 15, ;
		Left = 290, ;
		Name = "chkCaseSensitive", ;
		TabIndex = 8, ;
		Top = 69, ;
		Width = 88
		*< END OBJECT: BaseClass="checkbox" />

	ADD OBJECT 'label1' AS label WITH ;
		BackStyle = 0, ;
		Caption = "Campo:", ;
		FontName = "MS Sans Serif", ;
		FontSize = 8, ;
		Height = 16, ;
		Left = 12, ;
		Name = "label1", ;
		Top = 7, ;
		Width = 102
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'label2' AS label WITH ;
		BackStyle = 0, ;
		Caption = "Operador:", ;
		FontName = "MS Sans Serif", ;
		FontSize = 8, ;
		Height = 16, ;
		Left = 158, ;
		Name = "label2", ;
		Top = 7, ;
		Width = 93
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'label3' AS label WITH ;
		BackStyle = 0, ;
		Caption = "Valor:", ;
		FontName = "MS Sans Serif", ;
		FontSize = 8, ;
		Height = 16, ;
		Left = 262, ;
		Name = "label3", ;
		Top = 7, ;
		Width = 165
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'label4' AS label WITH ;
		BackStyle = 0, ;
		Caption = "Campo:", ;
		FontName = "MS Sans Serif", ;
		FontSize = 8, ;
		Height = 16, ;
		Left = 12, ;
		Name = "label4", ;
		Top = 99, ;
		Width = 102
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'label5' AS label WITH ;
		BackStyle = 0, ;
		Caption = "Operador:", ;
		FontName = "MS Sans Serif", ;
		FontSize = 8, ;
		Height = 16, ;
		Left = 161, ;
		Name = "label5", ;
		Top = 99, ;
		Width = 93
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'label6' AS label WITH ;
		BackStyle = 0, ;
		Caption = "Valor:", ;
		FontName = "MS Sans Serif", ;
		FontSize = 8, ;
		Height = 16, ;
		Left = 262, ;
		Name = "label6", ;
		Top = 99, ;
		Width = 165
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'optgrpAndOr' AS optiongroup WITH ;
		AutoSize = .T., ;
		BackStyle = 0, ;
		ButtonCount = 2, ;
		Height = 46, ;
		Left = 50, ;
		Name = "optgrpAndOr", ;
		TabIndex = 7, ;
		Top = 55, ;
		Value = 1, ;
		Width = 58, ;
		Option1.BackStyle = 0, ;
		OPTION1.Caption = "\<Y", ;
		OPTION1.FontName = "MS Sans Serif", ;
		OPTION1.FontSize = 8, ;
		OPTION1.Height = 18, ;
		OPTION1.Left = 5, ;
		Option1.Name = "Option1", ;
		OPTION1.Top = 5, ;
		OPTION1.Value = 1, ;
		OPTION1.Width = 48, ;
		Option2.BackStyle = 0, ;
		OPTION2.Caption = "\<O", ;
		OPTION2.FontName = "MS Sans Serif", ;
		OPTION2.FontSize = 8, ;
		OPTION2.Height = 18, ;
		OPTION2.Left = 5, ;
		Option2.Name = "Option2", ;
		OPTION2.Top = 23, ;
		OPTION2.Value = 0, ;
		OPTION2.Width = 39
		*< END OBJECT: BaseClass="optiongroup" />

	ADD OBJECT 'txtExpr1' AS textbox WITH ;
		FontName = "MS Sans Serif", ;
		FontSize = 8, ;
		Height = 23, ;
		Left = 260, ;
		Name = "txtExpr1", ;
		TabIndex = 3, ;
		Top = 25, ;
		Width = 176
		*< END OBJECT: BaseClass="textbox" />

	ADD OBJECT 'txtExpr2' AS textbox WITH ;
		FontName = "MS Sans Serif", ;
		FontSize = 8, ;
		Height = 23, ;
		Left = 260, ;
		Name = "txtExpr2", ;
		TabIndex = 6, ;
		Top = 118, ;
		Width = 176
		*< END OBJECT: BaseClass="textbox" />
	
	PROCEDURE dataexpr
		LPARAMETER cDataType,cFldExpr
		
		LOCAL cTmpExpr
		
		DO CASE
		CASE INLIST(m.cDataType,"M","G","P","O","U")
			RETURN ""
		
		CASE m.cDataType = "C"
			IF TYPE("'Test'="+m.cFldExpr) # "L"
				IF THIS.REMOTEDELIMETER
					cTmpExpr = '"'+m.cFldExpr+'"'
				ELSE
					cTmpExpr = "["+m.cFldExpr+"]"
				ENDIF
			ELSE
				cTmpExpr = m.cFldExpr
			ENDIF
			
			* Check for case sensitive
			IF THIS.chkCaseSensitive.Value = 0
				m.cTmpExpr= "UPPER("+m.cTmpExpr+")" 
			ENDIF
			RETURN m.cTmpExpr
			
		CASE INLIST(m.cDataType,"N","F","I","Y","B")
			* Check for any commas and remove
			RETURN ALLTRIM(STR(VAL(STRTRAN(m.cFldExpr,",")),16,4))
		
		CASE INLIST(m.cDataType,"D","T")
			RETURN "{"+CHRTRAN(m.cFldExpr,"{}","")+"}"
		
		OTHERWISE
			RETURN ""
		
		ENDCASE
		
		
	ENDPROC

	PROCEDURE Destroy
		RELEASE aWizFList
		
	ENDPROC

	PROCEDURE searchexpr
		LOCAL cGetExpr1,cGetExpr2,cJoin,cGetExpr
		
		m.cGetExpr1 = THIS.SearchItem(THIS.cboFields1,THIS.cboOperators1,THIS.txtExpr1)
		m.cGetExpr2 = THIS.SearchItem(THIS.cboFields2,THIS.cboOperators2,THIS.txtExpr2)
		m.cJoin = IIF(THIS.optGrpAndOr.value = 2," OR "," AND ")
		
		DO CASE
		CASE EMPTY(m.cGetExpr1) AND EMPTY(m.cGetExpr2)
			m.cGetExpr = ""
		CASE EMPTY(m.cGetExpr2)
			m.cGetExpr = m.cGetExpr1
		CASE EMPTY(m.cGetExpr1)
			m.cGetExpr = m.cGetExpr2
		OTHERWISE
			m.cGetExpr = m.cGetExpr1+m.cJoin+m.cGetExpr2
		ENDCASE
		
		RETURN m.cGetExpr
	ENDPROC

	PROCEDURE searchitem
		LPARAMETERS oField,oOp,oExpr
		LOCAL cExpr,cDataType,cOp,cFldName,cFldExpr,cRetExpr,aExprs,nTotExprs,i
		
		* Check to make sure proper parameters passed
		IF TYPE("m.oField")#"O" OR TYPE("m.oOp")#"O" OR TYPE("m.oExpr")#"O"
			RETURN ""
		ENDIF
		
		m.cFldName = ALLTRIM(m.oField.Value)
		m.cFldExpr = ALLTRIM(m.oExpr.Value)
		
		* If empty expression return empty.
		IF EMPTY(m.cFldExpr) AND !INLIST(m.oOp.listitemid,5,6)
			RETURN ""
		ENDIF
		
		* Get data type of field
		m.cDataType = aWizFList(m.oField.listitemid,2)
		
		IF m.cDataType = "C" AND THIS.chkCaseSensitive.Value = 0
			m.cFldName = "UPPER("+m.cFldName+")" 
		ENDIF
		
		* Get the operator language equivalent
		DO CASE
		CASE m.oOp.listitemid = 1	&& equals
			m.cOp = "="
		CASE m.oOp.listitemid = 2	&& not equals
			m.cOp = "<>"
		CASE m.oOp.listitemid = 3	&& more than
			m.cOp = ">"
		CASE m.oOp.listitemid = 4	&& less than
			m.cOp = "<"
		CASE m.oOp.listitemid = 5	&& is blank
			RETURN "EMPTY("+m.cFldName+")"
		CASE m.oOp.listitemid = 6	&& is NULL
			RETURN "ISNULL("+m.cFldName+")"
		CASE m.cDataType = "L" 		&& don't allow other options for logical type
			m.cOp = "="
		CASE m.oOp.listitemid = 7	&& contains
			m.cFldExpr = THIS.DataExpr("C",m.cFldExpr)
			DO CASE
			CASE m.cDataType = "T"
				RETURN "AT("+m.cFldExpr+",TTOC("+m.cFldName+"))>0"
			CASE m.cDataType = "D"
				RETURN "AT("+m.cFldExpr+",DTOC("+m.cFldName+"))>0"
			CASE INLIST(m.cDataType,"N","F","I","Y","B")
				RETURN "AT("+m.cFldExpr+",ALLTRIM(STR("+m.cFldName+")))>0"
			OTHERWISE
				RETURN "AT("+m.cFldExpr+","+m.cFldName+")>0"
			ENDCASE
		OTHERWISE
			nTotExprs = OCCURS(",",m.cFldExpr)+1
			DIMENSION aExprs[m.nTotExprs]
			FOR i =  1 TO m.nTotExprs
				DO CASE
				CASE m.i = m.nTotExprs
					aExprs[m.i] = SUBSTR(m.cFldExpr,RAT(",",m.cFldExpr)+1)
				CASE m.i =1
					aExprs[m.i] = LEFT(m.cFldExpr,AT(",",m.cFldExpr)-1)
				OTHERWISE
					aExprs[m.i] = SUBSTR(m.cFldExpr,AT(",",m.cFldExpr,m.i-1)+1,;
						AT(",",m.cFldExpr,m.i)-AT(",",m.cFldExpr,m.i-1)-1)
				ENDCASE
				aExprs[m.i] = THIS.DataExpr(m.cDataType,aExprs[m.i])
			ENDFOR
		
			DO CASE
			CASE m.oOp.listitemid = 8	&& in
				m.cFldExpr = ""
				FOR i = 1 TO m.nTotExprs
					m.cFldExpr = m.cFldExpr + aExprs[m.i]
					IF	m.i # m.nTotExprs
						m.cFldExpr = m.cFldExpr + ","			
					ENDIF
				ENDFOR
				RETURN "INLIST("+m.cFldName+","+m.cFldExpr+")"
			CASE m.oOp.listitemid = 9	&& between
				IF ALEN(aExprs)=1
					DIMENSION aExprs[2]
					aExprs[2] = aExprs[1]
				ENDIF
				IF ALEN(aExprs)>2
					DIMENSION aExprs[2]
				ENDIF
				RETURN "BETWEEN("+m.cFldName+","+aExprs[1]+","+aExprs[2]+")"
			OTHERWISE
				RETURN ""
			ENDCASE
		ENDCASE
		
		DO CASE
		CASE INLIST(m.cDataType,"M","G","P","O","U")
			RETURN ""
		CASE m.cDataType = "L"
			IF TYPE(m.cFldName+m.cOp+m.cFldExpr) # "L"
				IF (AT(m.cFldExpr,"fFnN")#0 AND m.cOp # "<>") OR (AT(m.cFldExpr,"tTyY")#0 AND m.cOp = "<>")
					m.cFldName = "!"+m.cFldName
				ENDIF
				RETURN m.cFldName
			ENDIF
		OTHERWISE
			m.cFldExpr = THIS.DataExpr(m.cDataType,m.cFldExpr)
		ENDCASE
		
		IF EMPTY(m.cFldExpr)
			RETURN ""
		ELSE
			RETURN m.cFldName+m.cOp+m.cFldExpr
		ENDIF
		
		
	ENDPROC

	PROCEDURE cboFields1.Init
		#DEFINE NUM_AFIELDS 16
		LOCAL i
		PUBLIC aWizFList
		DIMENSION aWizFList[1]
		=AFIELDS(aWizFList)
		FOR m.i = FCOUNT() TO 1 STEP -1
			IF INLIST(aWizFList[m.i,2],"G","M","U")	&&Memo field
				=ADEL(aWizFList,m.i)
				DIMENSION aWizFList[MAX(1,ALEN(aWizFList,1)-1),NUM_AFIELDS]
			ENDIF
		ENDFOR
		THIS.RowSourceType = 5
		THIS.RowSource = "aWizFList"
		THIS.VALUE = THIS.LIST[1]
		
	ENDPROC

	PROCEDURE cboFields2.Init
		THIS.RowSourceType = 5
		THIS.RowSource = "aWizFList"
		THIS.VALUE = THIS.LIST[1]
		
	ENDPROC

	PROCEDURE cboOperators1.Init
		#DEFINE C_OPERATORS_LOC	"igual\;no igual\;más que\;menos que\;está en blanco\;es NULL\;contiene\;en\;entre"
		THIS.ADDITEM(C_OPERATORS_LOC)
		THIS.VALUE = THIS.LIST[1]
		
	ENDPROC

	PROCEDURE cboOperators1.InteractiveChange
		IF INLIST(THIS.ListItemId,5,6)
			THIS.Parent.TxtExpr1.Value = ""
		ENDIF
		THIS.Parent.TxtExpr1.ENABLED = !INLIST(THIS.ListItemId,5,6)
		
	ENDPROC

	PROCEDURE cboOperators2.Init
		#DEFINE C_OPERATORS_LOC	"equals\;not equals\;more than\;less than\;is blank\;is NULL\;contains\;in\;between"
		THIS.ADDITEM(C_OPERATORS_LOC)
		THIS.VALUE = THIS.LIST[1]
		
	ENDPROC

	PROCEDURE cboOperators2.InteractiveChange
		IF INLIST(THIS.ListItemId,5,6)
			THIS.Parent.TxtExpr2.Value = ""
		ENDIF
		THIS.Parent.TxtExpr2.ENABLED = !INLIST(THIS.ListItemId,5,6)
		
	ENDPROC

	PROCEDURE optgrpAndOr.Init
		THIS.VALUE =1
	ENDPROC

ENDDEFINE

DEFINE CLASS searchform AS form 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" ProjectClassIcon="stylebmp\searchfm.bmp" ClassIcon="stylebmp\searchfm.bmp" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="Searchclass1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Commandgroup1" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*p: changedfilter
		*p: savefilter
		*p: saverecord
	*</DefinedPropArrayMethod>

	*<PropValue>
		AlwaysOnTop = .T.
		AutoCenter = .T.
		BorderStyle = 2
		Caption = "Buscar"
		DoCreate = .T.
		Height = 208
		MaxButton = .F.
		MinButton = .F.
		Name = "searchform"
		ShowWindow = 1
		Width = 448
		WindowType = 1
	*</PropValue>

	ADD OBJECT 'Commandgroup1' AS commandgroup WITH ;
		BackStyle = 0, ;
		BorderStyle = 0, ;
		ButtonCount = 3, ;
		Height = 31, ;
		Left = 103, ;
		Name = "Commandgroup1", ;
		Top = 175, ;
		Value = 1, ;
		Width = 241, ;
		COMMAND1.Caption = "\<Buscar", ;
		COMMAND1.FontName = "MS Sans Serif", ;
		COMMAND1.FontSize = 8, ;
		COMMAND1.Height = 23, ;
		COMMAND1.Left = 0, ;
		Command1.Name = "Command1", ;
		Command1.TabIndex = 1, ;
		COMMAND1.Top = 1, ;
		COMMAND1.Width = 72, ;
		COMMAND2.Caption = "\<Todo", ;
		COMMAND2.FontName = "MS Sans Serif", ;
		COMMAND2.FontSize = 8, ;
		COMMAND2.Height = 23, ;
		COMMAND2.Left = 84, ;
		Command2.Name = "Command2", ;
		Command2.TabIndex = 2, ;
		COMMAND2.Top = 1, ;
		COMMAND2.Width = 72, ;
		Command3.Cancel = .T., ;
		COMMAND3.Caption = "\<Cancelar", ;
		COMMAND3.FontName = "MS Sans Serif", ;
		COMMAND3.FontSize = 8, ;
		COMMAND3.Height = 23, ;
		COMMAND3.Left = 168, ;
		Command3.Name = "Command3", ;
		Command3.TabIndex = 3, ;
		COMMAND3.Top = 1, ;
		COMMAND3.Width = 72
		*< END OBJECT: BaseClass="commandgroup" />

	ADD OBJECT 'Searchclass1' AS searchclass WITH ;
		BorderWidth = 0, ;
		Height = 160, ;
		Left = 0, ;
		Name = "Searchclass1", ;
		TabIndex = 1, ;
		Top = 0, ;
		Width = 452, ;
		cbofields1.Name = "cbofields1", ;
		cbofields1.TabIndex = 1, ;
		cbooperators1.Name = "cbooperators1", ;
		cbooperators1.TabIndex = 2, ;
		txtexpr1.Name = "txtexpr1", ;
		txtexpr1.TabIndex = 3, ;
		cbofields2.Name = "cbofields2", ;
		cbofields2.TabIndex = 4, ;
		cbooperators2.Name = "cbooperators2", ;
		cbooperators2.TabIndex = 5, ;
		txtexpr2.Name = "txtexpr2", ;
		txtexpr2.TabIndex = 6, ;
		optgrpandor.Height = 46, ;
		optgrpandor.Name = "optgrpandor", ;
		OPTGRPANDOR.OPTION1.Left = 5, ;
		optgrpandor.option1.Name = "option1", ;
		OPTGRPANDOR.OPTION1.Top = 5, ;
		OPTGRPANDOR.OPTION1.Value = 1, ;
		OPTGRPANDOR.OPTION2.Left = 5, ;
		optgrpandor.option2.Name = "option2", ;
		OPTGRPANDOR.OPTION2.Top = 23, ;
		OPTGRPANDOR.OPTION2.Value = 0, ;
		optgrpandor.TabIndex = 7, ;
		optgrpandor.Width = 58, ;
		label1.Height = 16, ;
		label1.Left = 12, ;
		label1.Name = "label1", ;
		label1.Top = 7, ;
		label1.Width = 102, ;
		label2.Height = 16, ;
		label2.Left = 158, ;
		label2.Name = "label2", ;
		label2.Top = 7, ;
		label2.Width = 93, ;
		label3.Height = 16, ;
		label3.Left = 262, ;
		label3.Name = "label3", ;
		label3.Top = 7, ;
		label3.Width = 165, ;
		label4.Height = 16, ;
		label4.Left = 12, ;
		label4.Name = "label4", ;
		label4.Top = 99, ;
		label4.Width = 102, ;
		label5.Height = 16, ;
		label5.Left = 161, ;
		label5.Name = "label5", ;
		label5.Top = 99, ;
		label5.Width = 93, ;
		label6.Height = 16, ;
		label6.Left = 262, ;
		label6.Name = "label6", ;
		label6.Top = 99, ;
		label6.Width = 165, ;
		chkCaseSensitive.Height = 15, ;
		chkCaseSensitive.Left = 290, ;
		chkCaseSensitive.Name = "chkCaseSensitive", ;
		chkCaseSensitive.Top = 69, ;
		chkCaseSensitive.Width = 88
		*< END OBJECT: ClassLib="wizbtns.vcx" BaseClass="container" />
	
	PROCEDURE Destroy
		LOCAL cFilterExpr
		IF THIS.ChangedFilter
			IF EMPTY(THIS.SaveFilter)
				SET FILTER TO
			ELSE
				m.cFilterExpr = THIS.SaveFilter
				SET FILTER TO &cFilterExpr
			ENDIF
			IF RECCOUNT() # 0
				GO THIS.SaveRecord
			ENDIF
		ENDIF
		
	ENDPROC

	PROCEDURE Init
		IF !EMPTY(ALIAS())
			THIS.SaveRecord = RECNO()
			THIS.SaveFilter = SET("FILTER")
			THIS.ChangedFilter = .F.
		ENDIF
	ENDPROC

	PROCEDURE Commandgroup1.Click
		#DEFINE NORECSFOUND_LOC		"No se encontró ningún registro que cumpliera su consulta. Pruebe con otra consulta."
		
		DO CASE
		CASE THIS.VALUE = 1		&&SET FILTER condition
			LOCAL cGetExpr,cSavePoint
			SET FILTER TO
			m.cSavePoint = SET("POINT")
			SET POINT TO "."
			m.cGetExpr = THISFORM.SearchClass1.SearchExpr()	
			SET POINT TO &cSavePoint
			IF !EMPTY(m.cGetExpr)
				SET FILTER TO &cGetExpr
				LOCATE
				* Check if no records found
				IF EOF()
					=MESSAGEBOX(NORECSFOUND_LOC)
					THIS.Parent.ChangedFilter = .T.
					RETURN
				ENDIF
				THIS.Parent.ChangedFilter = .F.		&&good query
			ELSE
				LOCATE
			ENDIF
		CASE THIS.VALUE = 2  &&SET FILTER TO all
			SET FILTER TO
			LOCATE
			THIS.Parent.ChangedFilter = .F.			&&good query
		OTHERWISE
		
		ENDCASE
		
		RELEASE THISFORM
	ENDPROC

ENDDEFINE

DEFINE CLASS txtbtns AS container 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" ProjectClassIcon="stylebmp\textbttn.bmp" ClassIcon="stylebmp\textbttn.bmp" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="cmdPrev" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdNext" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdTop" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdEnd" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdFind" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdPrint" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdExit" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdAdd" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdDelete" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdEdit" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: addrec		&& Adds a new record to datasource.
		*m: buttonrefresh		&& Enables/disables buttons.
		*m: getgridref		&& Locates reference to grid object if one exists.
		*m: initvars		&& Saves and sets certain environment variables.
		*m: navigate		&& Navigates record pointer (Top, Prev, Next, End).
		*m: navrefresh		&& Refreshes record navigational buttons.
		*m: printrpt		&& Prints report not using outputdialog (old VFP5 style).
		*m: setallprop		&& Enables/disables editing of data bound objects on form.
		*m: setcaption		&& Changes caption/picture of buttons when edit mode toggled on/off.
		*m: updaterows		&& Handles add, edit and delete operations of records to tables.
		*p: addmode		&& Whether the form is in add mode where a new record is being added (set internally).
		*p: editmode		&& Whether the form is in edit mode (set internally).
		*p: endfile		&& Whether the record pointer is at end of table (set internally).
		*p: gridalias		&& Alias of table used in grid object (set internally).
		*p: gridref		&& Object reference to grid object (set internally).
		*p: haderror		&& Whether an error occurred.
		*p: hasgeneral		&& Whether the form has general field oleboundcontrol object (set internally).
		*p: lautobuffer		&& Whether to automatically buffer data.
		*p: lnorptscope		&& Whether to disable changing scope in reporting dialog.
		*p: lnorptsource		&& Whether to disable changing report/alias source in reporting dialog.
		*p: lpromptkey		&& Whether to always prompt for a unique primary key value when adding new record.
		*p: lstarttop		&& Always start on first record when running form.
		*p: nworkarea		&& Saves old workarea (set internally).
		*p: odatarelation		&& Object reference to data environment (set internally).
		*p: oldalias		&& Saves alias when editing to restore with 1-Many forms (set internally).
		*p: oldbuffering		&& Saves table buffering state (set internally).
		*p: oldmultilocks		&& Saves SET MULTILOCKS (set internally).
		*p: oldrec		&& Saves record number (set internally).
		*p: oldrefresh		&& Saves SET REFRESH (set internally).
		*p: oldreprocess		&& Saves SET REPROCESS (set internally).
		*p: oldsetdelete		&& Saves SET DELETED (set internally).
		*p: oldsetfields		&& Saves SET FIELDS (set internally).
		*p: oldtalk		&& Saves SET TALK (set internally).
		*p: parentkey		&& Key expression of parent table used in 1-Many form (set internally). Expression is obtained from Comment property of form.
		*p: previewinit		&& For use with Preview button on wizard (set internally).
		*p: previewmode		&& Whether the form is in preview mode for use with Preview button on Wizard (set internally).
		*p: topfile		&& Whether the record pointer is at top of table (set internally).
		*p: usedataenv		&& Whether the form has a data environment object attached (set internally).
		*p: usercontrolmode		&& This mode will allow user added controls such as comboboxes, listboxes and spinners to take on behavior of EditMode.
		*p: viewkey		&& Key expression of child table used in grid object (set internally). Expression is obtained from Tag property of form.
		*p: viewtype		&& Data source type for grid object (set internally).
	*</DefinedPropArrayMethod>

	*<PropValue>
		BackStyle = 0
		BorderWidth = 0
		editmode = 0
		endfile = 0
		Height = 25
		lautobuffer = .T.
		lstarttop = .T.
		Name = "txtbtns"
		nworkarea = 0
		oldbuffering = 1
		oldrec = 0
		oldrefresh = 0
		oldreprocess = 0
		previewinit = .T.
		previewmode = .F.
		TabIndex = 1
		topfile = 0
		usedataenv = .T.
		viewkey = ("")
		Visible = .T.
		Width = 542
	*</PropValue>

	ADD OBJECT 'cmdAdd' AS commandbutton WITH ;
		Caption = "Ag\<regar", ;
		Enabled = .T., ;
		FontName = "MS Sans Serif", ;
		FontSize = 8, ;
		Height = 24, ;
		Left = 324, ;
		Name = "cmdAdd", ;
		Statusbartext = "Agregar nuevo registro/Guardar modificaciones", ;
		TabIndex = 7, ;
		ToolTipText = "", ;
		Top = 0, ;
		Width = 53
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdDelete' AS commandbutton WITH ;
		Caption = "\<Eliminar", ;
		Enabled = .T., ;
		FontName = "MS Sans Serif", ;
		FontSize = 8, ;
		Height = 24, ;
		Left = 432, ;
		Name = "cmdDelete", ;
		Statusbartext = "Eliminar un registro existente", ;
		TabIndex = 9, ;
		ToolTipText = "", ;
		Top = 0, ;
		Width = 53
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdEdit' AS commandbutton WITH ;
		Caption = "\<Modificar", ;
		Enabled = .T., ;
		FontName = "MS Sans Serif", ;
		FontSize = 8, ;
		Height = 24, ;
		Left = 378, ;
		Name = "cmdEdit", ;
		Statusbartext = "Modificar registro existente/Revertir modificaciones", ;
		TabIndex = 8, ;
		ToolTipText = "", ;
		Top = 0, ;
		Width = 53
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdEnd' AS commandbutton WITH ;
		Caption = "Ú\<ltimo", ;
		FontName = "MS Sans Serif", ;
		FontSize = 8, ;
		Height = 24, ;
		Left = 168, ;
		Name = "cmdEnd", ;
		Statusbartext = "Ir a la parte inferior de la tabla", ;
		TabIndex = 4, ;
		ToolTipText = "", ;
		Top = 0, ;
		Width = 55
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdExit' AS commandbutton WITH ;
		Caption = "\<Salir", ;
		Enabled = .T., ;
		FontName = "MS Sans Serif", ;
		FontSize = 8, ;
		Height = 24, ;
		Left = 486, ;
		Name = "cmdExit", ;
		Statusbartext = "Salir del formulario de entrada", ;
		TabIndex = 10, ;
		ToolTipText = "", ;
		Top = 0, ;
		Width = 53
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdFind' AS commandbutton WITH ;
		Caption = "\<Buscar", ;
		Enabled = .T., ;
		FontName = "MS Sans Serif", ;
		FontSize = 8, ;
		Height = 24, ;
		Left = 224, ;
		Name = "cmdFind", ;
		Statusbartext = "Buscar registros", ;
		TabIndex = 5, ;
		ToolTipText = "", ;
		Top = 0, ;
		Width = 49
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdNext' AS commandbutton WITH ;
		Caption = "Siguie\<nte", ;
		FontName = "MS Sans Serif", ;
		FontSize = 8, ;
		Height = 24, ;
		Left = 112, ;
		Name = "cmdNext", ;
		Statusbartext = "Saltar al registro siguiente", ;
		TabIndex = 3, ;
		ToolTipText = "", ;
		Top = 0, ;
		Width = 55
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdPrev' AS commandbutton WITH ;
		Caption = "\<Anterior", ;
		FontName = "MS Sans Serif", ;
		FontSize = 8, ;
		Height = 24, ;
		Left = 56, ;
		Name = "cmdPrev", ;
		Statusbartext = "Saltar al registro anterior", ;
		TabIndex = 2, ;
		ToolTipText = "", ;
		Top = 0, ;
		Width = 55
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdPrint' AS commandbutton WITH ;
		Caption = "\<Imprimir", ;
		Enabled = .T., ;
		FontName = "MS Sans Serif", ;
		FontSize = 8, ;
		Height = 24, ;
		Left = 274, ;
		Name = "cmdPrint", ;
		Statusbartext = "Imprimir a un informe", ;
		TabIndex = 6, ;
		ToolTipText = "", ;
		Top = 0, ;
		Width = 49
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdTop' AS commandbutton WITH ;
		Caption = "\<Primero", ;
		FontName = "MS Sans Serif", ;
		FontSize = 8, ;
		Height = 24, ;
		Left = 0, ;
		Name = "cmdTop", ;
		Statusbartext = "Ir a la parte superior de la tabla", ;
		TabIndex = 1, ;
		ToolTipText = "", ;
		Top = 0, ;
		Width = 55
		*< END OBJECT: BaseClass="commandbutton" />
	
	PROCEDURE addrec		&& Adds a new record to datasource.
		#DEFINE OPT_CANCEL			0
		#DEFINE OPT_ADD_PARENT		1
		#DEFINE OPT_ADD_CHILD		2
		#DEFINE OPT_ADD_BOTH		3
		#DEFINE MB_Q_YESNO			36
		#DEFINE MB_A_YES			6
		
		#DEFINE C_KEYFLDNOUPDATE_LOC	"El campo que relaciona la vista de la cuadrícula con el origen de datos primario no es actualizable. "+"¿Desea simplemente agregar un nuevo registro a la tabla primaria?"
		
		#DEFINE C_BADCHILDKEY_LOC		"Los campos que relacionan las tablas primaria y secundaria no tienen el mismo tipo de datos. "+"¿Desea simplemente agregar un nuevo registro a la tabla primaria?"
		
		#DEFINE C_NOCHILDUPDATE_LOC		"El origen de datos secundario es una vista y no envía actualizaciones. "+"¿Desea agregar un nuevo registro a la tabla primaria?"
		
		#DEFINE C_NOOBJ_LOC		"No se pudo crear la clase de formulario Agregar registro. Active o reinstale el archivo WIZBTNS.VCX."
		#DEFINE C_NOUPDATE_LOC	"No puede agregar un nuevo registro porque las vistas seleccionadas no envían actualizaciones."
		#DEFINE C_NOUPDATE2_LOC	"No puede agregar un nuevo registro porque las vistas seleccionadas no envían actualizaciones y el origen de datos secundario tiene una clave principal."
		
		LOCAL oSearchDlog,oAddRec,cChildAlias,cPapaAlias,i,lPrimeKey,nPapakey
		LOCAL cPapaKey,cChildKey,nSaveSess,oRel,cTagName,lBadViewKey,nSaveRec,nSaveRec2
		LOCAL lBadChildKey,lUpdatableParentKey,lNoSendParentUpdates,lNoSendChildUpdates
		LOCAL lcSaveData,loAddRec,loCustom 
		
		IF EMPTY(ALIAS())
			RETURN .F.
		ENDIF
		
		THIS.OldAlias = ALIAS()	&&save alias in case reverting
		THIS.OldRec = RECNO()	&&save record in case reverting
		
		IF EMPTY(THIS.GridRef)		&& not using Grid object
			
			DO CASE
			CASE CURSORGETPROP("SourceType")#3 AND ;
			  !CURSORGETPROP("offline") AND ;
			  !CURSORGETPROP("SendUpdates")
				MESSAGEBOX(C_NOUPDATE_LOC)
				RETURN .F.
			CASE EMPTY(CURSORGETPROP("database")) 
				* Free table
				APPEND BLANK
			CASE CURSORGETPROP("SourceType")#3
				* View
				APPEND BLANK
			CASE CURSORGETPROP("buffering")#1 AND !THIS.lPromptKey
				* buffered data
				APPEND BLANK
			OTHERWISE
				lcSaveData = SET("DATABASE")
				SET DATABASE TO CURSORGETPROP("database")
				cPapaKey = DBGETPROP(CURSORGETPROP("sourcename"),"Table","PrimaryKey")
				nPapaKey = TAGNO(cPapaKey)
				SET DATABASE TO &lcSaveData
				IF EMPTY(cPapakey) OR nPapaKey=0
					APPEND BLANK
				ELSE
					cPapaKey = KEY(m.nPapaKey)
					loAddRec=NewObject("AddRecord",THIS.ClassLibrary,"")
					loCustom = Create('custom')
					loAddRec.cKeyField = m.cPapaKey
					loAddRec.cKeyValue = EVAL(m.cPapaKey)
					loAddRec.oRetValue = loCustom
					loAddRec.Show()
					IF loCustom.nBtnAction=1
						INSERT INTO (ALIAS()) ((m.cPapaKey)) VALUES(loCustom.cKeyValue)
					ELSE
						THIS.HadError = .T.	
					ENDIF
				ENDIF
			ENDCASE
			
			IF THIS.HadError
				THIS.HadError = .F.
				SELECT (THIS.OldAlias)
				GO THIS.OldRec 
				RETURN .F.
			ENDIF
			RETURN .T.
		ENDIF
		
		** Code for adding record
		lPrimeKey = .F.				&&is child key primary index
		IF !EMPTY(THIS.oDataRelation)
			oRel = EVAL(THIS.oDataRelation)
		ENDIF
		
		** Get alias and key information	
		DO CASE
		CASE TYPE("m.oRel") = "O"	&&data environment
			WITH oRel
				cPapaAlias = .ParentAlias
				cPapaKey = .RelationalExpr
				cChildAlias = .ChildAlias
				cChildKey = .ChildOrder
			ENDWITH
			oRel = .NULL.	&&reset
		CASE !EMPTY(THIS.ViewKey)	&&using views
			cPapaAlias = ALIAS()
			cPapaKey = THIS.ParentKey
			cChildAlias = THIS.GridAlias
			cChildKey = THIS.ViewKey
			
			* Need to check if Key field is updatable
			IF CURSORGETPROP("SourceType",m.cChildAlias)#3 AND !CURSORGETPROP("offline",m.cChildAlias) AND ;
				ATC(","+m.cChildKey+",",","+CURSORGETPROP("UpdatableFieldList",m.cChildAlias)+",")=0
				lBadViewKey = .T.
			ENDIF
		OTHERWISE
			cPapaAlias = ALIAS()
			cPapaKey = RELATION(1)
			cChildAlias = THIS.GridAlias
			cChildKey = ORDER(m.cChildAlias)
		ENDCASE
		
		** Test to see if both keys are of the same data type
		SELECT (THIS.GridAlias)
		cGridKeyType = ""
		
		IF EMPTY(THIS.ViewKey) AND !EMPTY(m.cChildKey)	&&regular table used 
			* Get the Child Key field since only index tag is here
			* if these is an expression, then default to blank.
			cTagName = ""
			FOR i = 1 TO TagCount("")
				IF UPPER(TAG(m.i)) == UPPER(m.cChildKey)
					cTagName = KEY(m.i)
					lPrimeKey = PRIMARY(m.i)
					EXIT
				ENDIF
			ENDFOR
			
			* Check if we have an index expression here.
			IF ATC("(",m.cTagName)#0 OR ATC("+",m.cTagName)#0 
				cChildKey = ""
			ELSE
				cChildKey = m.cTagName
				cGridKeyType = TYPE(m.cChildKey)
			ENDIF
		ENDIF
		
		IF CURSORGETPROP("SourceType",m.cPapaAlias)#3 AND !CURSORGETPROP("offline",m.cPapaAlias) AND ;
		 !CURSORGETPROP("SendUpdates",m.cPapaAlias)
			lNoSendParentUpdates = .T.
		ENDIF
		IF CURSORGETPROP("SourceType",m.cChildAlias)#3 AND !CURSORGETPROP("offline",m.cChildAlias) AND ;
		 !CURSORGETPROP("SendUpdates",m.cChildAlias)
			lNoSendChildUpdates = .T.
		ENDIF
		
		* Check if have two views and both do not send updates	
		IF m.lNoSendParentUpdates AND m.lNoSendChildUpdates
			=MESSAGEBOX(C_NOUPDATE_LOC)
			RETURN .F.
		ENDIF
		
		SELECT (THIS.OldAlias )
		IF !EMPTY(m.cGridKeyType) AND m.cGridKeyType # TYPE(m.cPapaKey)
			lBadChildKey = .T.
		ENDIF
		
		* Handle appends here
		DO CASE
		CASE m.lNoSendParentUpdates AND (m.lBadViewKey OR m.lBadChildKey)
			=MESSAGEBOX(C_NOUPDATE_LOC)
			RETURN .F.
		CASE m.lPrimeKey AND m.lNoSendParentUpdates
			=MESSAGEBOX(C_NOUPDATE2_LOC)
			RETURN .F.
		CASE m.lNoSendChildUpdates	&&child view does not send updates
			IF MESSAGEBOX(C_NOCHILDUPDATE_LOC,MB_Q_YESNO) # MB_A_YES
				RETURN .F.
			ENDIF 
			APPEND BLANK
		CASE m.lBadViewKey	&&view key in not updatable
			IF MESSAGEBOX(C_KEYFLDNOUPDATE_LOC,MB_Q_YESNO) # MB_A_YES
				RETURN .F.
			ENDIF
			APPEND BLANK
		CASE m.lBadChildKey 	&&bad child key -- different data type from parent
			IF MESSAGEBOX(C_BADCHILDKEY_LOC,MB_Q_YESNO) # MB_A_YES
				RETURN .F.
			ENDIF
			APPEND BLANK
		OTHERWISE
			* Need to check if Key field is updatable
			lUpdatableParentKey = .T.
			IF CURSORGETPROP("SourceType",m.cPapaAlias)#3 AND !CURSORGETPROP("offline",m.cPapaAlias) AND;
				ATC(","+m.cPapaKey+",",","+CURSORGETPROP("UpdatableFieldList",m.cPapaAlias)+",")=0
				* cPapaKey = ""
				lUpdatableParentKey = .F.
			ENDIF
		
			* Check for expression in cPapaKey if so, then do not update record with keyvalue
			IF ATC("(",m.cPapaKey)#0 OR ATC("+",m.cPapaKey)#0
				cPapaKey = ""
			ENDIF
		
			nSaveSess = SET("DATASESSION")
			oAddRec = CREATE("GridAddRec")
			IF TYPE("m.oAddRec") # "O"
				=MESSAGEBOX(C_NOOBJ_LOC)
				RETURN .F.
			ENDIF
			oAddRec.ChildPrimaryKey = m.lPrimeKey
			oAddRec.UpdatableParentKey = m.lUpdatableParentKey
			oAddRec.NoSendUpdates = m.lNoSendParentUpdates
			oAddRec.KeyField = m.cPapaKey
			oAddRec.KeyValue = 	IIF(!EMPTY(m.cPapaKey),EVAL(m.cPapaKey),"")
			oAddRec.RunAddForm()
			IF oAddRec.AddOption = OPT_CANCEL
				RETURN .F.
			ENDIF
		
			SET DATASESSION TO nSaveSess
			SELECT (THIS.OldAlias)
			
			IF TYPE("oAddRec.KeyValue") = "C"
				oAddRec.KeyValue = TRIM(oAddRec.KeyValue)
			ENDIF
			
			* Add record to parent table
			nSaveRec = RECNO()
			IF INLIST(oAddRec.AddOption,OPT_ADD_PARENT,OPT_ADD_BOTH)
				IF EMPTY(m.cPapaKey)
					APPEND BLANK IN (m.cPapaAlias)
				ELSE
					INSERT INTO (m.cPapaAlias) ((oAddRec.KeyField)) VALUES(oAddRec.KeyValue)
				ENDIF
			ENDIF
			nSaveRec2 = RECNO()
		
			* Add child record
			IF INLIST(oAddRec.AddOption,OPT_ADD_CHILD,OPT_ADD_BOTH)
				* Need to check
				GO m.nSaveRec
				IF EMPTY(m.cChildKey) OR ;
					TYPE(m.cChildAlias+"."+m.cChildKey) # TYPE("oAddRec.KeyValue")
					APPEND BLANK IN (m.cChildAlias)
				ELSE
					INSERT INTO (m.cChildAlias) ((m.cChildKey)) VALUES(oAddRec.KeyValue)
				ENDIF
				GO m.nSaveRec2
			ENDIF
		ENDCASE
		
		IF THIS.HadError
			THIS.HadError = .F.
			SELECT (lnSaveAlias3)
			GO lnSaveRec3
			RETURN .F.
		ENDIF
		
	ENDPROC

	PROCEDURE buttonrefresh		&& Enables/disables buttons.
		* This is a generic routine which refreshes the buttons
		* for appropriate table environments.
		IF SELECT()# THIS.nWorkArea
			SELECT (THIS.nWorkArea)
		ENDIF
		
		THIS.SetAllProp()
		THIS.cmdFind.Enabled = !THIS.EditMode
		THIS.cmdPrint.Enabled =  !THIS.EditMode
		THIS.cmdExit.Enabled =  !THIS.EditMode
		THIS.cmdDelete.Enabled =  !THIS.EditMode AND !ISREADONLY()
		THIS.SetCaption()
	ENDPROC

	PROCEDURE Destroy
		* Restore various settings
		LOCAL nTablesUsed,aTablesUsed,i,nDECursors,aDECursors,cDataEnvRef 
		DIMENSION aTablesUsed[1]
		
		IF TYPE('THIS.Parent') # "O"
			RETURN
		ENDIF
		
		IF TYPE("THIS.oldTalk") = "C" AND THIS.oldTalk="ON"
			SET TALK ON
		ENDIF
		
		IF THIS.UseDataEnv
			DIMENSION aDECursors[1]
			DO CASE
			CASE TYPE("THISFORM.DataEnvironment") = "O"
				nDECursors = AMEMBERS(aDECursors,THISFORM.DataEnvironment,2)
				cDataEnvRef = "THISFORM.DataEnvironment"
			CASE TYPE("THISFORMSET.DataEnvironment") = "O"
				nDECursors = AMEMBERS(aDECursors,THISFORMSET.DataEnvironment,2)
				cDataEnvRef = "THISFORMSET.DataEnvironment"
			ENDCASE
			FOR i = 1 TO m.nDECursors
				WITH EVAL(m.cDataEnvRef + "." + aDECursors[m.i])
					IF USED(.ALIAS) AND ATC("CURSOR",.BaseClass)#0 AND ;
					  CursorGetProp("sourcetype",.ALIAS)=3 AND ;
					  CursorGetProp("buffering",.ALIAS)>1
						TableRevert(.T.,.ALIAS)
						* If your form has General fields, there is a possibility
						* that certain OLE Servers supporting the General fields
						* can send data back to General fields even though they
						* are not in Edit Mode. If you experience problems in
						* closing the form because of thie, you might want to
						* uncomment the line below to resolve this. 
						*
						* CursorSetProp("buffering",1,.ALIAS)	&&optimistic table buffering
					ENDIF
				ENDWITH
			ENDFOR
		ENDIF
		
		* Skip if using preview mode
		IF THIS.PreviewMode
			RETURN
		ENDIF
		
		IF THIS.oldSetDelete = "OFF"
			SET DELETED OFF
		ENDIF
		SET REPROCESS TO THIS.oldReprocess
		SET MESSAGE TO
		SELECT (THIS.nWorkArea)
		
		IF THIS.UseDataEnv AND !THIS.lAutoBuffer
			RETURN
		ENDIF
		
		IF THIS.oldBuffering#1
			RETURN
		ENDIF
		
		* The following code is here to support
		* forms not using a DataEnvironment.
		m.nTablesUsed = AUSED(aTablesUsed)
		FOR i = 1 TO m.nTablesUsed
			IF CursorGetProp('sourcetype',aTablesUsed[m.i,1])=3	&&skip for views
		*	IF USED(aTablesUsed[m.i,1]) AND ATC(".TMP",DBF(aTablesUsed[m.i,1]))=0	&&skip for views
				=CursorSetProp("buffering",THIS.oldBuffering,aTablesUsed[m.i,1])	&&optimistic table buffering
			ENDIF
		ENDFOR
		
		IF THIS.oldMultiLocks = "OFF"
			SET MULTILOCKS OFF
		ENDIF
		
		IF THIS.oldSetFields = "ON"
			SET FIELDS ON
		ENDIF
		
	ENDPROC

	PROCEDURE Error
		Parameters nError, cMethod, nLine
		LOCAL aFoxErr,nTotErr
		DIMENSION aFoxErr[1]
		nTotErr = AERROR(aFoxErr)
		
		THIS.Haderror = .T.
		
		DO CASE
		CASE INLIST(m.nError,1733,1734)  &&property not found -- traps SETALL()
			RETURN
		CASE m.nError=1938  &&no parent
			RETURN
		CASE nToterr>0 AND aFoxErr[1,1] = 1420
			* Corrupt Ole object in General field.
			=MESSAGEBOX(aFoxErr[1,2])
			RETURN
		CASE nToterr>0 AND aFoxErr[1,1] = 1884
			* Uniqueness ID error
			=MESSAGEBOX(MESSAGE()+CHR(13))
			RETURN
		ENDCASE
		
		**** Error Dialog ******
		=MESSAGEBOX(MESSAGE(1)+CHR(13)+;
			"Error: "+STR(nError)+CHR(13)+;
			MESSAGE()+CHR(13)+;
			"Method: "+cMethod+CHR(13)+;
			"Line: "+STR(nLine))
		
		RETURN
		
	ENDPROC

	PROCEDURE getgridref		&& Locates reference to grid object if one exists.
		* Check if we have a grid
		LOCAL aMems,nTotMem,i
		THIS.GridRef = ""
		IF TYPE("THISFORM") = "O"
			DIMENSION aMems[1]
			nTotMem = AMEMBERS(aMems,THISFORM,2)
			WITH THISFORM
				FOR i = 1 TO m.nTotMem 
					IF UPPER(EVAL("."+aMems[m.i]+".BaseClass")) = "GRID"
						THIS.GridRef = aMems[m.i]
						WITH EVAL("."+THIS.GridRef)
							* Check if we have a view and get Tag property
							THIS.ViewType = CURSORGETPROP('sourcetype',.RecordSource)
							THIS.GridAlias = .RecordSource
							IF THIS.ViewType # 3
								THIS.ViewKey = .Tag
								THIS.ParentKey = .Comment
							ENDIF
						ENDWITH				
						EXIT
					ENDIF
				ENDFOR
			ENDWITH
		ENDIF
		
	ENDPROC

	PROCEDURE Init
		#DEFINE C_WIZSTYLE			"WIZBTNS.VCX"
		#DEFINE C_WIZDIR 			"WIZARDS\"
		#DEFINE C_PROMPT1_LOC		"Buscar: "
		#DEFINE E_NOSTYLE_LOC		"No se pudo encontrar la biblioteca de clases (WIZBTNS.VCX) necesaria para este formulario. "+"Búsquela."
		
		
		LOCAL cGridRef,cWizHomePath,separator,cWizStyFile
		
		IF TYPE('THIS.Parent') # "O"
			RETURN
		ENDIF
		
		IF SET("TALK") = "ON"
			SET TALK OFF
			THIS.oldTalk = "ON"
		ELSE
			THIS.oldTalk = "OFF"
		ENDIF
		
		
		IF ATC(C_WIZSTYLE,SET("CLASSLIB")) = 0
			
			* Returns just the pathname
			cWizHomePath = _WIZARD
			IF '\' $ cWizHomePath
			   cWizHomePath = SUBSTR(m.cWizHomePath,1,RAT('\',m.cWizHomePath))
			   IF RIGHT(m.cWizHomePath,1) = '\' AND LEN(m.cWizHomePath) > 1 ;
			            AND SUBSTR(m.cWizHomePath,LEN(m.cWizHomePath)-1,1) <> ':'
			         cWizHomePath = SUBSTR(m.cWizHomePath,1,LEN(m.cWizHomePath)-1)
			   ENDIF
			ELSE
			   cWizHomePath = ''
			ENDIF
		
			* Add a backslash unless there is one already there.
			separator = IIF(_MAC,":","\")
			IF !(RIGHT(m.cWizHomePath,1) $ '\:') AND !EMPTY(m.cWizHomePath)
			   m.cWizHomePath= m.cWizHomePath+ m.separator
			ENDIF
		
			DO CASE
			CASE FILE(C_WIZSTYLE)
				cWizFile = C_WIZSTYLE
			CASE FILE(m.cWizHomePath+C_WIZSTYLE)
				cWizFile = m.cWizHomePath+C_WIZSTYLE
			CASE FILE(m.cWizHomePath+C_WIZDIR+C_WIZSTYLE)
				cWizFile = m.cWizHomePath+C_WIZDIR+C_WIZSTYLE	
			CASE FILE(HOME()+C_WIZSTYLE)
				cWizFile = HOME()+C_WIZSTYLE
			CASE FILE(HOME()+C_WIZDIR+C_WIZSTYLE)
				cWizFile = HOME()+C_WIZDIR+C_WIZSTYLE
			OTHERWISE
				=MESSAGEBOX(E_NOSTYLE_LOC)
				cWizFile = GETFILE("VCX",C_PROMPT1_LOC+C_WIZSTYLE)
			ENDCASE
			
			IF ATC(C_WIZSTYLE,m.cWizFile)#0
				SET CLASS TO (m.cWizFile) ADDITIVE
			ELSE
				* Failed to get WIZSTYLE.VCX file
				RETURN .F.
			ENDIF
			
		ENDIF
		
		THIS.InitVars()
		
		IF THIS.lStartTop AND !EMPTY(ALIAS())
			GO TOP
		ENDIF
		
		THIS.ButtonRefresh()
		THIS.NavRefresh()
		
		cGridRef=THIS.GridRef
		IF !EMPTY(m.cGridRef)
			* Change this if you desire to have the grid initially selected.
			* THISFORM.&cGridRef..SetFocus()
		ENDIF
		
	ENDPROC

	PROCEDURE initvars		&& Saves and sets certain environment variables.
								
		#DEFINE C_NOUPDATEVIEW_LOC	"Puede que las modificaciones en una o más de las vistas no sean permanentes."+"Para solucionarlo, asegúrese de que la casilla de verificación Enviar actualizaciones SQL de la vista está activada en el Diseñador de vistas."
		
		#DEFINE C_READONLY_LOC		"La tabla es de sólo lectura. No podrá modificarla."
		
		LOCAL aTablesUsed,nTablesUsed,i,aMems,nTotMem,cWizFile,lShowedMess,cDataEnvRef
		DIMENSION aTablesUsed[1]
		DIMENSION aMems[1]
		
		* This routine sets the member variables
		THIS.ViewKey = ""
		THIS.ParentKey = ""
		THIS.ViewType = 3
		THIS.GridAlias = ""
		THIS.TopFile = .F.
		THIS.EndFile = .F.
		THIS.AddMode = .F.
		
		THIS.nWorkArea = SELECT()
		THIS.oldSetDelete = SET("DELETED")
		SET DELETED ON
		THIS.oldReprocess = SET("REPROCESS")
		SET REPROCESS TO 0
		THIS.oldMultiLocks = SET("MULTILOCKS")
		THIS.oldSetFields = SET("FIELDS")
		
		* These properties should not be used. They are reserved for use by
		* the Preview button of the Form Wizards.
		THIS.PreviewMode = IIF(TYPE("THIS.PreviewMode")#"L",.F.,THIS.PreviewMode)
		THIS.PreviewInit = IIF(TYPE("THIS.PreviewInit")#"L",.T.,THIS.PreviewInit)
		
		* Check for data environment
		DO CASE
		CASE TYPE("THISFORM.DataEnvironment") = "O"
			THIS.UseDataEnv = .T.
			nTotMem = AMEMBERS(aMems,THISFORM.DataEnvironment,2)
			cDataEnvRef = "THISFORM.DataEnvironment"
		CASE TYPE("THISFORMSET.DataEnvironment") = "O"
			THIS.UseDataEnv = .T.
			nTotMem = AMEMBERS(aMems,THISFORMSET.DataEnvironment,2)
			cDataEnvRef = "THISFORMSET.DataEnvironment"
			IF TYPE("THISFORM")="O" AND !THISFORM.VISIBLE 
				THISFORM.VISIBLE = .T.
			ENDIF
		OTHERWISE
			THIS.UseDataEnv = .F.
		ENDCASE
		
		IF THIS.UseDataEnv
			WITH EVAL(m.cDataEnvRef)
				* Check for relation
				FOR i = 1 TO m.nTotMem
					IF UPPER(EVAL("."+aMems[m.i]+".BaseClass")) = "RELATION"
						THIS.oDataRelation = m.cDataEnvRef+"."+aMems[m.i]
						EXIT
					ENDIF
				ENDFOR
				
				* Check for Views
				FOR i = 1 TO m.nTotMem
					IF UPPER(EVAL("."+aMems[m.i]+".BaseClass")) = "CURSOR"
						WITH EVAL("."+aMems[m.i])
							IF CURSORGETPROP("SourceType",.Alias)#3 AND ;
								!CURSORGETPROP("offline",.Alias)
								* Check if we need to requery for deleted records.
								* -- Note: Parameterized views are not requeried so all
								* records will be brought over. To remedy this situation
								* you can place a SET DELETED ON command in the
								* BeforeOpenTables event of the DataEnvironment.
								IF THIS.oldSetDelete = "OFF" AND ATC("?",CURSORGETPROP("SQL",.Alias))=0
									=REQUERY(.Alias)
								ENDIF
								* Check if updates are made
								IF !CURSORGETPROP("SendUpdates",.Alias) AND !m.lShowedMess
									=MESSAGEBOX(C_NOUPDATEVIEW_LOC)
									lShowedMess = .T.
								ENDIF
							ENDIF
						ENDWITH
					ENDIF
				ENDFOR
			ENDWITH
		ENDIF
		
		THIS.EditMode = IIF(TYPE("THIS.EditMode")#"L",.F.,THIS.EditMode)
		
		IF ISREADONLY()
			WAIT WINDOW C_READONLY_LOC TIMEOUT 2
			THIS.EditMode = .F.
		ENDIF
		
		* Disable appropriate buttons
		THIS.cmdAdd.Enabled = !ISREADONLY()
		THIS.cmdEdit.Enabled = !ISREADONLY()
		THIS.cmdDelete.Enabled = !ISREADONLY()
		
		IF THIS.PreviewMode
			RETURN
		ENDIF
		
		THIS.GetGridRef()
		
		IF (THIS.UseDataEnv AND !THIS.lAutoBuffer) OR EMPTY(ALIAS())
			RETURN
		ENDIF
		
		* The following code is here to support forms not using a DataEnvironment or 
		* where there is no data buffering.
		
		THIS.oldBuffering=CursorGetProp("buffering")
		IF THIS.oldBuffering#1
			RETURN
		ENDIF
		
		SET MULTILOCKS ON
		SET FIELDS OFF
		
		m.nTablesUsed = AUSED(aTablesUsed)
		FOR i = 1 TO m.nTablesUsed
			IF CursorGetProp('sourcetype',aTablesUsed[m.i,1])=3	&&skip for views
				CursorSetProp("buffering",5,aTablesUsed[m.i,1])	&&optimistic table buffering
			ENDIF
		ENDFOR
		
	ENDPROC

	PROCEDURE navigate		&& Navigates record pointer (Top, Prev, Next, End).
		LPARAMETER cDirection
		
		SELECT (THIS.nWorkArea)
		IF EMPTY(ALIAS())
			RETURN .F.
		ENDIF
		
		DO CASE
		CASE ATC("TOP",cDirection)#0
			LOCATE
			THIS.TopFile = .T.
			THIS.EndFile = EOF()
		CASE ATC("END",cDirection)#0
			GO BOTTOM
			THIS.TopFile = .F.
			THIS.EndFile = .T.
		CASE ATC("NEXT",cDirection)#0
			IF !EOF()
				SKIP 1
			ENDIF
			THIS.TopFile = BOF()
			THIS.EndFile = EOF()
		CASE ATC("PREV",cDirection)#0
			IF !BOF()
				SKIP -1
			ENDIF
			THIS.TopFile = BOF()
			THIS.EndFile = EOF()
		ENDCASE
		
		THIS.NavRefresh()
		
	ENDPROC

	PROCEDURE navrefresh		&& Refreshes record navigational buttons.
		**** Navigational Button Handling ****
		LOCAL OldLockScreen,KeyValue,cFiltExpr
		m.OldLockScreen = THISFORM.LockScreen
		THISFORM.LockScreen = .T.
		
		IF SELECT()#THIS.nWorkArea
			SELECT (THIS.nWorkArea)
		ENDIF
		
		IF !THIS.EditMode AND !EMPTY(ALIAS())
		
			* Check for bottom of file
			THIS.EndFile = EOF() OR THIS.EndFile
		
			* Test to see we are on last record
			IF !THIS.EndFile
				SKIP
				THIS.EndFile = EOF()
				SKIP -1
			ELSE
				GO BOTTOM
			ENDIF
		
			* Check for top of file
			THIS.TopFile = BOF() OR EOF() OR THIS.TopFile
		
			* Test to see if we are on first record
			IF !THIS.TopFile
				SKIP -1
				THIS.TopFile = BOF()
				IF !THIS.TopFile
					SKIP
				ENDIF	
			ENDIF
		
			IF THIS.TopFile
				GO TOP
			ENDIF
		
		ENDIF
		
		THIS.cmdTop.Enabled = !THIS.TopFile AND !THIS.EditMode
		THIS.cmdPrev.Enabled = !THIS.TopFile AND !THIS.EditMode
		THIS.cmdNext.Enabled = !THIS.EndFile AND !THIS.EditMode
		THIS.cmdEnd.Enabled = !THIS.EndFile AND !THIS.EditMode
		
		* Check if no records in query set
		DO CASE
		CASE THIS.PreviewMode OR ISREADONLY()
			* Nothing
		CASE THIS.EditMode AND CURSORGETPROP("BUFFERING")=1
			THIS.cmdEdit.Enabled = .F.
		CASE THIS.EditMode
			THIS.cmdEdit.Enabled = .T.
		CASE RECCOUNT()=0 OR BOF() OR EOF()
			THIS.cmdEdit.Enabled = .F.
			THIS.cmdDelete.Enabled = .F.
		CASE !THIS.cmdEdit.Enabled
			THIS.cmdEdit.Enabled = .T.
			THIS.cmdDelete.Enabled = .T.
		ENDCASE
		
		
		* Update Grid for Views
		IF !THIS.EditMode AND !EMPTY(THIS.ViewKey)
			KeyValue = EVAL(THIS.ParentKey)
			DO CASE
			CASE TYPE(THIS.ParentKey) = "C"
				cFiltExpr = THIS.ViewKey + "=" + "["+m.KeyValue+"]"
			CASE TYPE(THIS.ParentKey) = "L"
				cFiltExpr = THIS.ViewKey
			CASE TYPE(THIS.ParentKey) = "D"
				cFiltExpr = THIS.ViewKey + "=" + "{"+DTOC(m.KeyValue)+"}"	
			CASE TYPE(THIS.ParentKey) = "T"
				cFiltExpr = THIS.ViewKey + "=" + "{"+TTOC(m.KeyValue)+"}"	
			OTHERWISE	
				* Numeric
				cFiltExpr = THIS.ViewKey + "=" + ALLTRIM(STR(m.KeyValue,20,18))
			ENDCASE
				
			SELECT (THIS.GridAlias)
			DO CASE
			CASE .F. &&parameterized query
				* set parameter here
				* =requery()
			CASE THIS.ViewType = 1	&&local views
				SET FILTER TO &cFiltExpr
			CASE THIS.ViewType = 2	&&remote views
				SET FILTER TO &cFiltExpr
			ENDCASE
			SELECT (THIS.nWorkArea)
		ENDIF
		
		THISFORM.LockScreen = m.OldLockScreen
		THISFORM.Refresh()
		
	ENDPROC

	PROCEDURE printrpt		&& Prints report not using outputdialog (old VFP5 style).
		#DEFINE C_MAKEREPO_LOC			"No se pudo encontrar un informe para imprimir. ¿Desea crear uno nuevo?"
		#DEFINE C_NOOPEN_LOC			"Error al abrir la tabla. No se puede imprimir el informe."
		#DEFINE C_GETFILEPROMPT_LOC		"Imprimir el informe:"
		
		LOCAL cRepName,nSaveSess,cSaveAlias,cSaveSource,cSaveData
		
		cSaveAlias = ALIAS()
		cSaveSource = CURSORGETPROP("SourceName")
		cSaveData = CURSORGETPROP("Database")
		cDiffSource = ""
		cRepName = LEFT(ALIAS(),8)+".FRX"
		nSaveSess = SET("DATASESSION")
		
		IF TYPE("THISFORM.DataEnvironment") = "O"
			lPrivateSession = (THISFORM.DataSession = 2)
		ELSE
			lPrivateSession = (THISFORMSET.DataSession = 2)
		ENDIF
		
		* Handling for Private data sessions
		IF m.lPrivateSession
			IF m.nSaveSess # 1
				SET DATASESSION TO 1
				SELECT 0
				IF !EMPTY(m.cSaveData)
					OPEN DATABASE (m.cSaveData)
				ENDIF
				IF USED(m.cSaveAlias)
					SELECT (m.cSaveAlias)
					IF CURSORGETPROP("SourceName")#m.cSaveSource
						cDiffSource = CURSORGETPROP("SourceName")
						USE IN (m.cSaveAlias)
						SELECT 0
					ENDIF
				ENDIF	
				IF EMPTY(ALIAS())
					USE (m.cSaveSource) AGAIN ALIAS (m.cSaveAlias) SHARED
					IF EMPTY(ALIAS())
						=MESSAGEBOX(C_NOOPEN_LOC)
						RETURN
					ENDIF
				ENDIF
			ENDIF
		ENDIF
		
		IF FILE(m.cRepName)
			REPORT FORM (m.cRepName) PREVIEW NOWAIT
		ELSE
			m.cRepName = GETFILE("frx",C_GETFILEPROMPT_LOC,"",1)
			IF !EMPTY(m.cRepName)
				IF FILE(m.cRepName)
					* User pressed Open button
					REPORT FORM (m.cRepName) PREVIEW NOWAIT
				ELSE
					* User pressed New button
					DO (_WIZARD) WITH "AUTOREPORT"
				ENDIF
			ENDIF
		ENDIF
		
		* Private data session code
		IF m.lPrivateSession
			IF !EMPTY(cDiffSource)
				USE (m.cDiffSource) IN 0
			ENDIF
			SET DATASESSION TO m.nSaveSess
			SELECT (m.cSaveAlias)
		ENDIF
		
		IF THISFORM.ShowWindow = 2 
			Activate Window (THISFORM.Name)
		ENDIF
		
	ENDPROC

	PROCEDURE Refresh
		**** Special Preview Mode Handling ****
		IF THIS.PreviewMode AND THIS.PreviewInit
			THIS.PreviewInit = .F.
			THIS.cmdAdd.Enabled = .F.
			THIS.cmdEdit.Enabled = .F.
			THIS.cmdDelete.Enabled = .F.
			THIS.cmdFind.Enabled = .F.
			THIS.cmdPrint.Enabled = .F.
			THIS.cmdExit.Enabled = .F.
			THIS.nWorkArea = SELECT()
			THIS.GetGridRef()
			THIS.SetAllProp()
			THIS.NavRefresh()
		ENDIF
		
	ENDPROC

	PROCEDURE setallprop		&& Enables/disables editing of data bound objects on form.
		LPARAMETER oContainer
		
		* Checks for General fields
		LOCAL i,oControlParent,nCtrlCount
		
		IF PARAMETERS() = 0
			m.oControlParent = THISFORM
		ELSE
			m.oControlParent = m.oContainer
		ENDIF
		
		DO CASE 
		CASE ATC("Pageframe",m.oControlParent.BaseClass)#0
			nCtrlCount = oControlParent.PageCount
		CASE ATC(m.oControlParent.BaseClass,"Optiongroup,Commandgroup")#0
			nCtrlCount = oControlParent.ButtonCount
		OTHERWISE
			nCtrlCount = oControlParent.ControlCount
		ENDCASE
		
		FOR i = 1 TO m.nCtrlCount 
			DO CASE
			CASE ATC("Pageframe",m.oControlParent.BaseClass)#0
				THIS.SetAllProp(m.oControlParent.Pages[m.i])
				
			CASE ATC(m.oControlParent.BaseClass,"Optiongroup,Commandgroup")#0 AND ;
				THIS.UserControlMode
				m.oControlParent.Buttons[m.i].Enabled = THIS.EditMode
		
			CASE ATC(m.oControlParent.Controls[m.i].BaseClass,"Optiongroup,Commandgroup")#0 ;
				AND THIS.UserControlMode
				THIS.SetAllProp(m.oControlParent.Controls[m.i])
		
			CASE ATC("Container",m.oControlParent.Controls[m.i].BaseClass) # 0 OR; 
				ATC("Page",m.oControlParent.Controls[m.i].BaseClass) # 0
				THIS.SetAllProp(m.oControlParent.Controls[m.i])
		
			CASE ATC(m.oControlParent.Controls[m.i].BaseClass,"ListBox,ComboBox,Spinner") # 0 AND;
				THIS.UserControlMode
				m.oControlParent.Controls[m.i].Enabled = THIS.EditMode
		
			CASE ATC(m.oControlParent.Controls[m.i].BaseClass,"OleBoundControl") # 0
				m.oControlParent.Controls[m.i].Enabled = THIS.EditMode
		
			CASE ATC(m.oControlParent.Controls[m.i].BaseClass,"CheckBox,TextBox,EditBox") # 0
				m.oControlParent.Controls[m.i].ReadOnly = !THIS.EditMode
		
			CASE ATC(m.oControlParent.Controls[m.i].BaseClass,"Grid") # 0
				m.oControlParent.Controls[m.i].ReadOnly = !THIS.EditMode
				m.oControlParent.Controls[m.i].DeleteMark = THIS.EditMode
				
			ENDCASE
		ENDFOR
		
	ENDPROC

	PROCEDURE setcaption		&& Changes caption/picture of buttons when edit mode toggled on/off.
		#DEFINE ADD_CAPTION_LOC		"Ag\<regar"
		#DEFINE EDIT_CAPTION_LOC	"\<Modificar"
		#DEFINE REV_CAPTION_LOC		"Re\<vertir"
		#DEFINE SAVE_CAPTION_LOC	"\<Guardar"
		
		IF THIS.EditMode
			THIS.cmdAdd.Caption = SAVE_CAPTION_LOC
			THIS.cmdEdit.Caption = REV_CAPTION_LOC
		ELSE
			THIS.cmdAdd.Caption = ADD_CAPTION_LOC
			THIS.cmdEdit.Caption = EDIT_CAPTION_LOC
		ENDIF
		
	ENDPROC

	PROCEDURE updaterows		&& Handles add, edit and delete operations of records to tables.
		#DEFINE	E_FAIL_LOC			"Fallo al actualizar la tabla:"
		#DEFINE E_PRIMARYKEY_LOC	"Infracción de clave primaria única."
		#DEFINE	E_TRIGGERFAIL_LOC	"Falló el desencadenante."
		#DEFINE	E_FIELDNULL_LOC		"El campo no acepta NULL"
		#DEFINE	E_FIELDRULE_LOC		"Se ha infringido la regla del campo"
		#DEFINE	E_RECORDLOCK_LOC	"Hay otra persona usando ese registro"
		#DEFINE	E_ROWRULE_LOC		"Se ha infringido la regla de la fila"
		#DEFINE	E_UNIQUEINDEX_LOC	"Infracción de índice único"
		#DEFINE	E_DIRTYREC_LOC		"Otro usuario ha modificado los datos. ¿Desea sobrescribir los cambios con sus modificaciones?"
		#DEFINE	E_NOFORCE_LOC		"No se pudieron forzar las actualizaciones de tablas."
		#DEFINE E_PROMPT_LOC	 	"Error: "
		#DEFINE MSGBOX_YES			6
		
		LOCAL aErrors,cErrorMessage,aTablesUsed,nTablesUsed,nTotErr 
		LOCAL nFld,i,nOldArea,lSuccess,lInDBC,lOverwrite,lHadMessage
		
		DIMENSION aTablesUsed[1]
		DIMENSION aErrors[1]
		m.cErrorMessage=""
		m.lSuccess = .T.
		m.nOldArea = SELECT()
		m.nTablesUsed = AUSED(aTablesUsed)
		
		* Can wrap everything in transaction if using strictly DBCs
		
		FOR i = 1 TO m.nTablesUsed
		
			SELECT (aTablesUsed[m.i,1])
		
			m.lInDBC = !EMPTY(CURSORGETPROP("Database"))
			m.cErrorMessage = ""
			m.lOverwrite = .F.
			m.lHadMessage = .F.
		
			DO CASE
			CASE CURSORGETPROP("Buffering") = 1
				* Skip if buffering not on
				LOOP
			CASE GetFldState(0) = 2			&&deleted record
				* Only delete current record and force it
				m.lSuccess = TableUpdate(.F.,.T.)
				IF m.lSuccess				&&successful update
					LOOP
				ENDIF
			CASE !m.lInDBC AND (ATC("2",GetFldState(-1))#0 OR;
				 ATC("3",GetFldState(-1))#0)	
				* Field was edited - in Free Table
				* Since free tables are not supported by transactions,
				* we must process record by record
				m.nModRecord = GetNextMod(0)
				DO WHILE m.nModRecord # 0	&&loop locks all records
					GO m.nModRecord
					m.lSuccess = RLOCK()	&&try to lock record
					IF !m.lSuccess			&&failed to lock record
						m.cErrorMessage = E_RECORDLOCK_LOC
						UNLOCK ALL
						EXIT
					ENDIF
					IF !m.lHadMessage	&&so we don't repeat alert
						* See if record(s) modified by another user
						FOR m.nFld = 1 TO FCOUNT()
							IF TYPE(FIELD(m.nFld)) = "G"	&&skip for General fields
								LOOP					
							ENDIF
							IF OLDVAL(FIELD(m.nFld)) # CURVAL(FIELD(m.nFld))
								m.lHadMessage = .T.
								IF MESSAGEBOX(E_DIRTYREC_LOC,4+48) = MSGBOX_YES
									m.lOverwrite = .T.
								ELSE
									m.lSuccess = .F.
									UNLOCK ALL
									EXIT
								ENDIF
							ENDIF
						ENDFOR
					ENDIF
					m.nModRecord = GetNextMod(m.nModRecord)
				ENDDO
				IF m.lSuccess 	&&was able to lock all records
					m.lSuccess = TableUpdate(.T.,m.lOverwrite)
					IF m.lSuccess &&was able to update all records
						LOOP
					ENDIF	
					UNLOCK ALL
				ENDIF
			CASE m.lInDBC
				BEGIN TRANSACTION
				* Try to update all records in selected table
				m.lSuccess = TableUpdate(.T.,.F.)	&&successful update
				IF m.lSuccess
					END TRANSACTION
					LOOP
				ENDIF
				ROLLBACK
			ENDCASE
		
			* Handle errors
			nTotErr =AERROR(aErrors)
			DO CASE
			CASE nTotErr = 0
			CASE aErrors[1,1] = 1547				&& Unique primary key violation
				m.cErrorMessage = E_PRIMARYKEY_LOC
			CASE aErrors[1,1] = 1539				&& Trigger failed
				m.cErrorMessage = E_TRIGGERFAIL_LOC
			CASE aErrors[1,1] = 1581				&& Field doesn't accept NULL
				m.cErrorMessage = E_FIELDNULL_LOC
			CASE aErrors[1,1] = 1582				&& Field rule violated
				m.cErrorMessage = E_FIELDRULE_LOC
			CASE aErrors[1,1] = 1700				&& Record in use by another user
				m.cErrorMessage = E_RECORDLOCK_LOC
			CASE aErrors[1,1] = 1583				&& Row rule violated
				m.cErrorMessage = E_ROWRULE_LOC
			CASE aErrors[1,1] = 1884				&& Unique index violation
				m.cErrorMessage = E_UNIQUEINDEX_LOC
			CASE aErrors[1,1] = 1585				&& Record changed by another user
		
				IF m.lInDBC		&&handle free tables above
					* Display conflict alert
					IF MESSAGEBOX(E_DIRTYREC_LOC,4+48) = MSGBOX_YES
						*Try to force update
						BEGIN TRANSACTION				
						m.lSuccess = TABLEUPDATE(.T.,.T.)
						IF m.lSuccess
							END TRANSACTION
							LOOP
						ELSE
							ROLLBACK
							=MESSAGEBOX(E_NOFORCE_LOC)
						ENDIF			
					ENDIF
				ENDIF
		
			OTHERWISE
				IF !EMPTY(m.cErrorMessage)	&&for free table handling above
					m.cErrorMessage = E_PROMPT_LOC+aErrors[1,2]
				ENDIF
			ENDCASE
		
			* Had an error we couldn't handle
			=TABLEREVERT(.T.)  &&revert all records
			m.lSuccess = .F.
			IF !EMPTY(m.cErrorMessage)
				=MESSAGEBOX(E_FAIL_LOC+m.cErrorMessage)
			ENDIF
		
		ENDFOR
		
		SELECT (m.nOldArea)
		RETURN m.lSuccess
		
	ENDPROC

	PROCEDURE cmdAdd.Click
		IF THIS.Parent.EditMode
			THIS.Parent.UpdateRows()
		ELSE
			IF !THIS.Parent.AddRec()
				RETURN
			ENDIF
		ENDIF
		
		THIS.Parent.EditMode = !THIS.Parent.EditMode
		THIS.Parent.AddMode = THIS.Parent.EditMode
		THIS.Parent.TopFile = .F.
		THIS.Parent.ButtonRefresh()
		THIS.Parent.NavRefresh()
		
	ENDPROC

	PROCEDURE cmdAdd.Error
		LPARAMETERS nError, cMethod, nLine
		this.parent.error(m.nError, m.cMethod, m.nLine)
	ENDPROC

	PROCEDURE cmdDelete.Click
		#DEFINE MSGBOX_YES		6
		#DEFINE C_MSGBOX1		36
		#DEFINE C_DELETE_LOC	"¿Desea eliminar este registro?"
		#DEFINE C_NOLOCK_LOC	"No se pudo eliminar el registro porque hay alguien usándolo."
		
		* Note: Cascading deletes should be handled via RI triggers in DBC!
		IF EMPTY(ALIAS())
			RETURN
		ENDIF
		
		IF MESSAGEBOX(C_DELETE_LOC,C_MSGBOX1) = MSGBOX_YES
			DELETE
			IF THIS.Parent.UpdateRows()  &&success
				* Success
				IF !EOF()
					SKIP 1
				ENDIF
				IF EOF() AND !BOF()
					SKIP -1
				ENDIF
			ENDIF
			THIS.Parent.ButtonRefresh()
			THIS.Parent.NavRefresh()
		ENDIF
		
		IF THISFORM.ShowWindow = 2 
			Activate Window (THISFORM.Name)
		ENDIF
		
	ENDPROC

	PROCEDURE cmdDelete.Error
		LPARAMETERS nError, cMethod, nLine
		this.parent.error(m.nError, m.cMethod, m.nLine)
	ENDPROC

	PROCEDURE cmdEdit.Click
		#DEFINE C_NOUPDATE_LOC	"No puede modificar porque las vistas seleccionadas no envían actualizaciones."
		
		LOCAL lNoSendParentUpdates,lNoSendChildUpdates
		LOCAL aTablesUsed,nTablesUsed,i
		
		IF EMPTY(ALIAS())
			RETURN
		ENDIF
		
		** Reverting record
		IF THIS.Parent.EditMode
			
			IF THIS.Parent.UseDataEnv
				SELECT (THIS.Parent.OldAlias)
				IF CURSORGETPROP("Buffering")>1
					=TableRevert(.T.)
				ENDIF
				IF !EMPTY(THIS.Parent.GridAlias)
					SELECT (THIS.Parent.GridAlias)
					IF CURSORGETPROP("Buffering")>1
						=TableRevert(.T.)
					ENDIF
				ENDIF			
			ELSE
				DIMENSION aTablesUsed[1]
				m.nTablesUsed = AUSED(aTablesUsed)
				FOR i = 1 TO m.nTablesUsed
					IF CURSORGETPROP("Buffering",aTablesUsed[m.i,1])>1
						=TableRevert(.T.,aTablesUsed[m.i,1])
					ENDIF
				ENDFOR
			ENDIF
			
			* Go back to original place
			SELECT (THIS.Parent.OldAlias)
			IF RECCOUNT() < THIS.Parent.OldRec	&&added record at EOF()
				GO TOP
			ELSE
				GO THIS.Parent.OldRec
			ENDIF
		ELSE
		
			* Check to see if view allows updates
			IF CURSORGETPROP("SourceType")#3 AND !CURSORGETPROP("offline") AND;
				!CURSORGETPROP("SendUpdates")
				lNoSendParentUpdates = .T.
			ENDIF
			IF !EMPTY(THIS.Parent.GridAlias) AND ;
			  CURSORGETPROP("SourceType",THIS.Parent.GridAlias)#3 AND ;
			  !CURSORGETPROP("offline",THIS.Parent.GridAlias) AND ;
			  !CURSORGETPROP("SendUpdates",THIS.Parent.GridAlias)
				lNoSendChildUpdates= .T.
			ENDIF
			
			IF (m.lNoSendChildUpdates AND m.lNoSendParentUpdates) OR;
				(EMPTY(THIS.Parent.GridAlias) AND m.lNoSendParentUpdates)
				=MESSAGEBOX(C_NOUPDATE_LOC)
				RETURN
			ENDIF
			
			THIS.Parent.OldAlias = ALIAS()	&&save alias in case reverting
			THIS.Parent.OldRec = RECNO()	&&save record in case reverting
		ENDIF
		
		** Editing record
		THIS.Parent.EditMode = !THIS.Parent.EditMode
		THIS.Parent.AddMode = .F.
		THIS.Parent.ButtonRefresh()
		THIS.Parent.NavRefresh()
		
	ENDPROC

	PROCEDURE cmdEdit.Error
		LPARAMETERS nError, cMethod, nLine
		this.parent.error(m.nError, m.cMethod, m.nLine)
	ENDPROC

	PROCEDURE cmdEnd.Click
		THIS.Parent.Navigate("END")
		
	ENDPROC

	PROCEDURE cmdExit.Click
		THISFORM.Release
		
	ENDPROC

	PROCEDURE cmdFind.Click
		LOCAL oSearchDlog
		LOCAL lVisChange,lStateChange
		
		IF EMPTY(ALIAS())
			RETURN
		ENDIF
		
		* Check if SDI Window
		IF THISFORM.ShowWindow = 2 
			IF !_VFP.Visible
				_VFP.Visible = .T.
				lVisChange = .T.
			ENDIF
			IF _SCREEN.WindowState = 1
				_SCREEN.WindowState = 0
				lStateChange = .T.
			ENDIF
		ENDIF
		
		oSearchDlog = CREATE("searchform")
		oSearchDlog.SHOW()
		
		IF m.lVisChange
			_VFP.Visible = .F.
		ENDIF
		IF m.lStateChange 
			_SCREEN.WindowState = 1
		ENDIF
		
		IF THISFORM.ShowWindow = 2 
			Activate Window (THISFORM.Name)
		ENDIF
		
		* Reset from prior
		THIS.Parent.TopFile = .F.
		THIS.Parent.EndFile = .F.
		THIS.Parent.NavRefresh()
	ENDPROC

	PROCEDURE cmdNext.Click
		THIS.Parent.Navigate("NEXT")
		
	ENDPROC

	PROCEDURE cmdPrev.Click
		THIS.Parent.Navigate("PREV")
	ENDPROC

	PROCEDURE cmdPrint.Click
		#DEFINE DIALOG_CLASS "_outputdialog"
		#DEFINE DIALOG_CLASSLIB "_reports.vcx"
		
		LOCAL lcRepName,loOutputDialog,lcDClass
		
		DO CASE
		CASE EMPTY(ALIAS())
			lcRepName = ""
		CASE CURSORGETPROP("sourcetype")=3	&& tables
			lcRepName = FORCEEXT(DBF(),"FRX")
		OTHERWISE
			lcRepName = LEFT(ALIAS(),8)+".FRX"
		ENDCASE
		
		DO CASE
		CASE FILE(DIALOG_CLASSLIB)
			lcDClass = DIALOG_CLASSLIB
		CASE FILE(HOME()+"FFC\"+DIALOG_CLASSLIB)
			lcDClass = HOME()+"FFC\"+DIALOG_CLASSLIB
		CASE FILE("..\FFC\"+DIALOG_CLASSLIB)
			lcDClass = "..\FFC\"+DIALOG_CLASSLIB
		OTHERWISE
			THIS.Parent.PrintRpt()
			RETURN
		ENDCASE
		
		loOutputDialog = NewObject(DIALOG_CLASS,lcDClass)
		IF VARTYPE(loOutputDialog) # "O" OR;
			(THIS.Parent.lNoRptSource AND !FILE(lcRepName))
			THIS.Parent.PrintRpt()
			RETURN
		ENDIF
		
		WITH loOutputDialog
			.cReport= IIF(FILE(lcRepName),lcRepName,"")
			.lPreventSourceChanges=THIS.Parent.lNoRptSource
			.lPreventScopeChanges=THIS.Parent.lNoRptScope
		ENDWITH
		loOutputDialog.Show(1)
		
	ENDPROC

	PROCEDURE cmdTop.Click
		THIS.Parent.Navigate("TOP")
		
	ENDPROC

ENDDEFINE

DEFINE CLASS verttxtbtns AS txtbtns OF "wizbtns.vcx" 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" ProjectClassIcon="stylebmp\textbttn.bmp" ClassIcon="stylebmp\textbttn.bmp" />

	*<PropValue>
		Height = 276
		Name = "verttxtbtns"
		Width = 55
		cmdPrev.Left = 0
		cmdPrev.Name = "cmdPrev"
		cmdPrev.Top = 24
		cmdNext.Left = 0
		cmdNext.Name = "cmdNext"
		cmdNext.Top = 48
		cmdTop.Left = 0
		cmdTop.Name = "cmdTop"
		cmdTop.Top = 0
		cmdEnd.Left = 0
		cmdEnd.Name = "cmdEnd"
		cmdEnd.Top = 72
		cmdFind.Left = 0
		cmdFind.Name = "cmdFind"
		cmdFind.Top = 108
		cmdFind.Width = 55
		cmdPrint.Left = 0
		cmdPrint.Name = "cmdPrint"
		cmdPrint.Top = 132
		cmdPrint.Width = 55
		cmdExit.Height = 24
		cmdExit.Left = 0
		cmdExit.Name = "cmdExit"
		cmdExit.Top = 252
		cmdExit.Width = 55
		cmdAdd.Caption = "Ag\<rar"
		cmdAdd.Left = 0
		cmdAdd.Name = "cmdAdd"
		cmdAdd.Top = 168
		cmdDelete.Left = 0
		cmdDelete.Name = "cmdDelete"
		cmdDelete.Top = 216
		cmdEdit.Left = 0
		cmdEdit.Name = "cmdEdit"
		cmdEdit.Top = 192
	*</PropValue>

ENDDEFINE
