*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.21" SourceFile="wizbase.vcx" CPID="1252" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS baseform AS form 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" ProjectClassIcon="stylebmp\form.bmp" ClassIcon="stylebmp\form.bmp" />

	*<DefinedPropArrayMethod>
		*m: addrecord
		*m: deleterecord
		*m: pickrecord
		*m: resolveconflicts
		*p: haderror		&& Whether an error occurred.
		*p: lpromptkey		&& Whether to prompt for primary key value.
		*p: lsavebuffereddata
		*p: lshowfirsttime
		*p: lupdateallbufferedtables
		*p: wizappclass		&& Name of application class to add to form.
		*p: wizappclasslibrary		&& Name of application class library to add to form.
		*p: wizappobject		&& Name used on form for application class.
		*p: wizbtnlayout		&& Button position object (class) if one used for unique placement of buttons.
		*p: wizbtnpos		&& Button position centering (0-none, 1-hori, 2-vert, 3-both). By default, buttons are centered in footer. You can use these settings for better control over how buttons are placed, especially if buttons are vertically laid out.
		*p: wizbuffering		&& Data environment table buffering setting.
		*p: wizbuttons		&& Class reference for button set object.
		*p: wizcaptions		&& Whether to use DBC long name label captions.
		*p: wizcboxlbl		&& Whether to use the checkbox as the label.
		*p: wizcodestyle		&& Whether to use code style or button style.
		*p: wizfield		&& Class reference for a field object.
		*p: wizformstretch		&& Whether to shrink/expand form (height only) based on number of fields selected.
		*p: wizgrid		&& Class reference for grid object with 1-Many forms.
		*p: wizgridform		&& Whether to use a separate form for grid object.
		*p: wizlabel		&& Class reference for label object.
		*p: wizlayout		&& Class reference for layout object.
		*p: wizlblcap		&& Label capitalization (proper, normal, upper or lower).
		*p: wizlbldefwid		&& Whether to use fixed label width for consistent look and alignment of fields on form.
		*p: wizlblspace		&& Space between label and field.
		*p: wizlblsuffix		&& Character expression added to the end of each label (e.g., :).
		*p: wizlogic		&& Class reference for a logic field object.
		*p: wizmaxcharfld		&& Max width of character field before using editbox memo object.
		*p: wizmemo		&& Class reference for a memo field object.
		*p: wizole		&& Class reference for a general field object.
		*p: wizpages		&& Allows use of pages for overflow of fields (0 - none, 1 - single column, 2 - multi column).
		*p: wizpagestyle		&& This is style class for page frame.
		*p: wiztitle		&& Class reference for title object (label).
		*p: wizuser		&& For use by user.
		*p: wizverify		&& Whether to verify class objects (use for testing but can improve performance if set .F.).
	*</DefinedPropArrayMethod>

	*<PropValue>
		AutoCenter = .T.
		Caption = "Formulario1"
		DataSession = 2
		DoCreate = .T.
		Enabled = .T.
		Height = 320
		lpromptkey = .T.
		lsavebuffereddata = .T.
		lshowfirsttime = .T.
		Name = "baseform"
		ScaleMode = 3
		ScrollBars = 3
		ShowWindow = 1
		Width = 580
		wizappclass = _formmediator
		wizappclasslibrary = _framewk.vcx
		wizappobject = app_mediator
		wizbtnlayout = 0
		wizbtnpos = 0
		wizbuffering = 5
		wizbuttons = 0
		wizcaptions = .T.
		wizcodestyle = 0
		wizfield = 
		wizformstretch = 0
		wizgrid = 
		wizlabel = 
		wizlayout = 
		wizlblcap = 0
		wizlbldefwid = 0
		wizlblspace = 0
		wizlblsuffix = 0
		wizlogic = 0
		wizmaxcharfld = 0
		wizmemo = 
		wizole = 
		wizpages = 1
		wizpagestyle = 
		wiztitle = 
		wizuser = 0
		wizverify = 0
	*</PropValue>
	
	PROCEDURE addrecord
		#DEFINE C_NOUPDATE_LOC	"No puede agregar un nuevo registro porque las vistas seleccionadas no envían actualizaciones."
		#DEFINE	DIALOG_CLASSLIB "WIZBTNS.VCX"
		
		LOCAL lnSaveRec,lcSaveData,loAddRec,loCustom,cPrimaryKey,lcClassLib,nPrimaryKey
		
		IF EOF() OR BOF()
			GO TOP
		ENDIF
		lnSaveRec = RECNO()
		
		DO CASE
		CASE FILE(DIALOG_CLASSLIB)
			lcClassLib = DIALOG_CLASSLIB
		CASE FILE(HOME()+"WIZARDS\"+DIALOG_CLASSLIB)
			lcClassLib = HOME()+"WIZARDS\"+DIALOG_CLASSLIB
		OTHERWISE
			lcClassLib = ""
		ENDCASE
		
		DO CASE
		CASE CURSORGETPROP("SourceType")#3 AND ;
		  !CURSORGETPROP("offline") AND ;
		  !CURSORGETPROP("SendUpdates")
			MESSAGEBOX(C_NOUPDATE_LOC)
			RETURN .F.
		CASE EMPTY(CURSORGETPROP("database")) 
			* Free table
			APPEND BLANK
		CASE CURSORGETPROP("SourceType")#3
			* View
			APPEND BLANK
		CASE CURSORGETPROP("buffering")#1 AND !THIS.lPromptKey
			* buffered data
			APPEND BLANK
		CASE EMPTY(lcClassLib)
			* could disable this if you feel 
			* potential unique ID conflicts could arise
			APPEND BLANK
		OTHERWISE
			lcSaveData = SET("DATABASE")
			SET DATABASE TO CURSORGETPROP("database")
			cPrimaryKey = DBGETPROP(CURSORGETPROP("sourcename"),"Table","PrimaryKey")
			nPrimaryKey = TAGNO(m.cPrimaryKey)
			SET DATABASE TO &lcSaveData
			IF EMPTY(cPrimaryKey) OR m.nPrimaryKey=0
				APPEND BLANK
			ELSE
				cPrimaryKey=KEY(m.nPrimaryKey)
				loAddRec=NewObject("AddRecord",lcClassLib,"")
				loCustom = Create('custom')
				loAddRec.cKeyField = m.cPrimaryKey
				loAddRec.cKeyValue = EVAL(m.cPrimaryKey)
				loAddRec.oRetValue = loCustom
				loAddRec.Show()
				IF loCustom.nBtnAction=1
					INSERT INTO (ALIAS()) ((m.cPrimaryKey)) VALUES(loCustom.cKeyValue)
				ELSE
					THIS.HadError = .T.	
				ENDIF
			ENDIF
		ENDCASE
		
		IF THIS.HadError
			THIS.HadError = .F.
			GO lnSaveRec
			RETURN .F.
		ENDIF
		
		THISFORM.Refresh()
		
	ENDPROC

	PROCEDURE deleterecord
		#DEFINE MSGBOX_YES		6
		#DEFINE C_MSGBOX1		36
		#DEFINE C_DELETE_LOC	"¿Desea eliminar este registro?"
		LOCAL llHadEof
		llHadEof=.F.
		* Note: Cascading deletes should be handled via RI triggers in DBC!
		IF !USED()
			RETURN
		ENDIF
		
		IF MESSAGEBOX(C_DELETE_LOC,C_MSGBOX1) = MSGBOX_YES
			DELETE
		*!*		SKIP
		*!*		IF EOF()
		*!*			GO TOP
		*!*		ENDIF
			DO WHILE DELETED() OR EOF()
				IF EOF()
					IF llHadEof
						EXIT
					ENDIF
					GO TOP
					llHadEof = .T.
				ELSE
					SKIP	
				ENDIF
			ENDDO
			THISFORM.Refresh
		ENDIF
		
		IF THISFORM.ShowWindow = 2
			Activate Window (THISFORM.Name)
		ENDIF
		
	ENDPROC

	PROCEDURE Error
		#DEFINE ERR_UNIQUEKEY_LOC    "Se ha producido una infracción de error de clave única."
		#DEFINE ERR_UNIQUEKEY2_LOC   "¿Desea deshacer los cambios?"
		#DEFINE ERR_TABLEINUSE_LOC   "Error: La tabla está en uso. Puede que la tabla ya esté abierta en modo exclusivo."
		
		LPARAMETERS nError, cMethod, nLine
		LOCAL aFoxErr,nTotErr
		DIMENSION aFoxErr[1]
		nTotErr = AERROR(aFoxErr)
		THIS.HadError = .T.
		
		DO CASE
		CASE INLIST(nError,1967)	&&errors to skip
			RETURN
		CASE nToterr>0 AND aFoxErr[1,1] = 1420
			* Corrupt Ole object in General field.
			MESSAGEBOX(aFoxErr[1,2])
			RETURN
		CASE nError = 5  &&record out of range
			IF EOF()
				GO BOTTOM
			ELSE
				GO TOP
			ENDIF
			RETURN
		CASE nError = 1884
			* Uniqueness ID error
			IF CURSORGETPROP("buffering")=1
				MESSAGEBOX(ERR_UNIQUEKEY_LOC)
				RETURN
			ENDIF
			IF MESSAGEBOX(ERR_UNIQUEKEY_LOC+" "+ERR_UNIQUEKEY2_LOC,36)=6
				TABLEREVERT(.T.)
			ENDIF
			RETURN
		CASE nError = 1995  &&table is in use
			MESSAGEBOX(ERR_TABLEINUSE_LOC)
			RETURN
		ENDCASE
		
		**** Error Dialog ******
		MESSAGEBOX(MESSAGE(1)+CHR(13)+;
			"Error: "+STR(nError)+CHR(13)+;
			MESSAGE()+CHR(13)+;
			"Method: "+cMethod+CHR(13)+;
			"Line: "+STR(nLine))
		
	ENDPROC

	PROCEDURE Load
		RETURN !THIS.HadError
		
	ENDPROC

	PROCEDURE pickrecord
		IF TYPE("THIS.APP_MEDIATOR.BaseClass")#"C"
			RETURN
		ENDIF
		
		IF THIS.APP_MEDIATOR.PickRecordToWorkOn()
			IF THIS.APP_MEDIATOR.lAdding AND !EMPTY(ALIAS())
				THIS.REFRESH()
				* Check if we have blank record already from txtbtns
				IF GETFLDSTATE(1) #3
					THIS.AddRecord()
				ENDIF
			ENDIF
		ENDIF
		
	ENDPROC

	PROCEDURE QueryUnload
		IF TYPE("THIS.APP_MEDIATOR.BaseClass")#"C"
			IF !THIS.ResolveConflicts()
				NODEFAULT
				RETURN .F.
			ENDIF
			RETURN
		ENDIF
		
		IF DODEFAULT()
		    IF NOT THIS.App_Mediator.QueryUnload()
		       NODEFAULT
		       RETURN .F.
		   ENDIF
		ELSE
		  NODEFAULT
		  RETURN .F.
		ENDIF
		
	ENDPROC

	PROCEDURE Release
		IF !THIS.Queryunload()
			NODEFAULT
			RETURN .F.
		ENDIF
		
	ENDPROC

	PROCEDURE resolveconflicts
		#DEFINE PROMPTTOSAVE_LOC	"Se han modificado datos. ¿Desea guardar las modificaciones?"
		
		IF !THIS.lSaveBufferedData
			RETURN
		ENDIF
		
		LOCAL nDECursors, aDECursors, cDataEnvRef, lPromptSave,lHadPrompt
		LOCAL lcAlias, lnFields, nPromptSave, i, loCurrentControl
		
		* Flush current control
		IF TYPE("THIS.ActiveControl.baseclass")="C" AND; 
		  PEMSTATUS(THIS.ActiveControl,"value",5) AND;
		  PEMSTATUS(THIS.ActiveControl,"controlsource",5) AND;
		  !EMPTY(THIS.ActiveControl.controlsource)
			loCurrentControl = THIS.ActiveControl
			* Check if data actually changed
			IF !EVAL(loCurrentControl.controlsource)= loCurrentControl.Value
				loCurrentControl.Value = loCurrentControl.Value
			ENDIF
			loCurrentControl=""
		ENDIF
		
		nDECursors = 0
		cDataEnvRef = ""
		DIMENSION aDECursors[1]
		DO CASE
		CASE TYPE("THISFORM.DataEnvironment") = "O"
			nDECursors = AMEMBERS(aDECursors,THISFORM.DataEnvironment,2)
			cDataEnvRef = "THISFORM.DataEnvironment"
		CASE TYPE("THISFORMSET.DataEnvironment") = "O"
			nDECursors = AMEMBERS(aDECursors,THISFORMSET.DataEnvironment,2)
			cDataEnvRef = "THISFORMSET.DataEnvironment"
		CASE THIS.lUpdateAllBufferedTables
			nDECursors=AUSED(aDECursors)
		OTHERWISE
			IF !EMPTY(ALIAS())
				aDECursors[1]=ALIAS()
				nDECursors=1
			ENDIF
		ENDCASE
		
		FOR i = 1 TO m.nDECursors
			IF EMPTY(m.cDataEnvRef)
				lcAlias = aDECursors[m.i]
			ELSE
				WITH EVAL(m.cDataEnvRef + "." + aDECursors[m.i])
					IF ATC("CURSOR",.BaseClass)=0  &&skip relations
						LOOP
					ENDIF
					lcAlias = .ALIAS
				ENDWITH
			ENDIF
			
			IF USED(lcAlias) AND CursorGetProp("sourcetype",lcAlias )=3 AND ;
			  CursorGetProp("buffering",lcAlias )>1
		
				IF !m.lHadPrompt
					IF CursorGetProp("buffering",lcAlias )>3
						IF GETNEXTMODIFIED(0,lcAlias )=0
							LOOP
						ENDIF
					ELSE
						lnFields = GETFLDSTATE(-1,lcAlias)
						IF REPLICATE("1",LEN(lnFields))=TRANS(lnFields)
							LOOP
						ENDIF
					ENDIF
					nPromptSave = MESSAGEBOX(PROMPTTOSAVE_LOC,35)
					IF nPromptSave=2
						RETURN .F.
					ENDIF
					lPromptSave=(nPromptSave=6)
					lHadPrompt = .T.
				ENDIF
			  	IF m.lPromptSave
					TableUpdate(.T.,.T.,lcAlias)  && update on exit
			  	ELSE
					TableRevert(.T.,lcAlias)  && update on exit
				ENDIF
			ENDIF
		ENDFOR
		
	ENDPROC

	PROCEDURE Show
		LPARAMETERS nStyle
		LOCAL lcAppRef
		
		IF TYPE("THIS.APP_MEDIATOR.BaseClass")#"C" OR !THIS.lShowFirstTime
			RETURN
		ENDIF
		
		THIS.lShowFirstTime = .F.
		THIS.lSaveBufferedData = .F.
		THIS.PickRecord()
		
	ENDPROC

ENDDEFINE

DEFINE CLASS layoutsty AS container 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" ProjectClassIcon="stylebmp\layout.bmp" ClassIcon="stylebmp\layout.bmp" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="Shape1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Shape2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Shape3" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Shape4" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*p: ocol2
		*p: odimensions
		*p: olabel1
		*p: olabel2
	*</DefinedPropArrayMethod>

	*<PropValue>
		Height = 205
		Name = "layoutsty"
		ocol2 = Shape4
		odimensions = Shape1
		olabel1 = Shape2
		olabel2 = Shape3
		TabIndex = 0
		Width = 517
	*</PropValue>

	ADD OBJECT 'Shape1' AS shape WITH ;
		Height = 205, ;
		Left = 0, ;
		Name = "Shape1", ;
		Top = 0, ;
		Width = 517
		*< END OBJECT: BaseClass="shape" />

	ADD OBJECT 'Shape2' AS shape WITH ;
		Height = 13, ;
		Left = 24, ;
		Name = "Shape2", ;
		Top = 24, ;
		Width = 37
		*< END OBJECT: BaseClass="shape" />

	ADD OBJECT 'Shape3' AS shape WITH ;
		Height = 13, ;
		Left = 24, ;
		Name = "Shape3", ;
		Top = 45, ;
		Width = 37
		*< END OBJECT: BaseClass="shape" />

	ADD OBJECT 'Shape4' AS shape WITH ;
		Height = 13, ;
		Left = 228, ;
		Name = "Shape4", ;
		Top = 24, ;
		Width = 37
		*< END OBJECT: BaseClass="shape" />

ENDDEFINE

DEFINE CLASS wizshape AS shape 
 	*< CLASSDATA: Baseclass="shape" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*p: wizeffect
	*</DefinedPropArrayMethod>

	*<PropValue>
		Height = 68
		Name = "wizshape"
		Width = 68
		wizeffect = 0
	*</PropValue>

ENDDEFINE
