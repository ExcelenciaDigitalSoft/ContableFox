*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.21" SourceFile="wizstyle.vcx" CPID="1252" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS baseform AS form 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" ProjectClassIcon="stylebmp\form.bmp" ClassIcon="stylebmp\form.bmp" />

	*<DefinedPropArrayMethod>
		*p: wizbtnlayout		&& El objeto de posición de botón (clase) si se usa alguno para la colocación única de los botones.
		*p: wizbtnpos		&& Centrado de la posición del botón (0-ninguno, 1-horizontal, 2-vertical, 3-ambos). De forma predeterminada, los botones se centran en el pie. Puede utilizar estos valores para controlar mejor cómo se colocan los botones, especialmente si esán dispuestos verticalmente.
		*p: wizbuffering		&& Valor de almacenamiento en búfer de tablas de entornos de datos.
		*p: wizbuttons		&& Referencia de clase para el objeto de conjunto de botones.
		*p: wizcaptions		&& Si se van a utilizar títulos largos de etiquetas de nombres DBC.
		*p: wizcboxlbl		&& Si se va a utilizar la casilla de verificación como etiqueta.
		*p: wizcodestyle		&& Si se va a utilizar estilo de código o estilo de botón.
		*p: wizfield		&& Referencia de clase para un objeto Field.
		*p: wizformstretch		&& Si se va a contraer o expandir el formulario (sólo a lo alto) en base al número de campos seleccionados.
		*p: wizgrid		&& Referencia de clase para el objeto Grid con formularios uno a varios.
		*p: wizgridform		&& Si se va a utilizar un formulario distinto para el objeto Grid.
		*p: wizlabel		&& Referencia de clase para el objeto Label.
		*p: wizlayout		&& Referencia de clase para el objeto Layout.
		*p: wizlblcap		&& Modelo de mayúsculas y minúsculas de la etiqueta (adecuada, normal, mayúsculas o minúsculas).
		*p: wizlbldefwid		&& Si se va a utilizar un ancho fijo de etiqueta para conseguir una apariencia coherente de los campos del formulario.
		*p: wizlblspace		&& Espacio entre la etiqueta y el campo.
		*p: wizlblsuffix		&& Expresión de caracteres que se agrega al final de cada etiqueta (por ejemplo, :).
		*p: wizlogic		&& Referencia de clase para un objeto de campo lógico.
		*p: wizmaxcharfld		&& Ancho máximo del campo de caracteres antes de usar el objeto memo editbox.
		*p: wizmemo		&& Referencia de clase para un objeto de campo memo.
		*p: wizole		&& Referencia de clase para un objeto de campo general.
		*p: wizpages		&& Permite el uso de páginas para el desbordamiento de campos (0 - ninguno, 1 - columna única, 2 - múltiples columnas).
		*p: wizpagestyle
		*p: wiztitle		&& Referencia de clase para el objeto de título (etiqueta).
		*p: wizuser		&& Para uso del usuario.
		*p: wizverify		&& Si se van a comprobar objetos de clase (se usa para pruebas, pero puede mejorar el rendimiento si se establece a .F.).
	*</DefinedPropArrayMethod>

	*<PropValue>
		AutoCenter = .T.
		Caption = "Formulario1"
		DataSession = 1
		DoCreate = .T.
		Enabled = .T.
		Height = 350
		Name = "baseform"
		ScaleMode = 3
		Width = 575
		wizbtnlayout = 0
		wizbtnpos = 0
		wizbuffering = 5
		wizbuttons = 0
		wizcaptions = .T.
		wizcodestyle = 0
		wizfield = 
		wizformstretch = 0
		wizgrid = 
		wizlabel = 
		wizlayout = 
		wizlblcap = 0
		wizlbldefwid = 0
		wizlblspace = 0
		wizlblsuffix = 0
		wizlogic = 0
		wizmaxcharfld = 0
		wizmemo = 
		wizole = 
		wizpages = 1
		wizpagestyle = 
		wiztitle = 
		wizuser = 0
		wizverify = 0
	*</PropValue>

ENDDEFINE

DEFINE CLASS boxbase AS container 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" ProjectClassIcon="stylebmp\txtbox5.bmp" ClassIcon="stylebmp\txtbox5.bmp" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="Shape1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Label1" UniqueID="" Timestamp="" />

	*<PropValue>
		BackStyle = 0
		BorderWidth = 0
		Height = 43
		Name = "boxbase"
		SpecialEffect = 2
		Width = 94
	*</PropValue>

	ADD OBJECT 'Label1' AS label WITH ;
		BackColor = 0,0,255, ;
		BackStyle = 0, ;
		Caption = "Etiqueta1", ;
		FontSize = 9, ;
		ForeColor = 0,0,255, ;
		Height = 15, ;
		Left = 3, ;
		Name = "Label1", ;
		TabIndex = 0, ;
		Top = 2, ;
		Width = 49
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'Shape1' AS wizshape WITH ;
		BackColor = 255,255,255, ;
		BackStyle = 1, ;
		FillColor = 255,255,255, ;
		FillStyle = 0, ;
		Height = 43, ;
		Left = 0, ;
		Name = "Shape1", ;
		SpecialEffect = 1, ;
		Top = 0, ;
		Width = 94, ;
		wizeffect = 1
		*< END OBJECT: ClassLib="wizstyle.vcx" BaseClass="shape" />

ENDDEFINE

DEFINE CLASS boxfield AS boxbase OF "wizstyle.vcx" 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="Text1" UniqueID="" Timestamp="" />

	*<PropValue>
		Height = 43
		Name = "boxfield"
		Width = 94
		Shape1.Height = 43
		Shape1.Left = 0
		Shape1.Name = "Shape1"
		Shape1.Top = 0
		Shape1.Width = 94
		Label1.Height = 15
		Label1.Left = 3
		Label1.Name = "Label1"
		Label1.Top = 2
		Label1.Width = 49
	*</PropValue>

	ADD OBJECT 'Text1' AS textbox WITH ;
		BackColor = 255,255,255, ;
		BackStyle = 1, ;
		BorderStyle = 0, ;
		ColorSource = 0, ;
		FontSize = 9, ;
		Height = 18, ;
		Left = 3, ;
		Name = "Text1", ;
		SelectedBackColor = 128,128,128, ;
		SpecialEffect = 1, ;
		TabIndex = 0, ;
		Top = 23, ;
		Width = 88
		*< END OBJECT: BaseClass="textbox" />

ENDDEFINE

DEFINE CLASS boxform AS baseform OF "wizstyle.vcx" 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" ProjectClassIcon="stylebmp\form5.bmp" ClassIcon="stylebmp\form5.bmp" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="Layoutsty" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Shape1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Label1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Shape2" UniqueID="" Timestamp="" />

	*<PropValue>
		BackColor = 192,192,192
		ColorSource = 0
		DoCreate = .T.
		Name = "boxform"
		ScaleMode = 3
		wizcodestyle = .T.
		wizfield = boxfield
		wizformstretch = .T.
		wizgrid = grid1
		wizlayout = layoutsty
		wizlblcap = proper
		wizlbldefwid = .F.
		wizlblsuffix = (":")
		wizlogic = boxlogic
		wizmaxcharfld = 45
		wizmemo = boxmemo
		wizole = boxole
		wizpages = 2
		wizpagestyle = boxpages
		wiztitle = Label1
		wizuser = 0
		wizverify = .T.
	*</PropValue>

	ADD OBJECT 'Label1' AS label WITH ;
		AutoSize = .T., ;
		BackColor = 255,255,255, ;
		BackStyle = 0, ;
		Caption = "Etiqueta1", ;
		FontName = "Arial", ;
		FontSize = 20, ;
		ForeColor = 255,255,255, ;
		Height = 35, ;
		Left = 21, ;
		Name = "Label1", ;
		Top = 17, ;
		Width = 117
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'Layoutsty' AS layoutsty WITH ;
		Height = 195, ;
		Left = 5, ;
		Name = "Layoutsty", ;
		TabIndex = 0, ;
		Top = 62, ;
		Width = 571, ;
		shape1.Height = 194, ;
		shape1.Left = 0, ;
		shape1.Name = "shape1", ;
		shape1.Top = 0, ;
		shape1.Width = 570, ;
		shape2.Height = 13, ;
		shape2.Left = 16, ;
		shape2.Name = "shape2", ;
		shape2.Top = 1, ;
		shape2.Width = 37, ;
		shape3.Height = 13, ;
		shape3.Left = 16, ;
		shape3.Name = "shape3", ;
		shape3.Top = 13, ;
		shape3.Width = 37, ;
		shape4.Height = 13, ;
		shape4.Left = 52, ;
		shape4.Name = "shape4", ;
		shape4.Top = 1, ;
		shape4.Width = 37
		*< END OBJECT: ClassLib="wizstyle.vcx" BaseClass="container" />

	ADD OBJECT 'Shape1' AS shape WITH ;
		BackColor = 0,0,255, ;
		FillColor = 0,0,255, ;
		FillStyle = 0, ;
		Height = 61, ;
		Left = 0, ;
		Name = "Shape1", ;
		Top = 0, ;
		Width = 580
		*< END OBJECT: BaseClass="shape" />

	ADD OBJECT 'Shape2' AS shape WITH ;
		BackColor = 0,0,255, ;
		FillColor = 0,0,255, ;
		FillStyle = 0, ;
		Height = 81, ;
		Left = 0, ;
		Name = "Shape2", ;
		Top = 261, ;
		Width = 580
		*< END OBJECT: BaseClass="shape" />

ENDDEFINE

DEFINE CLASS boxlogic AS boxbase OF "wizstyle.vcx" 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="Check1" UniqueID="" Timestamp="" />

	*<PropValue>
		Height = 43
		Name = "boxlogic"
		Width = 88
		Shape1.Height = 43
		Shape1.Left = 0
		Shape1.Name = "Shape1"
		Shape1.Top = 0
		Shape1.Width = 88
		Label1.Height = 15
		Label1.Left = 3
		Label1.Name = "Label1"
		Label1.Top = 2
		Label1.Width = 49
	*</PropValue>

	ADD OBJECT 'Check1' AS checkbox WITH ;
		BackStyle = 1, ;
		Caption = "", ;
		ColorSource = 0, ;
		FontSize = 9, ;
		Height = 17, ;
		Left = 2, ;
		Name = "Check1", ;
		SpecialEffect = 0, ;
		TabIndex = 0, ;
		Top = 22, ;
		Width = 13
		*< END OBJECT: BaseClass="checkbox" />

ENDDEFINE

DEFINE CLASS boxmemo AS boxbase OF "wizstyle.vcx" 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="Edit1" UniqueID="" Timestamp="" />

	*<PropValue>
		Height = 75
		Name = "boxmemo"
		Width = 247
		Shape1.Height = 75
		Shape1.Left = 0
		Shape1.Name = "Shape1"
		Shape1.Top = 0
		Shape1.Width = 246
		Label1.Height = 15
		Label1.Left = 3
		Label1.Name = "Label1"
		Label1.Top = 2
		Label1.Width = 49
	*</PropValue>

	ADD OBJECT 'Edit1' AS editbox WITH ;
		BackColor = 255,255,255, ;
		BorderStyle = 0, ;
		ColorSource = 0, ;
		FontSize = 9, ;
		Height = 50, ;
		Left = 3, ;
		Name = "Edit1", ;
		ScrollBars = 0, ;
		SpecialEffect = 1, ;
		TabIndex = 0, ;
		Top = 23, ;
		Width = 241
		*< END OBJECT: BaseClass="editbox" />

ENDDEFINE

DEFINE CLASS boxole AS boxbase OF "wizstyle.vcx" 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="Oleboundcontrol1" UniqueID="" Timestamp="" />

	*<PropValue>
		Height = 125
		Name = "boxole"
		Width = 156
		Shape1.Height = 125
		Shape1.Left = 0
		Shape1.Name = "Shape1"
		Shape1.Top = 0
		Shape1.Width = 156
		Label1.Height = 15
		Label1.Left = 3
		Label1.Name = "Label1"
		Label1.Top = 2
		Label1.Width = 49
	*</PropValue>

	ADD OBJECT 'Oleboundcontrol1' AS oleboundcontrol WITH ;
		Height = 100, ;
		Left = 3, ;
		Name = "Oleboundcontrol1", ;
		TabIndex = 0, ;
		Top = 23, ;
		Width = 150
		*< END OBJECT: BaseClass="oleboundcontrol" />

ENDDEFINE

DEFINE CLASS boxpages AS pageframe 
 	*< CLASSDATA: Baseclass="pageframe" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<PropValue>
		ErasePage = .T.
		Height = 169
		Name = "boxpages"
		PageCount = 2
		TabStretch = 1
		TabStyle = 1
		Width = 287
		PAGE1.Caption = "Página1"
		Page1.Name = "Page1"
		PAGE2.Caption = "Página2"
		Page2.Name = "Page2"
	*</PropValue>

ENDDEFINE

DEFINE CLASS chiselbase AS container 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" ProjectClassIcon="stylebmp\txtbox2.bmp" ClassIcon="stylebmp\txtbox2.bmp" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="Shape1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Label1" UniqueID="" Timestamp="" />

	*<PropValue>
		BackColor = 192,192,192
		BackStyle = 0
		BorderWidth = 0
		Height = 24
		Name = "chiselbase"
		SpecialEffect = 2
		Width = 148
	*</PropValue>

	ADD OBJECT 'Label1' AS label WITH ;
		Alignment = 1, ;
		BackStyle = 0, ;
		Caption = "Etiqueta1", ;
		ColorSource = 3, ;
		FontName = "Arial", ;
		FontSize = 8, ;
		Height = 13, ;
		Left = 0, ;
		Name = "Label1", ;
		TabIndex = 0, ;
		Top = 5, ;
		Width = 45
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'Shape1' AS shape WITH ;
		BackColor = 255,255,255, ;
		Height = 2, ;
		Left = 46, ;
		Name = "Shape1", ;
		SpecialEffect = 0, ;
		Top = 20, ;
		Width = 97
		*< END OBJECT: BaseClass="shape" />

ENDDEFINE

DEFINE CLASS chiselfield AS chiselbase OF "wizstyle.vcx" 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="Text1" UniqueID="" Timestamp="" />

	*<PropValue>
		Height = 24
		Name = "chiselfield"
		Width = 148
		Shape1.Height = 2
		Shape1.Left = 46
		Shape1.Name = "Shape1"
		Shape1.Top = 20
		Shape1.Width = 97
		Label1.Height = 13
		Label1.Left = 0
		Label1.Name = "Label1"
		Label1.Top = 5
		Label1.Width = 45
	*</PropValue>

	ADD OBJECT 'Text1' AS textbox WITH ;
		BackColor = 192,192,192, ;
		BackStyle = 0, ;
		BorderStyle = 0, ;
		DisabledForeColor = 0,0,128, ;
		FontBold = .F., ;
		FontName = "Arial", ;
		FontSize = 8, ;
		Height = 17, ;
		Left = 46, ;
		Name = "Text1", ;
		SelectedBackColor = 0,0,0, ;
		SelectedForeColor = 255,255,255, ;
		SpecialEffect = 1, ;
		TabIndex = 0, ;
		Top = 3, ;
		Width = 97
		*< END OBJECT: BaseClass="textbox" />

ENDDEFINE

DEFINE CLASS chiselform AS baseform OF "wizstyle.vcx" 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" ProjectClassIcon="stylebmp\form2.bmp" ClassIcon="stylebmp\form2.bmp" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="Layoutsty" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Shape2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Shape3" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Label1" UniqueID="" Timestamp="" />

	*<PropValue>
		BackColor = 192,192,192
		ColorSource = 0
		DoCreate = .T.
		Name = "chiselform"
		ScaleMode = 3
		wizbtnpos = 0
		wizcodestyle = .T.
		wizfield = chiselfield
		wizformstretch = .T.
		wizgrid = grid1
		wizlayout = layoutsty
		wizlblcap = proper
		wizlbldefwid = .T.
		wizlblsuffix = (":")
		wizlogic = chisellogic
		wizmaxcharfld = 45
		wizmemo = chiselmemo
		wizole = chiselole
		wiztitle = Label1
		wizuser = 0
		wizverify = .T.
	*</PropValue>

	ADD OBJECT 'Label1' AS label WITH ;
		AutoSize = .T., ;
		BackColor = 0,0,0, ;
		BackStyle = 0, ;
		Caption = "Etiqueta1", ;
		FontSize = 20, ;
		ForeColor = 255,255,255, ;
		Height = 35, ;
		Left = 19, ;
		Name = "Label1", ;
		Top = 10, ;
		Width = 87, ;
		ZOrderSet = 3
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'Layoutsty' AS layoutsty WITH ;
		Height = 213, ;
		Left = 2, ;
		Name = "Layoutsty", ;
		odimensions = Shape1, ;
		TabIndex = 0, ;
		Top = 53, ;
		Width = 573, ;
		ZOrderSet = 0, ;
		shape1.Height = 212, ;
		shape1.Left = 0, ;
		shape1.Name = "shape1", ;
		shape1.Top = 0, ;
		shape1.Width = 572, ;
		shape2.Left = 16, ;
		shape2.Name = "shape2", ;
		shape2.Top = 7, ;
		shape3.Left = 16, ;
		shape3.Name = "shape3", ;
		shape3.Top = 22, ;
		shape4.Left = 255, ;
		shape4.Name = "shape4", ;
		shape4.Top = 7
		*< END OBJECT: ClassLib="wizstyle.vcx" BaseClass="container" />

	ADD OBJECT 'Shape2' AS shape WITH ;
		Height = 2, ;
		Left = 0, ;
		Name = "Shape2", ;
		Top = 270, ;
		Width = 584, ;
		ZOrderSet = 1
		*< END OBJECT: BaseClass="shape" />

	ADD OBJECT 'Shape3' AS shape WITH ;
		BorderColor = 0,0,0, ;
		FillColor = 0,0,0, ;
		FillStyle = 0, ;
		Height = 50, ;
		Left = 0, ;
		Name = "Shape3", ;
		Top = 0, ;
		Width = 580, ;
		ZOrderSet = 2
		*< END OBJECT: BaseClass="shape" />

ENDDEFINE

DEFINE CLASS chisellogic AS chiselbase OF "wizstyle.vcx" 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="Check1" UniqueID="" Timestamp="" />

	*<PropValue>
		Height = 18
		Name = "chisellogic"
		Width = 94
		Shape1.Height = 2
		Shape1.Left = 53
		Shape1.Name = "Shape1"
		Shape1.Top = 15
		Shape1.Width = 13
		Label1.Height = 13
		Label1.Left = 0
		Label1.Name = "Label1"
		Label1.Top = 1
		Label1.Width = 45
	*</PropValue>

	ADD OBJECT 'Check1' AS checkbox WITH ;
		BackStyle = 0, ;
		Caption = "", ;
		FontName = "MS Sans Serif", ;
		FontSize = 8, ;
		Height = 15, ;
		Left = 53, ;
		Name = "Check1", ;
		SpecialEffect = 0, ;
		TabIndex = 0, ;
		Top = 0, ;
		Width = 15
		*< END OBJECT: BaseClass="checkbox" />

ENDDEFINE

DEFINE CLASS chiselmemo AS chiselbase OF "wizstyle.vcx" 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="Edit1" UniqueID="" Timestamp="" />

	*<PropValue>
		Height = 52
		Name = "chiselmemo"
		Width = 198
		Shape1.Height = 2
		Shape1.Left = 46
		Shape1.Name = "Shape1"
		Shape1.Top = 50
		Shape1.Width = 150
		Label1.Height = 13
		Label1.Left = 0
		Label1.Name = "Label1"
		Label1.Top = 3
		Label1.Width = 45
	*</PropValue>

	ADD OBJECT 'Edit1' AS editbox WITH ;
		BackColor = 192,192,192, ;
		BackStyle = 0, ;
		DisabledForeColor = 0,0,128, ;
		FontBold = .F., ;
		FontName = "Arial", ;
		FontSize = 8, ;
		Height = 48, ;
		Left = 46, ;
		Name = "Edit1", ;
		SelectedBackColor = 0,0,0, ;
		SelectedForeColor = 255,255,255, ;
		SpecialEffect = 0, ;
		TabIndex = 0, ;
		Top = -1, ;
		Width = 150
		*< END OBJECT: BaseClass="editbox" />

ENDDEFINE

DEFINE CLASS chiselole AS chiselbase OF "wizstyle.vcx" 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="Oleboundcontrol1" UniqueID="" Timestamp="" />

	*<PropValue>
		Height = 106
		Name = "chiselole"
		Width = 200
		Shape1.Height = 2
		Shape1.Left = 46
		Shape1.Name = "Shape1"
		Shape1.Top = 103
		Shape1.Width = 150
		Label1.Height = 13
		Label1.Left = 0
		Label1.Name = "Label1"
		Label1.Top = 3
		Label1.Width = 45
	*</PropValue>

	ADD OBJECT 'Oleboundcontrol1' AS oleboundcontrol WITH ;
		Height = 100, ;
		Left = 46, ;
		Name = "Oleboundcontrol1", ;
		TabIndex = 0, ;
		Top = 0, ;
		Width = 150
		*< END OBJECT: BaseClass="oleboundcontrol" />

ENDDEFINE

DEFINE CLASS embossedfield AS textbox 
 	*< CLASSDATA: Baseclass="textbox" Timestamp="" Scale="Pixels" Uniqueid="" ProjectClassIcon="stylebmp\txtbox3.bmp" ClassIcon="stylebmp\txtbox3.bmp" />

	*<PropValue>
		ColorSource = 0
		DisabledBackColor = 255,255,255
		FontBold = .F.
		FontName = "Arial"
		FontSize = 8
		Height = 22
		Name = "embossedfield"
		Width = 113
	*</PropValue>

ENDDEFINE

DEFINE CLASS embossedform AS baseform OF "wizstyle.vcx" 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" ProjectClassIcon="stylebmp\form3.bmp" ClassIcon="stylebmp\form3.bmp" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="Layoutsty" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Label1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Shape1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Shape2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Shape3" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Shape4" UniqueID="" Timestamp="" />

	*<PropValue>
		DoCreate = .T.
		Name = "embossedform"
		ScaleMode = 3
		wizbtnpos = 0
		wizcboxlbl = .T.
		wizcodestyle = .T.
		wizfield = embossedfield
		wizformstretch = .T.
		wizgrid = grid1
		wizlabel = embossedlabel
		wizlayout = layoutsty
		wizlblcap = proper
		wizlbldefwid = .T.
		wizlblsuffix = (":")
		wizlogic = embossedlogic
		wizmaxcharfld = 45
		wizmemo = embossedmemo
		wizole = embossedole
		wiztitle = Label1
		wizuser = 0
		wizverify = .T.
	*</PropValue>

	ADD OBJECT 'Label1' AS label WITH ;
		AutoSize = .T., ;
		BackStyle = 0, ;
		Caption = "Etiqueta1", ;
		FontBold = .T., ;
		FontName = "Times New Roman", ;
		FontSize = 20, ;
		Height = 34, ;
		Left = 12, ;
		Name = "Label1", ;
		Top = 8, ;
		Width = 81
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'Layoutsty' AS layoutsty WITH ;
		Height = 205, ;
		Left = 4, ;
		Name = "Layoutsty", ;
		TabIndex = 0, ;
		Top = 54, ;
		Width = 571, ;
		shape1.Height = 205, ;
		shape1.Left = 0, ;
		shape1.Name = "shape1", ;
		shape1.Top = 0, ;
		shape1.Width = 570, ;
		shape2.Height = 13, ;
		shape2.Left = 6, ;
		shape2.Name = "shape2", ;
		shape2.Top = 7, ;
		shape2.Width = 37, ;
		shape3.Height = 13, ;
		shape3.Left = 6, ;
		shape3.Name = "shape3", ;
		shape3.Top = 22, ;
		shape3.Width = 37, ;
		shape4.Height = 13, ;
		shape4.Left = 260, ;
		shape4.Name = "shape4", ;
		shape4.Top = 7, ;
		shape4.Width = 37
		*< END OBJECT: ClassLib="wizstyle.vcx" BaseClass="container" />

	ADD OBJECT 'Shape1' AS shape WITH ;
		BackColor = 128,128,128, ;
		BorderColor = 128,128,128, ;
		Height = 1, ;
		Left = 5, ;
		Name = "Shape1", ;
		Top = 42, ;
		Width = 568
		*< END OBJECT: BaseClass="shape" />

	ADD OBJECT 'Shape2' AS shape WITH ;
		BackColor = 255,255,255, ;
		BorderColor = 255,255,255, ;
		Height = 1, ;
		Left = 5, ;
		Name = "Shape2", ;
		Top = 43, ;
		Width = 568
		*< END OBJECT: BaseClass="shape" />

	ADD OBJECT 'Shape3' AS shape WITH ;
		BackColor = 128,128,128, ;
		BorderColor = 128,128,128, ;
		Height = 1, ;
		Left = 6, ;
		Name = "Shape3", ;
		Top = 264, ;
		Width = 568
		*< END OBJECT: BaseClass="shape" />

	ADD OBJECT 'Shape4' AS shape WITH ;
		BackColor = 255,255,255, ;
		BorderColor = 255,255,255, ;
		Height = 1, ;
		Left = 6, ;
		Name = "Shape4", ;
		Top = 265, ;
		Width = 568
		*< END OBJECT: BaseClass="shape" />

ENDDEFINE

DEFINE CLASS embossedlabel AS label 
 	*< CLASSDATA: Baseclass="label" Timestamp="" Scale="Pixels" Uniqueid="" ProjectClassIcon="stylebmp\label3.bmp" ClassIcon="stylebmp\label3.bmp" />

	*<PropValue>
		BackStyle = 0
		Caption = "Etiqueta1"
		FontBold = .F.
		FontName = "Arial"
		FontSize = 8
		Height = 13
		Name = "embossedlabel"
		Width = 43
	*</PropValue>

ENDDEFINE

DEFINE CLASS embossedlogic AS checkbox 
 	*< CLASSDATA: Baseclass="checkbox" Timestamp="" Scale="Pixels" Uniqueid="" ProjectClassIcon="stylebmp\logic3.bmp" ClassIcon="stylebmp\logic3.bmp" />

	*<PropValue>
		BackStyle = 0
		Caption = "Casilla1"
		ColorSource = 0
		DisabledBackColor = 255,255,255
		FontBold = .F.
		FontName = "Arial"
		FontSize = 8
		Height = 15
		Name = "embossedlogic"
		Width = 72
	*</PropValue>

ENDDEFINE

DEFINE CLASS embossedmemo AS editbox 
 	*< CLASSDATA: Baseclass="editbox" Timestamp="" Scale="Pixels" Uniqueid="" ProjectClassIcon="stylebmp\memo3.bmp" ClassIcon="stylebmp\memo3.bmp" />

	*<PropValue>
		Alignment = 0
		ColorSource = 0
		FontBold = .F.
		FontName = "Arial"
		FontSize = 8
		Height = 50
		Name = "embossedmemo"
		Width = 150
	*</PropValue>

ENDDEFINE

DEFINE CLASS embossedole AS oleboundcontrol 
 	*< CLASSDATA: Baseclass="oleboundcontrol" Timestamp="" Scale="Pixels" Uniqueid="" ProjectClassIcon="stylebmp\ole3.bmp" ClassIcon="stylebmp\ole3.bmp" />

	*<PropValue>
		Height = 100
		Name = "embossedole"
		Sizable = .T.
		Visible = .T.
		Width = 150
	*</PropValue>

ENDDEFINE

DEFINE CLASS fancybase AS container 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="Label1" UniqueID="" Timestamp="" />

	*<PropValue>
		Height = 34
		Name = "fancybase"
		SpecialEffect = 0
		Width = 184
	*</PropValue>

	ADD OBJECT 'Label1' AS label WITH ;
		Caption = "Etiqueta1", ;
		FontName = "Tahoma", ;
		FontSize = 9, ;
		Height = 18, ;
		Left = 8, ;
		Name = "Label1", ;
		Top = 9, ;
		Width = 43
		*< END OBJECT: BaseClass="label" />

ENDDEFINE

DEFINE CLASS fancyfield AS fancybase OF "wizstyle.vcx" 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="Text1" UniqueID="" Timestamp="" />

	*<PropValue>
		Height = 34
		Name = "fancyfield"
		Width = 184
		Label1.Name = "Label1"
	*</PropValue>

	ADD OBJECT 'Text1' AS textbox WITH ;
		DisabledForeColor = 0,0,0, ;
		FontName = "Tahoma", ;
		Height = 23, ;
		Left = 59, ;
		Name = "Text1", ;
		NullDisplay = ("n/a"), ;
		Top = 5, ;
		Width = 113
		*< END OBJECT: BaseClass="textbox" />

ENDDEFINE

DEFINE CLASS fancyform AS embossedform OF "wizstyle.vcx" 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<PropValue>
		BackColor = 0,128,128
		DoCreate = .T.
		Name = "fancyform"
		wizcboxlbl = .F.
		wizfield = fancyfield
		wizlabel = 
		wizlblcap = lower
		wizlblspace = 
		wizlblsuffix = ("")
		wizlogic = fancylogic
		wizmaxcharfld = 40
		wizmemo = fancymemo
		wizole = fancyole
		layoutsty.Height = 228
		layoutsty.Left = 21
		layoutsty.Name = "layoutsty"
		layoutsty.Shape1.Height = 228
		layoutsty.Shape1.Left = 0
		layoutsty.Shape1.Name = "Shape1"
		layoutsty.Shape1.Top = 0
		layoutsty.Shape1.Width = 538
		layoutsty.Shape2.Height = 13
		layoutsty.Shape2.Left = 6
		layoutsty.Shape2.Name = "Shape2"
		layoutsty.Shape2.Top = 7
		layoutsty.Shape2.Width = 37
		layoutsty.Shape3.Height = 13
		layoutsty.Shape3.Left = 6
		layoutsty.Shape3.Name = "Shape3"
		layoutsty.Shape3.Top = 27
		layoutsty.Shape3.Width = 37
		layoutsty.Shape4.Height = 13
		layoutsty.Shape4.Left = 111
		layoutsty.Shape4.Name = "Shape4"
		layoutsty.Shape4.Top = 6
		layoutsty.Shape4.Width = 37
		layoutsty.Top = 48
		layoutsty.Width = 538
		Label1.FontName = "Tahoma"
		Label1.FontSize = 18
		Label1.Height = 31
		Label1.Left = 21
		Label1.Name = "Label1"
		Label1.Top = 10
		Label1.Width = 111
		Shape1.BackColor = 255,255,255
		Shape1.BorderColor = 255,255,255
		Shape1.Height = 1
		Shape1.Left = 5
		Shape1.Name = "Shape1"
		Shape1.Top = 279
		Shape1.Width = 569
		Shape2.Height = 1
		Shape2.Left = 5
		Shape2.Name = "Shape2"
		Shape2.Top = 43
		Shape2.Width = 569
		Shape3.BackColor = 255,255,255
		Shape3.BorderColor = 255,255,255
		Shape3.Height = 1
		Shape3.Left = 5
		Shape3.Name = "Shape3"
		Shape3.Top = 344
		Shape3.Width = 569
		Shape4.BackStyle = 0
		Shape4.Height = 0
		Shape4.Left = 5
		Shape4.Name = "Shape4"
		Shape4.SpecialEffect = 0
		Shape4.Top = 5
		Shape4.Width = 569
	*</PropValue>

ENDDEFINE

DEFINE CLASS fancylogic AS fancybase OF "wizstyle.vcx" 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="Check1" UniqueID="" Timestamp="" />

	*<PropValue>
		Height = 34
		Name = "fancylogic"
		Width = 88
		Label1.Name = "Label1"
	*</PropValue>

	ADD OBJECT 'Check1' AS checkbox WITH ;
		Caption = "", ;
		DisabledForeColor = 0,0,0, ;
		Height = 18, ;
		Left = 56, ;
		Name = "Check1", ;
		Top = 8, ;
		Width = 17
		*< END OBJECT: BaseClass="checkbox" />

ENDDEFINE

DEFINE CLASS fancymemo AS fancybase OF "wizstyle.vcx" 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="Edit1" UniqueID="" Timestamp="" />

	*<PropValue>
		Height = 90
		Name = "fancymemo"
		Width = 240
		Label1.Name = "Label1"
	*</PropValue>

	ADD OBJECT 'Edit1' AS editbox WITH ;
		DisabledForeColor = 0,0,0, ;
		FontName = "Tahoma", ;
		ForeColor = 0,0,0, ;
		Height = 78, ;
		IntegralHeight = .T., ;
		Left = 54, ;
		Name = "Edit1", ;
		Top = 5, ;
		Width = 177
		*< END OBJECT: BaseClass="editbox" />

ENDDEFINE

DEFINE CLASS fancyole AS fancybase OF "wizstyle.vcx" 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="Oleboundcontrol1" UniqueID="" Timestamp="" />

	*<PropValue>
		Height = 120
		Name = "fancyole"
		Width = 220
		Label1.Name = "Label1"
	*</PropValue>

	ADD OBJECT 'Oleboundcontrol1' AS oleboundcontrol WITH ;
		Height = 100, ;
		Left = 60, ;
		Name = "Oleboundcontrol1", ;
		Top = 12, ;
		Width = 145
		*< END OBJECT: BaseClass="oleboundcontrol" />

ENDDEFINE

DEFINE CLASS grid1 AS grid 
 	*< CLASSDATA: Baseclass="grid" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<PropValue>
		FontName = "MS Sans Serif"
		FontSize = 8
		Height = 152
		Name = "grid1"
		RecordSource = "customer"
		Width = 397
	*</PropValue>

ENDDEFINE

DEFINE CLASS gridaddform AS form 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="Optiongroup1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Commandgroup1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Text1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Label1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Label2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Label3" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Label4" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Label5" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*p: ckeyvalue
	*</DefinedPropArrayMethod>

	*<PropValue>
		AutoCenter = .T.
		BackColor = 192,192,192
		Caption = "Agregar registro"
		DoCreate = .T.
		Height = 293
		Name = "gridaddform"
		ScaleMode = 3
		Width = 498
		WindowType = 1
	*</PropValue>

	ADD OBJECT 'Commandgroup1' AS commandgroup WITH ;
		AutoSize = .T., ;
		BackStyle = 0, ;
		BorderStyle = 0, ;
		ButtonCount = 2, ;
		ControlSource = "nBtnAction", ;
		Height = 39, ;
		Left = 166, ;
		Name = "Commandgroup1", ;
		Top = 248, ;
		Value = 1.00, ;
		Width = 163, ;
		COMMAND1.Caption = "Agregar", ;
		COMMAND1.Height = 29, ;
		COMMAND1.Left = 5, ;
		Command1.Name = "Command1", ;
		Command1.TabIndex = 1, ;
		COMMAND1.Top = 5, ;
		COMMAND1.Width = 70, ;
		COMMAND2.Caption = "Cancelar", ;
		COMMAND2.Height = 29, ;
		COMMAND2.Left = 88, ;
		Command2.Name = "Command2", ;
		Command2.TabIndex = 2, ;
		COMMAND2.Top = 5, ;
		COMMAND2.Width = 70
		*< END OBJECT: BaseClass="commandgroup" />

	ADD OBJECT 'Label1' AS label WITH ;
		AutoSize = .T., ;
		BackStyle = 0, ;
		Caption = "Valor clave:", ;
		Height = 17, ;
		Left = 48, ;
		Name = "Label1", ;
		Top = 203, ;
		Width = 64
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'Label2' AS label WITH ;
		AutoSize = .T., ;
		BackStyle = 0, ;
		Caption = "A. Seleccione la opción para agregar registros:", ;
		Height = 17, ;
		Left = 24, ;
		Name = "Label2", ;
		Top = 24, ;
		Width = 258
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'Label3' AS label WITH ;
		BackStyle = 0, ;
		Caption = "Etiqueta3", ;
		FontItalic = .T., ;
		Height = 16, ;
		Left = 132, ;
		Name = "Label3", ;
		Top = 175, ;
		Width = 145
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'Label4' AS label WITH ;
		AutoSize = .T., ;
		BackStyle = 0, ;
		Caption = "Campo clave:", ;
		Height = 17, ;
		Left = 37, ;
		Name = "Label4", ;
		Top = 175, ;
		Width = 77
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'Label5' AS label WITH ;
		AutoSize = .T., ;
		BackStyle = 0, ;
		Caption = "B: Escriba el valor clave que vincula los registros primario y secundario:", ;
		Height = 17, ;
		Left = 24, ;
		Name = "Label5", ;
		Top = 132, ;
		Width = 393
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'Optiongroup1' AS optiongroup WITH ;
		AutoSize = .T., ;
		BackStyle = 0, ;
		BorderStyle = 0, ;
		ButtonCount = 3, ;
		ControlSource = "nAddAction", ;
		Height = 67, ;
		Left = 36, ;
		Name = "Optiongroup1", ;
		SpecialEffect = 0, ;
		TabIndex = 1, ;
		Top = 48, ;
		Value = 2, ;
		Width = 289, ;
		OPTION1.AutoSize = .T., ;
		Option1.BackStyle = 0, ;
		OPTION1.Caption = "Agregar registro sólo al primario", ;
		OPTION1.Height = 17, ;
		OPTION1.Left = 5, ;
		Option1.Name = "Option1", ;
		OPTION1.Top = 5, ;
		OPTION1.Value = 0, ;
		OPTION1.Width = 195, ;
		OPTION2.AutoSize = .T., ;
		Option2.BackStyle = 0, ;
		OPTION2.Caption = "Agregar registro sólo al secundario (cuadrícula)", ;
		OPTION2.Height = 17, ;
		OPTION2.Left = 5, ;
		Option2.Name = "Option2", ;
		OPTION2.Top = 25, ;
		OPTION2.Value = 1, ;
		OPTION2.Width = 279, ;
		OPTION3.AutoSize = .T., ;
		Option3.BackStyle = 0, ;
		OPTION3.Caption = "Agregar registro a ambos", ;
		OPTION3.Height = 17, ;
		OPTION3.Left = 5, ;
		Option3.Name = "Option3", ;
		OPTION3.Top = 45, ;
		OPTION3.Value = 0, ;
		OPTION3.Width = 158
		*< END OBJECT: BaseClass="optiongroup" />

	ADD OBJECT 'Text1' AS textbox WITH ;
		Alignment = 0, ;
		Height = 24, ;
		Left = 132, ;
		Name = "Text1", ;
		TabIndex = 3, ;
		Top = 199, ;
		Width = 218
		*< END OBJECT: BaseClass="textbox" />
	
	PROCEDURE Init
		LPARAMETERS cFldKey,cKeyValue,nBtnAction,nAddAction,lChildPrimaryKey,lUpdatableParentKey,lNoSendUpdates
		
		IF PARAMETERS() # 7
			RETURN .F.
		ENDIF
		
		THIS.CommandGroup1.Value = 0
		THIS.Label3.Caption = m.cFldKey
		THIS.cKeyValue = m.cKeyValue
		
		DO CASE
		CASE m.lNoSendUpdates
			* Send Parent Updates
			THIS.Optiongroup1.Option1.Enabled = .F.
			THIS.Optiongroup1.Option3.Enabled = .F.
		CASE !m.lUpdatableParentKey
			* Updatable parent key
			THIS.Optiongroup1.Option3.Enabled = .F.
		ENDCASE
		
		* Has a primary key
		IF m.lChildPrimaryKey
			THIS.Optiongroup1.Option2.Enabled = .F.
		ENDIF
		
		DO CASE
		CASE TYPE('THIS.cKeyValue') = "C"
			THIS.Text1.Value = ""
		CASE ATC(TYPE('THIS.cKeyValue'),"NYIBF") # 0
			THIS.Text1.Value = 0
		CASE ATC(TYPE('THIS.cKeyValue'),"DT") # 0
			THIS.Text1.Value = {//}
		CASE TYPE('THIS.cKeyValue') = "L"
			THIS.Text1.Value = .T.
		ENDCASE
		
	ENDPROC

	PROCEDURE Commandgroup1.Click
		cKeyValue = THIS.Parent.Text1.Value
		nAddAction = THIS.Parent.OptionGroup1.Value
		nBtnAction = THIS.Value
		THISFORM.Release()
	ENDPROC

	PROCEDURE Optiongroup1.InteractiveChange
		DO CASE
		CASE THIS.Value = 2
			THISFORM.Text1.Value = THISFORM.cKeyValue
		CASE TYPE('THISFORM.cKeyValue') = "C"
			THISFORM.Text1.Value = ""
		CASE ATC(TYPE('THISFORM.cKeyValue'),"NYIBF") # 0
			THISFORM.Text1.Value = 0
		CASE ATC(TYPE('THISFORM.cKeyValue'),"DT") # 0
			THISFORM.Text1.Value = {//}
		CASE TYPE('THISFORM.cKeyValue') = "L"
			THISFORM.Text1.Value = .T.
		ENDCASE
		
		THISFORM.Text1.ReadOnly = (THIS.Value = 2)
		
	ENDPROC

ENDDEFINE

DEFINE CLASS gridaddrec AS custom 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: runaddform
		*p: addoption
		*p: childprimarykey
		*p: keyfield
		*p: keyvalue
		*p: nosendupdates
		*p: updatableparentkey
	*</DefinedPropArrayMethod>

	*<PropValue>
		Height = 22
		Name = "gridaddrec"
		Width = 39
	*</PropValue>
	
	PROCEDURE runaddform
		#DEFINE C_NOOBJ_LOC	"Falló la creación de la clase de formulario Agregar registro. Verifique o vuelva a instalar el archivo WIZSTYLE.VCX."
		
		PRIVATE cFldKey,cKeyValue,nBtnAction,nAddAction,oGridAddForm 
		
		IF TYPE("THIS.KeyField") # "C"
			THIS.KeyField = ""
		ENDIF
		
		cFldKey = THIS.KeyField
		cKeyValue = THIS.KeyValue
		nBtnAction = 1
		nAddAction = 1
		
		oGridAddForm = CREATE("gridaddform",m.cFldKey,m.cKeyValue,;
			m.nBtnAction,m.nAddAction,THIS.ChildPrimaryKey,THIS.UpdatableParentKey,THIS.NoSendUpdates)
		
		IF TYPE("m.oGridAddForm") # "O"
			=MESSAGEBOX(C_NOOBJ_LOC)
			THIS.AddOption = 0
			RETURN
		ENDIF
		
		IF THIS.NoSendUpdates
			oGridAddForm.OptionGroup1.Value = 2
			oGridAddForm.Text1.Value = m.cKeyValue
		ENDIF
		
		oGridAddForm.Show()
		
		THIS.AddOption = IIF(m.nBtnAction=1,m.nAddAction,0)
		THIS.KeyValue = m.cKeyValue
		
	ENDPROC

ENDDEFINE

DEFINE CLASS gridbtns AS container 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" ProjectClassIcon="stylebmp\textbttn.bmp" ClassIcon="stylebmp\textbttn.bmp" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="cmdFind" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdPrint" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdExit" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdAdd" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdDelete" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: initvars		&& Guarda y establece ciertas variables de entorno.
		*m: updaterows		&& Trata operaciones de agregar, modificar y eliminar registros de tablas.
		*p: hasgeneral		&& Si el formulario tiene un objeto oleboundcontrol de campo general (se establece internamente).
		*p: hasmemo		&& Si el formulario tiene un objeto editbox de campo memo (se establece internamente).
		*p: nworkarea		&& Guarda el área de trabajo anterior (se establece internamente).
		*p: oldalias		&& Guarda el alias al modificar para restaurar con formularios uno a varios (se establece internamente).
		*p: oldbuffering		&& Guarda el estado de almacenamiento de tablas en búfer (se establece internamente).
		*p: oldmultilocks		&& Guarda SET MULTILOCKS (se establece internamente).
		*p: oldrec		&& Guarda el número de registro (se establece internamente).
		*p: oldrefresh		&& Guarda SET REFRESH (se establece internamente).
		*p: oldreprocess		&& Guarda SET REPROCESS (se establece internamente).
		*p: oldsetdelete		&& Guarda SET DELETED (se establece internamente).
		*p: oldsetfields		&& Guarda SET FIELDS (se establece internamente).
		*p: oldtalk		&& Guarda SET TALK (se establece internamente).
		*p: previewinit		&& Para su uso con el botón Vista preliminar del asistente (se establece internamente).
		*p: previewmode		&& Si el formulario está en modo de vista preliminar para utilizarse con el botón Vista preliminar del asistente (se establece internamente).
		*p: usedataenv		&& Si el formulario tiene adjunto un objeto de entorno de datos (se establece internamente).
	*</DefinedPropArrayMethod>

	*<PropValue>
		BackStyle = 0
		BorderWidth = 0
		Height = 26
		Name = "gridbtns"
		nworkarea = 0
		oldrec = 0
		oldrefresh = 0
		oldreprocess = 0
		previewinit = .T.
		previewmode = .F.
		TabIndex = 1
		usedataenv = .T.
		Visible = .T.
		Width = 296
	*</PropValue>

	ADD OBJECT 'cmdAdd' AS commandbutton WITH ;
		Caption = "Ag\<regar", ;
		Enabled = .T., ;
		FontName = "MS Sans Serif", ;
		FontSize = 8, ;
		Height = 24, ;
		Left = 116, ;
		Name = "cmdAdd", ;
		Statusbartext = "Agregar nuevo registro/Guardar modificaciones", ;
		TabIndex = 7, ;
		ToolTipText = "", ;
		Top = 2, ;
		Width = 53
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdDelete' AS commandbutton WITH ;
		Caption = "\<Eliminar", ;
		Enabled = .T., ;
		FontName = "MS Sans Serif", ;
		FontSize = 8, ;
		Height = 24, ;
		Left = 178, ;
		Name = "cmdDelete", ;
		Statusbartext = "Eliminar un registro existente", ;
		TabIndex = 9, ;
		ToolTipText = "", ;
		Top = 2, ;
		Width = 53
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdExit' AS commandbutton WITH ;
		Caption = "\<Salir", ;
		Enabled = .T., ;
		FontName = "MS Sans Serif", ;
		FontSize = 8, ;
		Height = 24, ;
		Left = 240, ;
		Name = "cmdExit", ;
		Statusbartext = "Salir del formulario de entrada", ;
		TabIndex = 10, ;
		ToolTipText = "", ;
		Top = 2, ;
		Width = 53
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdFind' AS commandbutton WITH ;
		Caption = "\<Buscar", ;
		Enabled = .T., ;
		FontName = "MS Sans Serif", ;
		FontSize = 8, ;
		Height = 24, ;
		Left = 0, ;
		Name = "cmdFind", ;
		Statusbartext = "Buscar registros", ;
		TabIndex = 5, ;
		ToolTipText = "", ;
		Top = 2, ;
		Width = 49
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdPrint' AS commandbutton WITH ;
		Caption = "\<Imprimir", ;
		Enabled = .T., ;
		FontName = "MS Sans Serif", ;
		FontSize = 8, ;
		Height = 24, ;
		Left = 58, ;
		Name = "cmdPrint", ;
		Statusbartext = "Imprimir a un informe", ;
		TabIndex = 6, ;
		ToolTipText = "", ;
		Top = 2, ;
		Width = 49
		*< END OBJECT: BaseClass="commandbutton" />
	
	PROCEDURE Destroy
		* Restore various settings
		LOCAL nTablesUsed,aTablesUsed,i,nDECursors,aDECursors,cDataEnvRef 
		DIMENSION aTablesUsed[1]
		
		IF TYPE('THIS.Parent') # "O"
			RETURN
		ENDIF
		
		IF TYPE("THIS.oldTalk") = "C" AND THIS.oldTalk="ON"
			SET TALK ON
		ENDIF
		
		* OLE Servers can still send data back to General fields 
		* even though they are not in Edit Mode. We need to reset 
		* buffering to 1 so the buffer is not updated by the OLE Server.
		* Also, folks might exit out while editing.
		IF THIS.UseDataEnv
			DIMENSION aDECursors[1]
			DO CASE
			CASE TYPE("THISFORM.DataEnvironment") = "O"
				nDECursors = AMEMBERS(aDECursors,THISFORM.DataEnvironment,2)
				cDataEnvRef = "THISFORM.DataEnvironment"
			CASE TYPE("THISFORMSET.DataEnvironment") = "O"
				nDECursors = AMEMBERS(aDECursors,THISFORMSET.DataEnvironment,2)
				cDataEnvRef = "THISFORMSET.DataEnvironment"
			ENDCASE
			FOR i = 1 TO m.nDECursors
				WITH EVAL(m.cDataEnvRef + "." + aDECursors[m.i])
					IF USED(.ALIAS) AND ATC("CURSOR",.BaseClass)#0 AND ;
					  CursorGetProp("sourcetype",.ALIAS)=3 AND ;
					  CursorGetProp("buffering",.ALIAS)>1
						=TableRevert(.T.,.ALIAS)
						=CursorSetProp("buffering",1,.ALIAS)	&&optimistic table buffering
					ENDIF
				ENDWITH
			ENDFOR
		ENDIF
		
		* Skip if using preview mode
		IF THIS.PreviewMode
			RETURN
		ENDIF
		
		IF THIS.oldSetDelete = "OFF"
			SET DELETED OFF
		ENDIF
		SET REPROCESS TO THIS.oldReprocess
		SET MESSAGE TO
		SELECT (THIS.nWorkArea)
		
		IF THIS.UseDataEnv
			RETURN
		ENDIF
		
		* The following code is here to support
		* forms not using a DataEnvironment.
		m.nTablesUsed = AUSED(aTablesUsed)
		FOR i = 1 TO m.nTablesUsed
			IF USED(aTablesUsed[m.i,1]) AND ATC(".TMP",DBF(aTablesUsed[m.i,1]))=0	&&skip for views
				=CursorSetProp("buffering",THIS.oldBuffering,aTablesUsed[m.i,1])	&&optimistic table buffering
			ENDIF
		ENDFOR
		
		IF THIS.oldMultiLocks = "OFF"
			SET MULTILOCKS OFF
		ENDIF
		
		IF THIS.oldSetFields = "ON"
			SET FIELDS ON
		ENDIF
		
		SET REFRESH TO THIS.oldRefresh
		
	ENDPROC

	PROCEDURE Error
		Parameters nError, cMethod, nLine
		LOCAL aFoxErr,nTotErr
		DIMENSION aFoxErr[1]
		nTotErr = AERROR(aFoxErr)
		
		DO CASE
		CASE INLIST(m.nError,1733,1734)  &&property not found -- traps SETALL()
			RETURN
		CASE m.nError=1938  &&no parent
			RETURN
		CASE nToterr>0 AND aFoxErr[1,1] = 1420
			* Corrupt Ole object in General field.
			=MESSAGEBOX(aFoxErr[1,2])
			RETURN
		ENDCASE
		
		**** Error Dialog ******
		=MESSAGEBOX(MESSAGE(1)+CHR(13)+;
		"Error: "+STR(nError)+CHR(13)+;
		MESSAGE()+CHR(13)+;
		"Method: "+cMethod+CHR(13)+;
		"Line: "+STR(nLine))
		
		RETURN TO MASTER
		
	ENDPROC

	PROCEDURE Init
		#DEFINE C_WIZSTYLE			"WIZSTYLE.VCX"
		#DEFINE C_WIZDIR 			"WIZARDS\"
		#DEFINE C_PROMPT1_LOC		"Buscar: "
		#DEFINE E_NOSTYLE_LOC		"No se pudo encontrar la biblioteca de clase (WIZSTYLE.VCX) necesaria para este formulario. "+"Búsquela."
		
		
		LOCAL cWizHomePath,separator,cWizStyFile
		
		
		IF TYPE('THIS.Parent') # "O"
			RETURN
		ENDIF
		
		IF SET("TALK") = "ON"
			SET TALK OFF
			THIS.oldTalk = "ON"
		ELSE
			THIS.oldTalk = "OFF"
		ENDIF
		
		
		IF ATC(C_WIZSTYLE,SET("CLASSLIB")) = 0
			* Returns just the pathname
			cWizHomePath = _WIZARD
			IF '\' $ cWizHomePath
			   cWizHomePath = SUBSTR(m.cWizHomePath,1,RAT('\',m.cWizHomePath))
			   IF RIGHT(m.cWizHomePath,1) = '\' AND LEN(m.cWizHomePath) > 1 ;
			            AND SUBSTR(m.cWizHomePath,LEN(m.cWizHomePath)-1,1) <> ':'
			         cWizHomePath = SUBSTR(m.cWizHomePath,1,LEN(m.cWizHomePath)-1)
			   ENDIF
			ELSE
			   cWizHomePath = ''
			ENDIF
		
			* Add a backslash unless there is one already there.
			separator = IIF(_MAC,":","\")
			IF !(RIGHT(m.cWizHomePath,1) $ '\:') AND !EMPTY(m.cWizHomePath)
			   m.cWizHomePath= m.cWizHomePath+ m.separator
			ENDIF
		
			DO CASE
			CASE FILE(C_WIZSTYLE)
				cWizFile = C_WIZSTYLE
			CASE FILE(m.cWizHomePath+C_WIZSTYLE)
				cWizFile = m.cWizHomePath+C_WIZSTYLE
			CASE FILE(m.cWizHomePath+C_WIZDIR+C_WIZSTYLE)
				cWizFile = m.cWizHomePath+C_WIZDIR+C_WIZSTYLE	
			CASE FILE(HOME()+C_WIZSTYLE)
				cWizFile = HOME()+C_WIZSTYLE
			CASE FILE(HOME()+C_WIZDIR+C_WIZSTYLE)
				cWizFile = HOME()+C_WIZDIR+C_WIZSTYLE
			OTHERWISE
				=MESSAGEBOX(E_NOSTYLE_LOC)
				cWizFile = GETFILE("VCX",C_PROMPT1_LOC+C_WIZSTYLE)
			ENDCASE
			
			IF ATC(C_WIZSTYLE,m.cWizFile)#0
				SET CLASS TO (m.cWizFile) ADDITIVE
			ELSE
				* Failed to get WIZSTYLE.VCX file
				RETURN .F.
			ENDIF
			
		ENDIF
		
		THIS.InitVars()
		
	ENDPROC

	PROCEDURE initvars		&& Guarda y establece ciertas variables de entorno.
		#DEFINE C_NOUPDATEVIEW_LOC	"Puede que las modificaciones en una o más de las vistas no sean permanentes."+"Para solucionarlo, asegúrese de que la casilla de verificación 'Enviar actualizaciones SQL de la vista' está activada en el Diseñador de vistas."
		
		#DEFINE C_READONLY_LOC		"La tabla es de sólo lectura. No podrá modificarla."
		
		LOCAL aTablesUsed,nTablesUsed,i,aMems,nTotMem,cWizFile,lShowedMess,cDataEnvRef
		DIMENSION aTablesUsed[1]
		DIMENSION aMems[1]
		
		THIS.nWorkArea = SELECT()
		THIS.oldSetDelete = SET("DELETED")
		SET DELETED ON
		THIS.oldReprocess = SET("REPROCESS")
		SET REPROCESS TO 0
		
		* These properties should not be used. They are reserved for use by
		* the Preview button of the Form Wizards.
		THIS.PreviewMode = IIF(TYPE("THIS.PreviewMode")#"L",.F.,THIS.PreviewMode)
		THIS.PreviewInit = IIF(TYPE("THIS.PreviewInit")#"L",.T.,THIS.PreviewInit)
		
		* Check for data environment
		DO CASE
		CASE TYPE("THISFORM.DataEnvironment") = "O"
			THIS.UseDataEnv = .T.
			nTotMem = AMEMBERS(aMems,THISFORM.DataEnvironment,2)
			cDataEnvRef = "THISFORM.DataEnvironment"
		CASE TYPE("THISFORMSET.DataEnvironment") = "O"
			THIS.UseDataEnv = .T.
			nTotMem = AMEMBERS(aMems,THISFORMSET.DataEnvironment,2)
			cDataEnvRef = "THISFORMSET.DataEnvironment"
			* let's also set the 
			IF TYPE("THISFORM")="O" AND !THISFORM.VISIBLE 
				THISFORM.VISIBLE = .T.
			ENDIF
		OTHERWISE
			THIS.UseDataEnv = .F.
		ENDCASE
		
		IF THIS.UseDataEnv
			WITH EVAL(m.cDataEnvRef)
				* Check for Views
				FOR i = 1 TO m.nTotMem
					IF UPPER(EVAL("."+aMems[m.i]+".BaseClass")) = "CURSOR"
						WITH EVAL("."+aMems[m.i])
							IF CURSORGETPROP("SourceType",.Alias)#3
								* Check if we need to requery for deleted records.
								* -- Note: Parameterized views are not requeried so all records will be brought over.
								* To remedy this situation you can place a SET DELETED ON command in the
								* BeforeOpenTables event of the DataEnvironment.
								IF THIS.oldSetDelete = "OFF" AND ATC("?",CURSORGETPROP("SQL",.Alias))=0
									=REQUERY(.Alias)
								ENDIF
								* Check if updates are made
								IF !CURSORGETPROP("SendUpdates",.Alias) AND !m.lShowedMess
									=MESSAGEBOX(C_NOUPDATEVIEW_LOC)
									lShowedMess = .T.
								ENDIF
							ENDIF
						ENDWITH
					ENDIF
				ENDFOR
			ENDWITH
		ENDIF
		
		IF ISREADONLY()
			WAIT WINDOW C_READONLY_LOC TIMEOUT 2
		ENDIF
		
		* Disable appropriate buttons
		THIS.cmdAdd.Enabled = !ISREADONLY()
		THIS.cmdDelete.Enabled = !ISREADONLY()
		
		IF THIS.PreviewMode
			RETURN
		ENDIF
		
		IF THIS.UseDataEnv
			RETURN
		ENDIF
		
		* The following code is here to support forms not using a DataEnvironment.
		THIS.oldSetFields = SET("FIELDS")
		SET FIELDS OFF
		THIS.oldMultiLocks = SET("MULTILOCKS")
		SET MULTILOCKS ON
		THIS.oldRefresh = SET("REFRESH")
		SET REFRESH TO 5
		IF !EMPTY(ALIAS())
			THIS.oldBuffering=CursorGetProp("buffering")
			m.nTablesUsed = AUSED(aTablesUsed)
			FOR i = 1 TO m.nTablesUsed
				IF CursorGetProp('sourcetype',aTablesUsed[m.i,1])#3	&&skip for views
					=CursorSetProp("buffering",5,aTablesUsed[m.i,1])	&&optimistic table buffering
				ENDIF
			ENDFOR
		ENDIF
		GO TOP
		
	ENDPROC

	PROCEDURE Refresh
		**** Special Preview Mode Handling ****
		IF THIS.PreviewMode AND THIS.PreviewInit
			THIS.PreviewInit = .F.
			THIS.cmdAdd.Enabled = .F.
			THIS.cmdDelete.Enabled = .F.
			THIS.cmdFind.Enabled = .F.
			THIS.cmdPrint.Enabled = .F.
			THIS.cmdExit.Enabled = .F.
			THIS.nWorkArea = SELECT()
		ENDIF
		
	ENDPROC

	PROCEDURE updaterows		&& Trata operaciones de agregar, modificar y eliminar registros de tablas.
		#DEFINE	E_FAIL_LOC			"Fallo al actualizar la tabla:"
		#DEFINE	E_TRIGGERFAIL_LOC	"Falló el desencadenante."
		#DEFINE	E_FIELDNULL_LOC		"El campo no acepta NULL"
		#DEFINE	E_FIELDRULE_LOC		"Se ha infringido la regla del campo"
		#DEFINE	E_RECORDLOCK_LOC	"Hay otra persona usando ese registro"
		#DEFINE	E_ROWRULE_LOC		"Se ha infringido la regla de la fila"
		#DEFINE	E_UNIQUEINDEX_LOC	"Infracción de índice único"
		#DEFINE	E_DIRTYREC_LOC		"Otra persona ha cambiado los datos. ¿Desea sobrescribir los cambios con sus correcciones?"
		#DEFINE	E_NOFORCE_LOC		"Imposible forzar actualizaciones de tablas."
		#DEFINE E_PROMPT_LOC	 	"Error: "
		#DEFINE MSGBOX_YES			6
		
		LOCAL aErrors,cErrorMessage,aTablesUsed,nTablesUsed,nTotErr 
		LOCAL nFld,i,nOldArea,lSuccess,lInDBC,lOverwrite,lHadMessage
		
		DIMENSION aTablesUsed[1]
		DIMENSION aErrors[1]
		m.cErrorMessage=""
		m.lSuccess = .T.
		m.nOldArea = SELECT()
		m.nTablesUsed = AUSED(aTablesUsed)
		
		* Can wrap everything in transaction if using strictly DBCs
		
		FOR i = 1 TO m.nTablesUsed
		
			SELECT (aTablesUsed[m.i,1])
		
			m.lInDBC = !EMPTY(CURSORGETPROP("Database"))
			m.cErrorMessage = ""
			m.lOverwrite = .F.
			m.lHadMessage = .F.
		
			DO CASE
			CASE CURSORGETPROP("Buffering") = 1
				* Skip if buffering not on
				LOOP
			CASE GetFldState(0) = 2			&&deleted record
				* Only delete current record and force it
				m.lSuccess = TableUpdate(.F.,.T.)
				IF m.lSuccess				&&successful update
					LOOP
				ENDIF
			CASE !m.lInDBC AND (ATC("2",GetFldState(-1))#0 OR;
				 ATC("3",GetFldState(-1))#0)	
				* Field was edited - in Free Table
				* Since free tables are not supported by transactions,
				* we must process record by record
				m.nModRecord = GetNextMod(0)
				DO WHILE m.nModRecord # 0	&&loop locks all records
					GO m.nModRecord
					m.lSuccess = RLOCK()	&&try to lock record
					IF !m.lSuccess			&&failed to lock record
						m.cErrorMessage = E_RECORDLOCK_LOC
						UNLOCK ALL
						EXIT
					ENDIF
					IF !m.lHadMessage	&&so we don't repeat alert
						* See if record(s) modified by another user
						FOR m.nFld = 1 TO FCOUNT()
							IF TYPE(FIELD(m.nFld)) = "G"	&&skip for General fields
								LOOP					
							ENDIF
							IF OLDVAL(FIELD(m.nFld)) # CURVAL(FIELD(m.nFld))
								m.lHadMessage = .T.
								IF MESSAGEBOX(E_DIRTYREC_LOC,4+48) = MSGBOX_YES
									m.lOverwrite = .T.
								ELSE
									m.lSuccess = .F.
									UNLOCK ALL
									EXIT
								ENDIF
							ENDIF
						ENDFOR
					ENDIF
					m.nModRecord = GetNextMod(m.nModRecord)
				ENDDO
				IF m.lSuccess 	&&was able to lock all records
					m.lSuccess = TableUpdate(.T.,m.lOverwrite)
					IF m.lSuccess &&was able to update all records
						LOOP
					ENDIF	
					UNLOCK ALL
				ENDIF
			CASE m.lInDBC
				BEGIN TRANSACTION
				* Try to update all records in selected table
				m.lSuccess = TableUpdate(.T.,.F.)	&&successful update
				IF m.lSuccess
					END TRANSACTION
					LOOP
				ENDIF
				ROLLBACK
			ENDCASE
		
			* Handle errors
			nTotErr =AERROR(aErrors)
			DO CASE
			CASE nTotErr = 0
				
			CASE aErrors[1,1] = 1539				&& Trigger failed
				m.cErrorMessage = E_TRIGGERFAIL_LOC
			CASE aErrors[1,1] = 1581				&& Field doesn't accept NULL
				m.cErrorMessage = E_FIELDNULL_LOC
			CASE aErrors[1,1] = 1582				&& Field rule violated
				m.cErrorMessage = E_FIELDRULE_LOC
			CASE aErrors[1,1] = 1700				&& Record in use by another user
				m.cErrorMessage = E_RECORDLOCK_LOC
			CASE aErrors[1,1] = 1583				&& Row rule violated
				m.cErrorMessage = E_ROWRULE_LOC
			CASE aErrors[1,1] = 1884				&& Unique index violation
				m.cErrorMessage = E_UNIQUEINDEX_LOC
			CASE aErrors[1,1] = 1585				&& Record changed by another user
		
				IF m.lInDBC		&&handle free tables above
					* Dislpay conflict alert
					IF MESSAGEBOX(E_DIRTYREC_LOC,4+48) = MSGBOX_YES
						*Try to force update
						BEGIN TRANSACTION				
						m.lSuccess = TABLEUPDATE(.T.,.T.)
						IF m.lSuccess
							END TRANSACTION
							LOOP
						ELSE
							ROLLBACK
							=MESSAGEBOX(E_NOFORCE_LOC)
						ENDIF			
					ENDIF
				ENDIF
		
			OTHERWISE
				IF !EMPTY(m.cErrorMessage)	&&for free table handling above
					m.cErrorMessage = E_PROMPT_LOC+aErrors[1,2]
				ENDIF
			ENDCASE
		
			* Had an error we couldn't handle
			=TABLEREVERT(.T.)  &&revert all records
			m.lSuccess = .F.
			IF !EMPTY(m.cErrorMessage)
				=MESSAGEBOX(E_FAIL_LOC+m.cErrorMessage)
			ENDIF
		
		ENDFOR
		
		SELECT (m.nOldArea)
		RETURN m.lSuccess
		
	ENDPROC

	PROCEDURE cmdAdd.Click
		#DEFINE C_NOUPDATE_LOC	"No puede agregar un nuevo registro porque la vista o las vistas seleccionadas no envían actualizaciones."
		IF CURSORGETPROP("SourceType")#3 AND !CURSORGETPROP("SendUpdates")
			MESSAGEBOX(C_NOUPDATE_LOC)
			RETURN
		ENDIF
		APPEND BLANK
		THISFORM.REFRESH()
	ENDPROC

	PROCEDURE cmdDelete.Click
		#DEFINE MSGBOX_YES		6
		#DEFINE C_MSGBOX1		36
		#DEFINE C_DELETE_LOC	"¿Desea eliminar este registro?"
		
		IF MESSAGEBOX(C_DELETE_LOC,C_MSGBOX1) = MSGBOX_YES
			DELETE
			IF THIS.Parent.UpdateRows()  &&success
				* Success
				IF !EOF()
					SKIP 1
				ENDIF
				IF EOF() AND !BOF()
					SKIP -1
				ENDIF
			ENDIF
		ENDIF
		THISFORM.REFRESH()
		IF THISFORM.ShowWindow = 2 
			Activate Window (THISFORM.Name)
		ENDIF
		
	ENDPROC

	PROCEDURE cmdExit.Click
		THISFORM.Release
		
	ENDPROC

	PROCEDURE cmdFind.Click
		
		LOCAL lVisChange,lStateChange,oSearchDlog
		
		* Check if SDI Window
		IF THISFORM.ShowWindow = 2 
			IF !_VFP.Visible
				_VFP.Visible = .T.
				lVisChange = .T.
			ENDIF
			IF _SCREEN.WindowState = 1
				_SCREEN.WindowState = 0
				lStateChange = .T.
			ENDIF
		ENDIF
		
		oSearchDlog = CREATE("searchform")
		oSearchDlog.SHOW()
		THISFORM.REFRESH()
		
		IF m.lVisChange
			_VFP.Visible = .F.
		ENDIF
		IF m.lStateChange 
			_SCREEN.WindowState = 1
		ENDIF
		IF THISFORM.ShowWindow = 2 
			Activate Window (THISFORM.Name)
		ENDIF
		
	ENDPROC

	PROCEDURE cmdPrint.Click
		#DEFINE C_MAKEREPO_LOC			"No se pudo encontrar un informe para imprimir. ¿Desea crear uno nuevo?"
		#DEFINE C_NOOPEN_LOC			"Error al abrir la tabla. Imposible imprimir el informe."
		#DEFINE C_GETFILEPROMPT_LOC		"Imprimir el informe:"
		
		LOCAL cRepName,nSaveSess,cSaveAlias,cSaveSource,cSaveData 
		
		cSaveAlias = ALIAS()
		cSaveSource = CURSORGETPROP("SourceName")
		cSaveData = CURSORGETPROP("Database")
		cDiffSource = ""
		cRepName = LEFT(ALIAS(),8)+".FRX"
		nSaveSess = SET("DATASESSION")
		
		#IF 0
			* Handling for Private data sessions
			IF m.nSaveSess # 1
				SET DATASESSION TO 1
				SELECT 0
				IF !EMPTY(m.cSaveData)
					OPEN DATABASE (m.cSaveData)
				ENDIF
				IF USED(m.cSaveAlias)
					SELECT (m.cSaveAlias)
					IF CURSORGETPROP("SourceName")#m.cSaveSource
						cDiffSource = CURSORGETPROP("SourceName")
						USE IN (m.cSaveAlias)
						SELECT 0
					ENDIF
				ENDIF	
				IF EMPTY(ALIAS())
					USE (m.cSaveSource) AGAIN ALIAS (m.cSaveAlias) SHARED
					IF EMPTY(ALIAS())
						=MESSAGEBOX(C_NOOPEN_LOC)
						RETURN
					ENDIF
				ENDIF
			ENDIF
		#ENDIF
		
		IF FILE(m.cRepName)
			REPORT FORM (m.cRepName) PREVIEW NOWAIT
		ELSE
			m.cRepName = GETFILE("frx",C_GETFILEPROMPT_LOC,"",1)
			IF !EMPTY(m.cRepName)
				IF FILE(m.cRepName)
					* User pressed Open button
					REPORT FORM (m.cRepName) PREVIEW NOWAIT
				ELSE
					* User pressed New button
					DO (_WIZARD) WITH "AUTOREPORT"
				ENDIF
			ENDIF
		ENDIF
		
		#IF 0
			IF !EMPTY(cDiffSource)
				USE (m.cDiffSource) IN 0
			ENDIF
		
			SET DATASESSION TO m.nSaveSess
			SELECT (m.cSaveAlias)
		#ENDIF
		
		IF THISFORM.ShowWindow = 2 
			Activate Window (THISFORM.Name)
		ENDIF
		
	ENDPROC

ENDDEFINE

DEFINE CLASS layoutsty AS container 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" ProjectClassIcon="stylebmp\layout.bmp" ClassIcon="stylebmp\layout.bmp" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="Shape1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Shape2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Shape3" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Shape4" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*p: ocol2
		*p: odimensions
		*p: olabel1
		*p: olabel2
	*</DefinedPropArrayMethod>

	*<PropValue>
		Height = 205
		Name = "layoutsty"
		ocol2 = Shape4
		odimensions = Shape1
		olabel1 = Shape2
		olabel2 = Shape3
		TabIndex = 0
		Width = 517
	*</PropValue>

	ADD OBJECT 'Shape1' AS shape WITH ;
		Height = 205, ;
		Left = 0, ;
		Name = "Shape1", ;
		Top = 0, ;
		Width = 517
		*< END OBJECT: BaseClass="shape" />

	ADD OBJECT 'Shape2' AS shape WITH ;
		Height = 13, ;
		Left = 24, ;
		Name = "Shape2", ;
		Top = 24, ;
		Width = 37
		*< END OBJECT: BaseClass="shape" />

	ADD OBJECT 'Shape3' AS shape WITH ;
		Height = 13, ;
		Left = 24, ;
		Name = "Shape3", ;
		Top = 45, ;
		Width = 37
		*< END OBJECT: BaseClass="shape" />

	ADD OBJECT 'Shape4' AS shape WITH ;
		Height = 13, ;
		Left = 228, ;
		Name = "Shape4", ;
		Top = 24, ;
		Width = 37
		*< END OBJECT: BaseClass="shape" />

ENDDEFINE

DEFINE CLASS nobtns AS baseform OF "wizstyle.vcx" 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="Shape1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Shape2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Label1" UniqueID="" Timestamp="" />

	*<PropValue>
		DoCreate = .T.
		Left = 6
		Name = "nobtns"
		ScaleMode = 3
		Top = 6
		wizbtnpos = 0
		wizbuttons = 0
	*</PropValue>

	ADD OBJECT 'Label1' AS label WITH ;
		AutoSize = .T., ;
		BackStyle = 0, ;
		Caption = "Etiqueta1", ;
		FontSize = 14, ;
		Height = 22, ;
		Left = 27, ;
		Name = "Label1", ;
		Top = 12, ;
		Width = 62
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'Shape1' AS shape WITH ;
		Height = 2, ;
		Left = 1, ;
		Name = "Shape1", ;
		Top = 48, ;
		Width = 584
		*< END OBJECT: BaseClass="shape" />

	ADD OBJECT 'Shape2' AS shape WITH ;
		Height = 2, ;
		Left = 3, ;
		Name = "Shape2", ;
		Top = 264, ;
		Width = 584
		*< END OBJECT: BaseClass="shape" />

ENDDEFINE

DEFINE CLASS picbtns AS txtbtns OF "wizstyle.vcx" 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" ProjectClassIcon="stylebmp\picbttns.bmp" ClassIcon="stylebmp\picbttns.bmp" />

	*<DefinedPropArrayMethod>
		*p: wizbmppath
	*</DefinedPropArrayMethod>

	*<PropValue>
		Height = 24
		Name = "picbtns"
		Width = 522
		wizbmppath = (HOME()+"WIZARDS\WIZBMPS\")
		cmdPrev.Caption = ""
		cmdPrev.Left = 49
		cmdPrev.Name = "cmdPrev"
		cmdPrev.Picture = (HOME()+"WIZARDS\WIZBMPS\WZBACK.BMP")
		CMDPREV.ToolTipText = "Registro anterior"
		cmdPrev.Top = 0
		cmdPrev.Width = 50
		cmdNext.Caption = ""
		cmdNext.ColorSource = 0
		cmdNext.Left = 98
		cmdNext.Name = "cmdNext"
		cmdNext.Picture = (HOME()+"WIZARDS\WIZBMPS\WZNEXT.BMP")
		CMDNEXT.ToolTipText = "Registro siguiente"
		cmdNext.Top = 0
		cmdNext.Width = 50
		cmdTop.Caption = ""
		cmdTop.Left = 0
		cmdTop.Name = "cmdTop"
		cmdTop.Picture = (HOME()+"WIZARDS\WIZBMPS\WZTOP.BMP")
		CMDTOP.ToolTipText = "Primer registro"
		cmdTop.Top = 0
		cmdTop.Width = 50
		cmdEnd.Caption = ""
		cmdEnd.Left = 147
		cmdEnd.Name = "cmdEnd"
		cmdEnd.Picture = (HOME()+"WIZARDS\WIZBMPS\WZEND.BMP")
		CMDEND.ToolTipText = "Último registro"
		cmdEnd.Top = 0
		cmdEnd.Width = 50
		cmdFind.Caption = ""
		cmdFind.Left = 206
		cmdFind.Name = "cmdFind"
		cmdFind.Picture = (HOME()+"WIZARDS\WIZBMPS\WZLOCATE.BMP")
		CMDFIND.ToolTipText = "Buscar registros"
		cmdFind.Top = 0
		cmdFind.Width = 50
		cmdPrint.Caption = ""
		cmdPrint.Left = 255
		cmdPrint.Name = "cmdPrint"
		cmdPrint.Picture = (HOME()+"WIZARDS\WIZBMPS\WZPRINT.BMP")
		CMDPRINT.ToolTipText = "Imprimir informe"
		cmdPrint.Top = 0
		cmdPrint.Width = 50
		cmdExit.Caption = ""
		cmdExit.Left = 471
		cmdExit.Name = "cmdExit"
		cmdExit.Picture = (HOME()+"WIZARDS\WIZBMPS\WZCLOSE.BMP")
		CMDEXIT.ToolTipText = "Salir del formulario"
		cmdExit.Top = 0
		cmdExit.Width = 50
		cmdAdd.Caption = ""
		cmdAdd.Left = 314
		cmdAdd.Name = "cmdAdd"
		cmdAdd.Picture = (HOME()+"WIZARDS\WIZBMPS\WZNEW.BMP")
		CMDADD.ToolTipText = "Agregar/Guardar registro"
		cmdAdd.Top = 0
		cmdAdd.Width = 50
		cmdDelete.Caption = ""
		cmdDelete.Left = 412
		cmdDelete.Name = "cmdDelete"
		cmdDelete.Picture = (HOME()+"WIZARDS\WIZBMPS\WZDELETE.BMP")
		CMDDELETE.ToolTipText = "Eliminar registro"
		cmdDelete.Top = 0
		cmdDelete.Width = 50
		cmdEdit.Caption = ""
		cmdEdit.Left = 363
		cmdEdit.Name = "cmdEdit"
		cmdEdit.Picture = (HOME()+"WIZARDS\WIZBMPS\WZEDIT.BMP")
		CMDEDIT.ToolTipText = "Modificar/Revertir registro"
		cmdEdit.Top = 0
		cmdEdit.Width = 50
	*</PropValue>
	
	PROCEDURE Init
		
		TxtBtns::Init()
		THISFORM.ShowTips = .T.
		
	ENDPROC

	PROCEDURE setcaption
		IF !THIS.EditMode
			THIS.cmdAdd.Picture = THIS.wizbmppath+"wznew.bmp"
			THIS.cmdEdit.Picture = THIS.wizbmppath+"wzedit.bmp"
			THIS.cmdAdd.DownPicture = THIS.wizbmppath+"wznew.bmp"
			THIS.cmdEdit.DownPicture = THIS.wizbmppath+"wzedit.bmp"
		ELSE
			THIS.cmdAdd.Picture = THIS.wizbmppath+"wzsave.bmp"
			THIS.cmdEdit.Picture = THIS.wizbmppath+"wzundo.bmp"
			THIS.cmdAdd.DownPicture = THIS.wizbmppath+"wzsave.bmp"
			THIS.cmdEdit.DownPicture = THIS.wizbmppath+"wzundo.bmp"
		ENDIF
	ENDPROC

ENDDEFINE

DEFINE CLASS scrollgrid AS grid 
 	*< CLASSDATA: Baseclass="grid" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="Column1.Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Column1.Container1" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*p: wizbtnstyle
	*</DefinedPropArrayMethod>

	*<PropValue>
		AllowHeaderSizing = .F.
		AllowRowSizing = .F.
		BackColor = 192,192,192
		ColumnCount = 1
		DeleteMark = .F.
		HeaderHeight = 0
		Height = 176
		Highlight = .F.
		HighlightRow = .F.
		Name = "scrollgrid"
		RecordMark = .F.
		RowHeight = 300
		ScrollBars = 2
		SplitBar = .F.
		Width = 369
		wizbtnstyle = gridbtns
		Column1.BackColor = 192,192,192
		Column1.Name = "Column1"
		Column1.Sparse = .F.
		Column1.Width = 500
	*</PropValue>

	ADD OBJECT 'Column1.Container1' AS container WITH ;
		BackStyle = 1, ;
		Height = 200, ;
		Left = 15, ;
		Name = "Container1", ;
		Top = 23, ;
		Width = 200
		*< END OBJECT: BaseClass="container" />

	ADD OBJECT 'Column1.Header1' AS header WITH ;
		Caption = "Encabezado1", ;
		Name = "Header1"
		*< END OBJECT: BaseClass="header" />

ENDDEFINE

DEFINE CLASS searchclass AS container 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" ProjectClassIcon="stylebmp\searchcl.bmp" ClassIcon="stylebmp\searchcl.bmp" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="cboFields1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cboOperators1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtExpr1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cboFields2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cboOperators2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtExpr2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="optgrpAndOr" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="label1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="label2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="label3" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="label4" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="label5" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="label6" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkCaseSensitive" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: dataexpr
		*m: searchexpr
		*m: searchitem
		*p: remotedelimeter
	*</DefinedPropArrayMethod>

	*<PropValue>
		BackColor = 192,192,192
		BackStyle = 0
		Height = 160
		Name = "searchclass"
		remotedelimeter = (.F.)
		TabIndex = 1
		Width = 452
	*</PropValue>

	ADD OBJECT 'cboFields1' AS combobox WITH ;
		ControlSource = "", ;
		FontName = "MS Sans Serif", ;
		FontSize = 8, ;
		Height = 23, ;
		Left = 11, ;
		Name = "cboFields1", ;
		Style = 2, ;
		TabIndex = 1, ;
		Top = 25, ;
		Width = 141
		*< END OBJECT: BaseClass="combobox" />

	ADD OBJECT 'cboFields2' AS combobox WITH ;
		FontName = "MS Sans Serif", ;
		FontSize = 8, ;
		Height = 23, ;
		Left = 11, ;
		Name = "cboFields2", ;
		Style = 2, ;
		TabIndex = 4, ;
		Top = 117, ;
		Width = 141
		*< END OBJECT: BaseClass="combobox" />

	ADD OBJECT 'cboOperators1' AS combobox WITH ;
		Alignment = 0, ;
		FontName = "MS Sans Serif", ;
		FontSize = 8, ;
		Height = 23, ;
		Left = 158, ;
		Name = "cboOperators1", ;
		Style = 2, ;
		TabIndex = 2, ;
		Top = 25, ;
		Width = 96
		*< END OBJECT: BaseClass="combobox" />

	ADD OBJECT 'cboOperators2' AS combobox WITH ;
		FontName = "MS Sans Serif", ;
		FontSize = 8, ;
		Height = 23, ;
		Left = 160, ;
		Name = "cboOperators2", ;
		Style = 2, ;
		TabIndex = 5, ;
		Top = 117, ;
		Width = 96
		*< END OBJECT: BaseClass="combobox" />

	ADD OBJECT 'chkCaseSensitive' AS checkbox WITH ;
		AutoSize = .T., ;
		BackStyle = 0, ;
		Caption = "\<Distinguir MAY/min", ;
		FontName = "MS Sans Serif", ;
		FontSize = 8, ;
		Height = 15, ;
		Left = 290, ;
		Name = "chkCaseSensitive", ;
		TabIndex = 8, ;
		Top = 69, ;
		Width = 155
		*< END OBJECT: BaseClass="checkbox" />

	ADD OBJECT 'label1' AS label WITH ;
		BackStyle = 0, ;
		Caption = "Campo:", ;
		FontName = "MS Sans Serif", ;
		FontSize = 8, ;
		Height = 16, ;
		Left = 12, ;
		Name = "label1", ;
		Top = 7, ;
		Width = 102
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'label2' AS label WITH ;
		BackStyle = 0, ;
		Caption = "Operador:", ;
		FontName = "MS Sans Serif", ;
		FontSize = 8, ;
		Height = 16, ;
		Left = 158, ;
		Name = "label2", ;
		Top = 7, ;
		Width = 93
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'label3' AS label WITH ;
		BackStyle = 0, ;
		Caption = "Valor:", ;
		FontBold = .T., ;
		FontName = "MS Sans Serif", ;
		FontSize = 8, ;
		Height = 16, ;
		Left = 262, ;
		Name = "label3", ;
		Top = 7, ;
		Width = 165
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'label4' AS label WITH ;
		BackStyle = 0, ;
		Caption = "Campo:", ;
		FontName = "MS Sans Serif", ;
		FontSize = 8, ;
		Height = 16, ;
		Left = 12, ;
		Name = "label4", ;
		Top = 99, ;
		Width = 102
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'label5' AS label WITH ;
		BackStyle = 0, ;
		Caption = "Operador:", ;
		FontName = "MS Sans Serif", ;
		FontSize = 8, ;
		Height = 16, ;
		Left = 161, ;
		Name = "label5", ;
		Top = 99, ;
		Width = 93
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'label6' AS label WITH ;
		BackStyle = 0, ;
		Caption = "Valor:", ;
		FontBold = .T., ;
		FontName = "MS Sans Serif", ;
		FontSize = 8, ;
		Height = 16, ;
		Left = 262, ;
		Name = "label6", ;
		Top = 99, ;
		Width = 165
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'optgrpAndOr' AS optiongroup WITH ;
		AutoSize = .T., ;
		BackStyle = 0, ;
		ButtonCount = 2, ;
		Height = 46, ;
		Left = 50, ;
		Name = "optgrpAndOr", ;
		TabIndex = 7, ;
		Top = 55, ;
		Value = 1, ;
		Width = 58, ;
		Option2.BackStyle = 0, ;
		OPTION2.Caption = "\<O", ;
		OPTION2.FontBold = .T., ;
		OPTION2.FontName = "MS Sans Serif", ;
		OPTION2.FontSize = 8, ;
		OPTION2.Height = 18, ;
		OPTION2.Left = 5, ;
		Option2.Name = "Option2", ;
		OPTION2.Top = 23, ;
		OPTION2.Value = 0, ;
		OPTION2.Width = 39, ;
		Option1.BackStyle = 0, ;
		OPTION1.Caption = "\<Y", ;
		OPTION1.FontBold = .T., ;
		OPTION1.FontName = "MS Sans Serif", ;
		OPTION1.FontSize = 8, ;
		OPTION1.Height = 18, ;
		OPTION1.Left = 5, ;
		Option1.Name = "Option1", ;
		OPTION1.Top = 5, ;
		OPTION1.Value = 1, ;
		OPTION1.Width = 48
		*< END OBJECT: BaseClass="optiongroup" />

	ADD OBJECT 'txtExpr1' AS textbox WITH ;
		FontName = "MS Sans Serif", ;
		FontSize = 8, ;
		Height = 23, ;
		Left = 260, ;
		Name = "txtExpr1", ;
		TabIndex = 3, ;
		Top = 25, ;
		Width = 176
		*< END OBJECT: BaseClass="textbox" />

	ADD OBJECT 'txtExpr2' AS textbox WITH ;
		FontName = "MS Sans Serif", ;
		FontSize = 8, ;
		Height = 23, ;
		Left = 260, ;
		Name = "txtExpr2", ;
		TabIndex = 6, ;
		Top = 118, ;
		Width = 176
		*< END OBJECT: BaseClass="textbox" />
	
	PROCEDURE dataexpr
		LPARAMETER cDataType,cFldExpr
		
		LOCAL cTmpExpr
		
		DO CASE
		CASE INLIST(m.cDataType,"M","G","P","O","U")
			RETURN ""
		
		CASE m.cDataType = "C"
			IF TYPE("'Test'="+m.cFldExpr) # "L"
				IF THIS.REMOTEDELIMETER
					cTmpExpr = '"'+m.cFldExpr+'"'
				ELSE
					cTmpExpr = "["+m.cFldExpr+"]"
				ENDIF
			ELSE
				cTmpExpr = m.cFldExpr
			ENDIF
			
			* Check for case sensitive
			IF THIS.chkCaseSensitive.Value = 0
				m.cTmpExpr= "UPPER("+m.cTmpExpr+")" 
			ENDIF
			RETURN m.cTmpExpr
			
		CASE INLIST(m.cDataType,"N","F","I","Y","B")
			* Check for any commas and remove
			RETURN ALLTRIM(STR(VAL(STRTRAN(m.cFldExpr,",")),16,4))
		
		CASE INLIST(m.cDataType,"D","T")
			RETURN "{"+CHRTRAN(m.cFldExpr,"{}","")+"}"
		
		OTHERWISE
			RETURN ""
		
		ENDCASE
		
		
	ENDPROC

	PROCEDURE Destroy
		RELEASE aWizFList
		
	ENDPROC

	PROCEDURE searchexpr
		LOCAL cGetExpr1,cGetExpr2,cJoin,cGetExpr
		
		m.cGetExpr1 = THIS.SearchItem(THIS.cboFields1,THIS.cboOperators1,THIS.txtExpr1)
		m.cGetExpr2 = THIS.SearchItem(THIS.cboFields2,THIS.cboOperators2,THIS.txtExpr2)
		m.cJoin = IIF(THIS.optGrpAndOr.value = 2," OR "," AND ")
		
		DO CASE
		CASE EMPTY(m.cGetExpr1) AND EMPTY(m.cGetExpr2)
			m.cGetExpr = ""
		CASE EMPTY(m.cGetExpr2)
			m.cGetExpr = m.cGetExpr1
		CASE EMPTY(m.cGetExpr1)
			m.cGetExpr = m.cGetExpr2
		OTHERWISE
			m.cGetExpr = m.cGetExpr1+m.cJoin+m.cGetExpr2
		ENDCASE
		
		RETURN m.cGetExpr
	ENDPROC

	PROCEDURE searchitem
		LPARAMETERS oField,oOp,oExpr
		LOCAL cExpr,cDataType,cOp,cFldName,cFldExpr,cRetExpr,aExprs,nTotExprs,i
		
		* Check to make sure proper parameters passed
		IF TYPE("m.oField")#"O" OR TYPE("m.oOp")#"O" OR TYPE("m.oExpr")#"O"
			RETURN ""
		ENDIF
		
		m.cFldName = ALLTRIM(m.oField.Value)
		m.cFldExpr = ALLTRIM(m.oExpr.Value)
		
		* If empty expression return empty.
		IF EMPTY(m.cFldExpr) AND !INLIST(m.oOp.listitemid,5,6)
			RETURN ""
		ENDIF
		
		* Get data type of field
		m.cDataType = aWizFList(m.oField.listitemid,2)
		
		IF m.cDataType = "C" AND THIS.chkCaseSensitive.Value = 0
			m.cFldName = "UPPER("+m.cFldName+")" 
		ENDIF
		
		* Get the operator language equivalent
		DO CASE
		CASE m.oOp.listitemid = 1	&& equals
			m.cOp = "="
		CASE m.oOp.listitemid = 2	&& not equals
			m.cOp = "<>"
		CASE m.oOp.listitemid = 3	&& more than
			m.cOp = ">"
		CASE m.oOp.listitemid = 4	&& less than
			m.cOp = "<"
		CASE m.oOp.listitemid = 5	&& is blank
			RETURN "EMPTY("+m.cFldName+")"
		CASE m.oOp.listitemid = 6	&& is NULL
			RETURN "ISNULL("+m.cFldName+")"
		CASE m.cDataType = "L" 		&& don't allow other options for logical type
			m.cOp = "="
		CASE m.oOp.listitemid = 7	&& contains
			m.cFldExpr = THIS.DataExpr("C",m.cFldExpr)
			DO CASE
			CASE m.cDataType = "T"
				RETURN "AT("+m.cFldExpr+",TTOC("+m.cFldName+"))>0"
			CASE m.cDataType = "D"
				RETURN "AT("+m.cFldExpr+",DTOC("+m.cFldName+"))>0"
			CASE INLIST(m.cDataType,"N","F","I","Y","B")
				RETURN "AT("+m.cFldExpr+",ALLTRIM(STR("+m.cFldName+")))>0"
			OTHERWISE
				RETURN "AT("+m.cFldExpr+","+m.cFldName+")>0"
			ENDCASE
		OTHERWISE
			nTotExprs = OCCURS(",",m.cFldExpr)+1
			DIMENSION aExprs[m.nTotExprs]
			FOR i =  1 TO m.nTotExprs
				DO CASE
				CASE m.i = m.nTotExprs
					aExprs[m.i] = SUBSTR(m.cFldExpr,RAT(",",m.cFldExpr)+1)
				CASE m.i =1
					aExprs[m.i] = LEFT(m.cFldExpr,AT(",",m.cFldExpr)-1)
				OTHERWISE
					aExprs[m.i] = SUBSTR(m.cFldExpr,AT(",",m.cFldExpr,m.i-1)+1,;
						AT(",",m.cFldExpr,m.i)-AT(",",m.cFldExpr,m.i-1)-1)
				ENDCASE
				aExprs[m.i] = THIS.DataExpr(m.cDataType,aExprs[m.i])
			ENDFOR
		
			DO CASE
			CASE m.oOp.listitemid = 8	&& in
				m.cFldExpr = ""
				FOR i = 1 TO m.nTotExprs
					m.cFldExpr = m.cFldExpr + aExprs[m.i]
					IF	m.i # m.nTotExprs
						m.cFldExpr = m.cFldExpr + ","			
					ENDIF
				ENDFOR
				RETURN "INLIST("+m.cFldName+","+m.cFldExpr+")"
			CASE m.oOp.listitemid = 9	&& between
				IF ALEN(aExprs)=1
					DIMENSION aExprs[2]
					aExprs[2] = aExprs[1]
				ENDIF
				IF ALEN(aExprs)>2
					DIMENSION aExprs[2]
				ENDIF
				RETURN "BETWEEN("+m.cFldName+","+aExprs[1]+","+aExprs[2]+")"
			OTHERWISE
				RETURN ""
			ENDCASE
		ENDCASE
		
		DO CASE
		CASE INLIST(m.cDataType,"M","G","P","O","U")
			RETURN ""
		CASE m.cDataType = "L"
			IF TYPE(m.cFldName+m.cOp+m.cFldExpr) # "L"
				IF (AT(m.cFldExpr,"fFnN")#0 AND m.cOp # "<>") OR (AT(m.cFldExpr,"tTyY")#0 AND m.cOp = "<>")
					m.cFldName = "!"+m.cFldName
				ENDIF
				RETURN m.cFldName
			ENDIF
		OTHERWISE
			m.cFldExpr = THIS.DataExpr(m.cDataType,m.cFldExpr)
		ENDCASE
		
		IF EMPTY(m.cFldExpr)
			RETURN ""
		ELSE
			RETURN m.cFldName+m.cOp+m.cFldExpr
		ENDIF
		
		
	ENDPROC

	PROCEDURE cboFields1.Init
		#DEFINE NUM_AFIELDS 16
		LOCAL i
		PUBLIC aWizFList
		DIMENSION aWizFList[1]
		=AFIELDS(aWizFList)
		FOR m.i = FCOUNT() TO 1 STEP -1
			IF INLIST(aWizFList[m.i,2],"G","M","U")	&&Memo field
				=ADEL(aWizFList,m.i)
				DIMENSION aWizFList[MAX(1,ALEN(aWizFList,1)-1),NUM_AFIELDS]
			ENDIF
		ENDFOR
		THIS.RowSourceType = 5
		THIS.RowSource = "aWizFList"
		THIS.VALUE = THIS.LIST[1]
		
	ENDPROC

	PROCEDURE cboFields2.Init
		THIS.RowSourceType = 5
		THIS.RowSource = "aWizFList"
		THIS.VALUE = THIS.LIST[1]
		
	ENDPROC

	PROCEDURE cboOperators1.Init
		#DEFINE C_OPERATORS_LOC	"es igual\;no es igual\;más que\;menos que\;es blanco\;es NULL\;contiene\;en\;entre"
		THIS.ADDITEM(C_OPERATORS_LOC)
		THIS.VALUE = THIS.LIST[1]
		
	ENDPROC

	PROCEDURE cboOperators1.InteractiveChange
		IF INLIST(THIS.ListItemId,5,6)
			THIS.Parent.TxtExpr1.Value = ""
		ENDIF
		THIS.Parent.TxtExpr1.ENABLED = !INLIST(THIS.ListItemId,5,6)
		
	ENDPROC

	PROCEDURE cboOperators2.Init
		#DEFINE C_OPERATORS_LOC	"es igual\;no es igual\;más que\;menos que\;es blanco\;es NULL\;contiene\;en\;entre"
		THIS.ADDITEM(C_OPERATORS_LOC)
		THIS.VALUE = THIS.LIST[1]
		
	ENDPROC

	PROCEDURE cboOperators2.InteractiveChange
		IF INLIST(THIS.ListItemId,5,6)
			THIS.Parent.TxtExpr2.Value = ""
		ENDIF
		THIS.Parent.TxtExpr2.ENABLED = !INLIST(THIS.ListItemId,5,6)
		
	ENDPROC

	PROCEDURE optgrpAndOr.Init
		THIS.VALUE =1
	ENDPROC

ENDDEFINE

DEFINE CLASS searchform AS form 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" ProjectClassIcon="stylebmp\searchfm.bmp" ClassIcon="stylebmp\searchfm.bmp" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="Searchclass1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Commandgroup1" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*p: changedfilter
		*p: savefilter
		*p: saverecord
	*</DefinedPropArrayMethod>

	*<PropValue>
		AlwaysOnTop = .T.
		AutoCenter = .T.
		BorderStyle = 1
		Caption = "Buscar"
		DoCreate = .T.
		Height = 216
		Name = "searchform"
		Width = 477
		WindowType = 1
	*</PropValue>

	ADD OBJECT 'Commandgroup1' AS commandgroup WITH ;
		BackStyle = 0, ;
		BorderStyle = 0, ;
		ButtonCount = 3, ;
		Height = 31, ;
		Left = 118, ;
		Name = "Commandgroup1", ;
		Top = 175, ;
		Value = 1, ;
		Width = 241, ;
		Command1.Caption = "\<Buscar", ;
		Command1.Height = 29, ;
		Command1.Left = 0, ;
		Command1.Name = "Command1", ;
		Command1.TabIndex = 1, ;
		Command1.Top = 1, ;
		Command1.Width = 73, ;
		Command2.Caption = "\<Todo", ;
		Command2.Height = 29, ;
		Command2.Left = 84, ;
		Command2.Name = "Command2", ;
		Command2.TabIndex = 2, ;
		Command2.Top = 1, ;
		Command2.Width = 73, ;
		Command3.Cancel = .T., ;
		Command3.Caption = "\<Cancelar", ;
		Command3.Height = 29, ;
		Command3.Left = 168, ;
		Command3.Name = "Command3", ;
		Command3.TabIndex = 3, ;
		Command3.Top = 1, ;
		Command3.Width = 73
		*< END OBJECT: BaseClass="commandgroup" />

	ADD OBJECT 'Searchclass1' AS searchclass WITH ;
		BorderWidth = 0, ;
		Height = 160, ;
		Left = 12, ;
		Name = "Searchclass1", ;
		TabIndex = 1, ;
		Top = 3, ;
		Width = 452, ;
		cbofields1.Name = "cbofields1", ;
		cbofields1.TabIndex = 1, ;
		cbooperators1.Name = "cbooperators1", ;
		cbooperators1.TabIndex = 2, ;
		txtexpr1.Name = "txtexpr1", ;
		txtexpr1.TabIndex = 3, ;
		cbofields2.Name = "cbofields2", ;
		cbofields2.TabIndex = 4, ;
		cbooperators2.Name = "cbooperators2", ;
		cbooperators2.TabIndex = 5, ;
		txtexpr2.Name = "txtexpr2", ;
		txtexpr2.TabIndex = 6, ;
		optgrpandor.Height = 46, ;
		optgrpandor.Name = "optgrpandor", ;
		optgrpandor.option1.Left = 5, ;
		optgrpandor.option1.Name = "option1", ;
		optgrpandor.option1.Top = 5, ;
		optgrpandor.option1.Value = 1, ;
		optgrpandor.option2.Left = 5, ;
		optgrpandor.option2.Name = "option2", ;
		optgrpandor.option2.Top = 23, ;
		optgrpandor.option2.Value = 0, ;
		optgrpandor.TabIndex = 7, ;
		optgrpandor.Width = 58, ;
		label1.Height = 16, ;
		label1.Left = 12, ;
		label1.Name = "label1", ;
		label1.Top = 7, ;
		label1.Width = 102, ;
		label2.Height = 16, ;
		label2.Left = 158, ;
		label2.Name = "label2", ;
		label2.Top = 7, ;
		label2.Width = 93, ;
		label3.FontBold = .F., ;
		label3.Height = 16, ;
		label3.Left = 262, ;
		label3.Name = "label3", ;
		label3.Top = 7, ;
		label3.Width = 165, ;
		label4.Height = 16, ;
		label4.Left = 12, ;
		label4.Name = "label4", ;
		label4.Top = 99, ;
		label4.Width = 102, ;
		label5.Height = 16, ;
		label5.Left = 161, ;
		label5.Name = "label5", ;
		label5.Top = 99, ;
		label5.Width = 93, ;
		label6.FontBold = .F., ;
		label6.Height = 16, ;
		label6.Left = 262, ;
		label6.Name = "label6", ;
		label6.Top = 99, ;
		label6.Width = 165, ;
		chkCaseSensitive.Height = 15, ;
		chkCaseSensitive.Left = 290, ;
		chkCaseSensitive.Name = "chkCaseSensitive", ;
		chkCaseSensitive.Top = 69, ;
		chkCaseSensitive.Width = 108
		*< END OBJECT: ClassLib="wizstyle.vcx" BaseClass="container" />
	
	PROCEDURE Destroy
		LOCAL cFilterExpr
		IF THIS.ChangedFilter
			IF EMPTY(THIS.SaveFilter)
				SET FILTER TO
			ELSE
				m.cFilterExpr = THIS.SaveFilter
				SET FILTER TO &cFilterExpr
			ENDIF
			IF RECCOUNT() # 0
				GO THIS.SaveRecord
			ENDIF
		ENDIF
		
	ENDPROC

	PROCEDURE Init
		IF !EMPTY(ALIAS())
			THIS.SaveRecord = RECNO()
			THIS.SaveFilter = SET("FILTER")
			THIS.ChangedFilter = .F.
		ENDIF
	ENDPROC

	PROCEDURE Commandgroup1.Click
		#DEFINE NORECSFOUND_LOC		"No se encontró ningún registro que cumpliera su consulta. Pruebe con otra consulta."
		
		DO CASE
		CASE THIS.VALUE = 1		&&SET FILTER condition
			LOCAL cGetExpr,cSavePoint
			SET FILTER TO
			m.cSavePoint = SET("POINT")
			SET POINT TO "."
			m.cGetExpr = THISFORM.SearchClass1.SearchExpr()	
			SET POINT TO &cSavePoint
			IF !EMPTY(m.cGetExpr)
				SET FILTER TO &cGetExpr
				LOCATE
				* Check if no records found
				IF EOF()
					=MESSAGEBOX(NORECSFOUND_LOC)
					THIS.Parent.ChangedFilter = .T.
					RETURN
				ENDIF
				THIS.Parent.ChangedFilter = .F.		&&good query
			ELSE
				LOCATE
			ENDIF
		CASE THIS.VALUE = 2  &&SET FILTER TO all
			SET FILTER TO
			LOCATE
			THIS.Parent.ChangedFilter = .F.			&&good query
		OTHERWISE
		
		ENDCASE
		
		RELEASE THISFORM
	ENDPROC

ENDDEFINE

DEFINE CLASS shadowbase AS container 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="Shape1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Label1" UniqueID="" Timestamp="" />

	*<PropValue>
		BackStyle = 0
		BorderWidth = 0
		Height = 25
		Name = "shadowbase"
		Width = 149
	*</PropValue>

	ADD OBJECT 'Label1' AS label WITH ;
		Alignment = 1, ;
		BackStyle = 0, ;
		Caption = "Etiqueta1", ;
		FontBold = .T., ;
		FontName = "Arial", ;
		FontSize = 8, ;
		Height = 16, ;
		Left = 0, ;
		Name = "Label1", ;
		TabIndex = 0, ;
		Top = 3, ;
		Width = 41
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'Shape1' AS shape WITH ;
		BackColor = 0,255,255, ;
		BackStyle = 0, ;
		BorderStyle = 0, ;
		BorderWidth = 0, ;
		FillColor = 128,128,128, ;
		FillStyle = 0, ;
		Height = 20, ;
		Left = 51, ;
		Name = "Shape1", ;
		Top = 4, ;
		Width = 97
		*< END OBJECT: BaseClass="shape" />

ENDDEFINE

DEFINE CLASS shadowfield AS shadowbase OF "wizstyle.vcx" 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="Text1" UniqueID="" Timestamp="" />

	*<PropValue>
		Height = 25
		Name = "shadowfield"
		Width = 149
		Shape1.Height = 20
		Shape1.Left = 51
		Shape1.Name = "Shape1"
		Shape1.Top = 5
		Shape1.Width = 97
		Label1.Height = 16
		Label1.Left = 0
		Label1.Name = "Label1"
		Label1.Top = 3
		Label1.Width = 41
	*</PropValue>

	ADD OBJECT 'Text1' AS textbox WITH ;
		BackColor = 255,255,255, ;
		DisabledBackColor = 255,255,255, ;
		FontName = "Arial", ;
		FontSize = 8, ;
		Height = 22, ;
		Left = 46, ;
		Name = "Text1", ;
		SelectedBackColor = 128,128,128, ;
		SpecialEffect = 1, ;
		TabIndex = 0, ;
		Top = 0, ;
		Width = 97
		*< END OBJECT: BaseClass="textbox" />

ENDDEFINE

DEFINE CLASS shadowform AS baseform OF "wizstyle.vcx" 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" ProjectClassIcon="stylebmp\form4.bmp" ClassIcon="stylebmp\form4.bmp" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="Layoutsty" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Shape1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Shape2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Label1" UniqueID="" Timestamp="" />

	*<PropValue>
		BackColor = 192,192,192
		ColorSource = 0
		DoCreate = .T.
		Name = "shadowform"
		ScaleMode = 3
		wizbtnpos = 0
		wizcodestyle = .T.
		wizfield = shadowfield
		wizformstretch = .T.
		wizgrid = grid1
		wizlayout = layoutsty
		wizlblcap = proper
		wizlbldefwid = .T.
		wizlblsuffix = (":")
		wizlogic = shadowlogic
		wizmaxcharfld = 45
		wizmemo = shadowmemo
		wizole = shadowole
		wiztitle = Label1
		wizuser = 0
		wizverify = .T.
	*</PropValue>

	ADD OBJECT 'Label1' AS label WITH ;
		AutoSize = .T., ;
		BackStyle = 0, ;
		Caption = "Etiqueta1", ;
		FontBold = .T., ;
		FontSize = 14, ;
		Height = 25, ;
		Left = 26, ;
		Name = "Label1", ;
		Top = 12, ;
		Width = 62
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'Layoutsty' AS layoutsty WITH ;
		Height = 205, ;
		Left = 7, ;
		Name = "Layoutsty", ;
		odimensions = Shape1, ;
		TabIndex = 0, ;
		Top = 54, ;
		Width = 564, ;
		shape1.Height = 205, ;
		shape1.Left = 0, ;
		shape1.Name = "shape1", ;
		shape1.Top = 0, ;
		shape1.Width = 563, ;
		shape2.Height = 13, ;
		shape2.Left = 16, ;
		shape2.Name = "shape2", ;
		shape2.Top = 7, ;
		shape2.Width = 37, ;
		shape3.Height = 13, ;
		shape3.Left = 16, ;
		shape3.Name = "shape3", ;
		shape3.Top = 22, ;
		shape3.Width = 37, ;
		shape4.Height = 13, ;
		shape4.Left = 252, ;
		shape4.Name = "shape4", ;
		shape4.Top = 7, ;
		shape4.Width = 37
		*< END OBJECT: ClassLib="wizstyle.vcx" BaseClass="container" />

	ADD OBJECT 'Shape1' AS shape WITH ;
		Height = 2, ;
		Left = 0, ;
		Name = "Shape1", ;
		Top = 48, ;
		Width = 584
		*< END OBJECT: BaseClass="shape" />

	ADD OBJECT 'Shape2' AS shape WITH ;
		Height = 2, ;
		Left = 2, ;
		Name = "Shape2", ;
		Top = 264, ;
		Width = 584
		*< END OBJECT: BaseClass="shape" />

ENDDEFINE

DEFINE CLASS shadowlogic AS shadowbase OF "wizstyle.vcx" 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="Check1" UniqueID="" Timestamp="" />

	*<PropValue>
		Height = 18
		Name = "shadowlogic"
		Width = 94
		Shape1.Height = 11
		Shape1.Left = 58
		Shape1.Name = "Shape1"
		Shape1.Top = 7
		Shape1.Width = 11
		Label1.Height = 16
		Label1.Left = 0
		Label1.Name = "Label1"
		Label1.Top = 0
		Label1.Width = 41
	*</PropValue>

	ADD OBJECT 'Check1' AS checkbox WITH ;
		BackStyle = 0, ;
		Caption = "", ;
		ColorSource = 0, ;
		DisabledBackColor = 255,255,255, ;
		Height = 15, ;
		Left = 52, ;
		Name = "Check1", ;
		SpecialEffect = 1, ;
		TabIndex = 0, ;
		Top = 0, ;
		Width = 15
		*< END OBJECT: BaseClass="checkbox" />

ENDDEFINE

DEFINE CLASS shadowmemo AS shadowbase OF "wizstyle.vcx" 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="Edit1" UniqueID="" Timestamp="" />

	*<PropValue>
		Height = 55
		Name = "shadowmemo"
		Width = 204
		Shape1.Height = 48
		Shape1.Left = 52
		Shape1.Name = "Shape1"
		Shape1.Top = 7
		Shape1.Width = 152
		Label1.Height = 16
		Label1.Left = 0
		Label1.Name = "Label1"
		Label1.Top = 4
		Label1.Width = 41
	*</PropValue>

	ADD OBJECT 'Edit1' AS editbox WITH ;
		BackColor = 255,255,255, ;
		ColorSource = 0, ;
		FontName = "Arial", ;
		FontSize = 8, ;
		Height = 48, ;
		Left = 48, ;
		Name = "Edit1", ;
		SpecialEffect = 1, ;
		TabIndex = 0, ;
		Top = 2, ;
		Width = 150
		*< END OBJECT: BaseClass="editbox" />

ENDDEFINE

DEFINE CLASS shadowole AS shadowbase OF "wizstyle.vcx" 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="Shape2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Oleboundcontrol1" UniqueID="" Timestamp="" />

	*<PropValue>
		Height = 111
		Name = "shadowole"
		Width = 207
		Shape1.Height = 100
		Shape1.Left = 54
		Shape1.Name = "Shape1"
		Shape1.Top = 7
		Shape1.Width = 150
		Shape1.ZOrderSet = 0
		Label1.Height = 16
		Label1.Left = 0
		Label1.Name = "Label1"
		Label1.Top = 3
		Label1.Width = 41
		Label1.ZOrderSet = 1
	*</PropValue>

	ADD OBJECT 'Oleboundcontrol1' AS oleboundcontrol WITH ;
		Height = 100, ;
		Left = 48, ;
		Name = "Oleboundcontrol1", ;
		TabIndex = 0, ;
		Top = 2, ;
		Width = 151, ;
		ZOrderSet = 3
		*< END OBJECT: BaseClass="oleboundcontrol" />

	ADD OBJECT 'Shape2' AS shape WITH ;
		Height = 100, ;
		Left = 48, ;
		Name = "Shape2", ;
		Top = 2, ;
		Width = 151, ;
		ZOrderSet = 2
		*< END OBJECT: BaseClass="shape" />

ENDDEFINE

DEFINE CLASS standardfield AS textbox 
 	*< CLASSDATA: Baseclass="textbox" Timestamp="" Scale="Pixels" Uniqueid="" ProjectClassIcon="stylebmp\txtbox1.bmp" ClassIcon="stylebmp\txtbox1.bmp" />

	*<PropValue>
		Alignment = 3
		ColorSource = 0
		FontName = "MS Sans Serif"
		FontSize = 8
		Height = 22
		Name = "standardfield"
		SpecialEffect = 1
		Width = 100
	*</PropValue>

ENDDEFINE

DEFINE CLASS standardform AS baseform OF "wizstyle.vcx" 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" ProjectClassIcon="stylebmp\form1.bmp" ClassIcon="stylebmp\form1.bmp" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="Layoutsty" UniqueID="" Timestamp="" />

	*<PropValue>
		BackColor = 255,255,255
		ColorSource = 0
		DoCreate = .T.
		Name = "standardform"
		ScaleMode = 3
		wizbtnpos = 0
		wizcboxlbl = .T.
		wizcodestyle = .T.
		wizfield = standardfield
		wizformstretch = .T.
		wizgrid = grid1
		wizlabel = standardlabel
		wizlayout = layoutsty
		wizlblcap = proper
		wizlbldefwid = .T.
		wizlblspace = 10
		wizlblsuffix = (":")
		wizlogic = standardlogic
		wizmaxcharfld = 45
		wizmemo = standardmemo
		wizole = standardole
		wiztitle = label1
		wizuser = 0
		wizverify = .T.
	*</PropValue>

	ADD OBJECT 'Layoutsty' AS layoutsty WITH ;
		BackColor = 255,255,255, ;
		Height = 253, ;
		Left = 9, ;
		Name = "Layoutsty", ;
		odimensions = Shape1, ;
		TabIndex = 0, ;
		Top = 6, ;
		Width = 561, ;
		shape1.BackColor = 255,255,255, ;
		shape1.Height = 252, ;
		shape1.Left = 0, ;
		shape1.Name = "shape1", ;
		shape1.Top = 0, ;
		shape1.Width = 561, ;
		shape2.Height = 13, ;
		shape2.Left = 16, ;
		shape2.Name = "shape2", ;
		shape2.Top = 7, ;
		shape2.Width = 37, ;
		shape3.Height = 13, ;
		shape3.Left = 16, ;
		shape3.Name = "shape3", ;
		shape3.Top = 22, ;
		shape3.Width = 37, ;
		shape4.Height = 13, ;
		shape4.Left = 56, ;
		shape4.Name = "shape4", ;
		shape4.Top = 7, ;
		shape4.Width = 37
		*< END OBJECT: ClassLib="wizstyle.vcx" BaseClass="container" />

ENDDEFINE

DEFINE CLASS standardlabel AS label 
 	*< CLASSDATA: Baseclass="label" Timestamp="" Scale="Pixels" Uniqueid="" ProjectClassIcon="stylebmp\label1.bmp" ClassIcon="stylebmp\label1.bmp" />

	*<PropValue>
		Alignment = 0
		AutoSize = .F.
		BackStyle = 0
		Caption = "Etiqueta1"
		FontName = "MS Sans Serif"
		FontSize = 8
		Height = 15
		Name = "standardlabel"
		Width = 39
	*</PropValue>

ENDDEFINE

DEFINE CLASS standardlogic AS checkbox 
 	*< CLASSDATA: Baseclass="checkbox" Timestamp="" Scale="Pixels" Uniqueid="" ProjectClassIcon="stylebmp\logic1.bmp" ClassIcon="stylebmp\logic1.bmp" />

	*<PropValue>
		Alignment = 0
		BackStyle = 0
		Caption = "Casilla1"
		FontName = "MS Sans Serif"
		FontSize = 9
		Height = 16
		Name = "standardlogic"
		SpecialEffect = 1
		Width = 68
	*</PropValue>

ENDDEFINE

DEFINE CLASS standardmemo AS editbox 
 	*< CLASSDATA: Baseclass="editbox" Timestamp="" Scale="Pixels" Uniqueid="" ProjectClassIcon="stylebmp\memo1.bmp" ClassIcon="stylebmp\memo1.bmp" />

	*<PropValue>
		ColorSource = 0
		DisabledBackColor = 255,255,255
		FontName = "MS Sans Serif"
		FontSize = 8
		Height = 43
		Name = "standardmemo"
		SpecialEffect = 1
		Width = 150
	*</PropValue>

ENDDEFINE

DEFINE CLASS standardole AS oleboundcontrol 
 	*< CLASSDATA: Baseclass="oleboundcontrol" Timestamp="" Scale="Pixels" Uniqueid="" ProjectClassIcon="stylebmp\ole1.bmp" ClassIcon="stylebmp\ole1.bmp" />

	*<PropValue>
		Height = 100
		Name = "standardole"
		Width = 150
	*</PropValue>

ENDDEFINE

DEFINE CLASS txtbtns AS container 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" ProjectClassIcon="stylebmp\textbttn.bmp" ClassIcon="stylebmp\textbttn.bmp" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="cmdPrev" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdNext" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdTop" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdEnd" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdFind" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdPrint" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdExit" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdAdd" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdDelete" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdEdit" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: buttonrefresh		&& Habilita y deshabilita botones.
		*m: getgridref		&& Encuentra una referencia al objeto Grid, si existe alguna.
		*m: initvars		&& Guarda y establece ciertas variables de entorno.
		*m: navrefresh		&& Actualiza los botones de desplazamiento por registros.
		*m: setallprop		&& Activa o desactiva la edición de objetos enlazados a datos de un formulario.
		*m: setcaption		&& Cambia el título o la imagen de botones cuando el modo de edición está activado o desactivado.
		*m: updaterows		&& Trata operaciones de agregar, modificar y eliminar registros de tablas.
		*p: addmode		&& Si el formulario está en modo agregar cuando se agrega un nuevo registro (se establece internamente).
		*p: editbackcolor		&& Guarda la propiedad EditBackColor para los objetos editbox (se establece internamente).
		*p: editdisbackcolor		&& Guarda la propiedad DisabledBackColor para los objetos editbox (se establece internamente).
		*p: editdisforecolor		&& Guarda la propiedad DisabledForeColor para los objetos editbox (se establece internamente).
		*p: editforecolor		&& Guarda la propiedad EditForeColor para los objetos editbox (se establece internamente).
		*p: editmode		&& Si el formulario está en modo de edición (se establece internamente).
		*p: endfile		&& Si el puntero de registro está al final de la tabla (se establece internamente).
		*p: gridalias		&& Alias de la tabla usado en el objeto Grid (se establece internamente).
		*p: gridref		&& Referencia de objeto al objeto Grid (se establece internamente).
		*p: hasgeneral		&& Si el formulario tiene un objeto oleboundcontrol de campo general (se establece internamente).
		*p: hasmemo		&& Si el formulario tiene un objeto editbox de campo memo (se establece internamente).
		*p: nworkarea		&& Guarda el área de trabajo anterior (se establece internamente).
		*p: odatarelation		&& Referencia de objeto al entorno de datos (se establece internamente).
		*p: oldalias		&& Guarda el alias al modificar para restaurar con formularios uno a varios (se establece internamente).
		*p: oldbuffering		&& Guarda el estado de almacenamiento de tablas en búfer (se establece internamente).
		*p: oldmultilocks		&& Guarda SET MULTILOCKS (se establece internamente).
		*p: oldrec		&& Guarda el número de registro (se establece internamente).
		*p: oldrefresh		&& Guarda SET REFRESH (se establece internamente).
		*p: oldreprocess		&& Guarda SET REPROCESS (se establece internamente).
		*p: oldsetdelete		&& Guarda SET DELETED (se establece internamente).
		*p: oldsetfields		&& Guarda SET FIELDS (se establece internamente).
		*p: oldtalk		&& Guarda SET TALK (se establece internamente).
		*p: parentkey		&& Expresión clave de tabla primaria usada en el formulario uno a varios (se establece internamente). La expresión se obtiene de la propiedad Comment del formulario.
		*p: previewinit		&& Para su uso con el botón Vista preliminar del asistente (se establece internamente).
		*p: previewmode		&& Si el formulario está en modo de vista preliminar para utilizarse con el botón Vista preliminar del asistente (se establece internamente).
		*p: topfile		&& Si el puntero de registro está al principio de la tabla (se establece internamente).
		*p: usedataenv		&& Si el formulario tiene adjunto un objeto de entorno de datos (se establece internamente).
		*p: usercontrolmode		&& Este modo permitirá al usuario controles adicionales como combobox, listbox y spinner para asumir el comportamiento de EditMode.
		*p: viewkey		&& Expresión clave de tabla secundaria usada en el objeto Grid (se establece internamente). La expresión se obtiene de la propiedad Tag del formulario.
		*p: viewtype		&& Tipo de origen de datos para el objeto Grid (se establece internamente).
	*</DefinedPropArrayMethod>

	*<PropValue>
		BackStyle = 0
		BorderWidth = 0
		editmode = 0
		endfile = 0
		Height = 66
		Name = "txtbtns"
		nworkarea = 0
		oldrec = 0
		oldrefresh = 0
		oldreprocess = 0
		previewinit = .T.
		previewmode = .F.
		TabIndex = 1
		topfile = 0
		usedataenv = .T.
		viewkey = ("")
		Visible = .T.
		Width = 575
	*</PropValue>

	ADD OBJECT 'cmdAdd' AS commandbutton WITH ;
		Caption = "Ag\<regar", ;
		Enabled = .T., ;
		FontName = "MS Sans Serif", ;
		FontSize = 8, ;
		Height = 24, ;
		Left = 324, ;
		Name = "cmdAdd", ;
		Statusbartext = "Agregar nuevo registro/Guardar modificaciones", ;
		TabIndex = 7, ;
		ToolTipText = "", ;
		Top = 25, ;
		Width = 60
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdDelete' AS commandbutton WITH ;
		Caption = "\<Eliminar", ;
		Enabled = .T., ;
		FontName = "MS Sans Serif", ;
		FontSize = 8, ;
		Height = 24, ;
		Left = 444, ;
		Name = "cmdDelete", ;
		Statusbartext = "Eliminar un registro existente", ;
		TabIndex = 9, ;
		ToolTipText = "", ;
		Top = 25, ;
		Width = 60
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdEdit' AS commandbutton WITH ;
		Caption = "\<Modificar", ;
		Enabled = .T., ;
		FontName = "MS Sans Serif", ;
		FontSize = 8, ;
		Height = 24, ;
		Left = 384, ;
		Name = "cmdEdit", ;
		Statusbartext = "Modificar registro existente/Revertir modificaciones", ;
		TabIndex = 8, ;
		ToolTipText = "", ;
		Top = 25, ;
		Width = 60
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdEnd' AS commandbutton WITH ;
		Caption = "Ú\<ltimo", ;
		FontName = "MS Sans Serif", ;
		FontSize = 8, ;
		Height = 24, ;
		Left = 66, ;
		Name = "cmdEnd", ;
		Statusbartext = "Ir a la parte inferior de la tabla", ;
		TabIndex = 4, ;
		ToolTipText = "", ;
		Top = 37, ;
		Width = 62
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdExit' AS commandbutton WITH ;
		Caption = "\<Salir", ;
		Enabled = .T., ;
		FontName = "MS Sans Serif", ;
		FontSize = 8, ;
		Height = 24, ;
		Left = 511, ;
		Name = "cmdExit", ;
		Statusbartext = "Salir del formulario de entrada", ;
		TabIndex = 10, ;
		ToolTipText = "", ;
		Top = 25, ;
		Width = 60
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdFind' AS commandbutton WITH ;
		Caption = "\<Buscar", ;
		Enabled = .T., ;
		FontName = "MS Sans Serif", ;
		FontSize = 8, ;
		Height = 24, ;
		Left = 197, ;
		Name = "cmdFind", ;
		Statusbartext = "Buscar registros", ;
		TabIndex = 5, ;
		ToolTipText = "", ;
		Top = 25, ;
		Width = 60
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdNext' AS commandbutton WITH ;
		Caption = "Siguie\<nte", ;
		FontName = "MS Sans Serif", ;
		FontSize = 8, ;
		Height = 24, ;
		Left = 128, ;
		Name = "cmdNext", ;
		Statusbartext = "Saltar al registro siguiente", ;
		TabIndex = 3, ;
		ToolTipText = "", ;
		Top = 25, ;
		Width = 62
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdPrev' AS commandbutton WITH ;
		Caption = "\<Anterior", ;
		FontName = "MS Sans Serif", ;
		FontSize = 8, ;
		Height = 24, ;
		Left = 4, ;
		Name = "cmdPrev", ;
		Statusbartext = "Saltar al registro anterior", ;
		TabIndex = 2, ;
		ToolTipText = "", ;
		Top = 25, ;
		Width = 62
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdPrint' AS commandbutton WITH ;
		Caption = "\<Imprimir", ;
		Enabled = .T., ;
		FontName = "MS Sans Serif", ;
		FontSize = 8, ;
		Height = 24, ;
		Left = 257, ;
		Name = "cmdPrint", ;
		Statusbartext = "Imprimir a un informe", ;
		TabIndex = 6, ;
		ToolTipText = "", ;
		Top = 25, ;
		Width = 60
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdTop' AS commandbutton WITH ;
		Caption = "\<Primero", ;
		FontName = "MS Sans Serif", ;
		FontSize = 8, ;
		Height = 24, ;
		Left = 66, ;
		Name = "cmdTop", ;
		Statusbartext = "Ir a la parte superior de la tabla", ;
		TabIndex = 1, ;
		ToolTipText = "", ;
		Top = 13, ;
		Width = 62
		*< END OBJECT: BaseClass="commandbutton" />
	
	PROCEDURE buttonrefresh		&& Habilita y deshabilita botones.
		* This is a generic routine which refreshes the buttons
		* for appropriate table environments.
		IF SELECT()# THIS.nWorkArea
			SELECT (THIS.nWorkArea)
		ENDIF
		
		THIS.SetAllProp()
		THIS.cmdFind.Enabled = !THIS.EditMode
		THIS.cmdPrint.Enabled =  !THIS.EditMode
		THIS.cmdExit.Enabled =  !THIS.EditMode
		THIS.cmdDelete.Enabled =  !THIS.EditMode AND !ISREADONLY()
		THIS.SetCaption()
	ENDPROC

	PROCEDURE Destroy
		* Restore various settings
		LOCAL nTablesUsed,aTablesUsed,i,nDECursors,aDECursors,cDataEnvRef 
		DIMENSION aTablesUsed[1]
		
		IF TYPE('THIS.Parent') # "O"
			RETURN
		ENDIF
		
		IF TYPE("THIS.oldTalk") = "C" AND THIS.oldTalk="ON"
			SET TALK ON
		ENDIF
		
		* OLE Servers can still send data back to General fields 
		* even though they are not in Edit Mode. We need to reset 
		* buffering to 1 so the buffer is not updated by the OLE Server.
		* Also, folks might exit out while editing.
		IF THIS.UseDataEnv
			DIMENSION aDECursors[1]
			DO CASE
			CASE TYPE("THISFORM.DataEnvironment") = "O"
				nDECursors = AMEMBERS(aDECursors,THISFORM.DataEnvironment,2)
				cDataEnvRef = "THISFORM.DataEnvironment"
			CASE TYPE("THISFORMSET.DataEnvironment") = "O"
				nDECursors = AMEMBERS(aDECursors,THISFORMSET.DataEnvironment,2)
				cDataEnvRef = "THISFORMSET.DataEnvironment"
			ENDCASE
			FOR i = 1 TO m.nDECursors
				WITH EVAL(m.cDataEnvRef + "." + aDECursors[m.i])
					IF USED(.ALIAS) AND ATC("CURSOR",.BaseClass)#0 AND ;
					  CursorGetProp("sourcetype",.ALIAS)=3 AND ;
					  CursorGetProp("buffering",.ALIAS)>1
						=TableRevert(.T.,.ALIAS)
						=CursorSetProp("buffering",1,.ALIAS)	&&optimistic table buffering
					ENDIF
				ENDWITH
			ENDFOR
		ENDIF
		
		* Skip if using preview mode
		IF THIS.PreviewMode
			RETURN
		ENDIF
		
		IF THIS.oldSetDelete = "OFF"
			SET DELETED OFF
		ENDIF
		SET REPROCESS TO THIS.oldReprocess
		SET MESSAGE TO
		SELECT (THIS.nWorkArea)
		
		IF THIS.UseDataEnv
			RETURN
		ENDIF
		
		* The following code is here to support
		* forms not using a DataEnvironment.
		m.nTablesUsed = AUSED(aTablesUsed)
		FOR i = 1 TO m.nTablesUsed
			IF USED(aTablesUsed[m.i,1]) AND ATC(".TMP",DBF(aTablesUsed[m.i,1]))=0	&&skip for views
				=CursorSetProp("buffering",THIS.oldBuffering,aTablesUsed[m.i,1])	&&optimistic table buffering
			ENDIF
		ENDFOR
		
		IF THIS.oldMultiLocks = "OFF"
			SET MULTILOCKS OFF
		ENDIF
		
		IF THIS.oldSetFields = "ON"
			SET FIELDS ON
		ENDIF
		
		SET REFRESH TO THIS.oldRefresh
		
	ENDPROC

	PROCEDURE Error
		Parameters nError, cMethod, nLine
		LOCAL aFoxErr,nTotErr
		DIMENSION aFoxErr[1]
		nTotErr = AERROR(aFoxErr)
		
		DO CASE
		CASE INLIST(m.nError,1733,1734)  &&property not found -- traps SETALL()
			RETURN
		CASE m.nError=1938  &&no parent
			RETURN
		CASE nToterr>0 AND aFoxErr[1,1] = 1420
			* Corrupt Ole object in General field.
			=MESSAGEBOX(aFoxErr[1,2])
			RETURN
		CASE nToterr>0 AND aFoxErr[1,1] = 1884
			* Uniqueness ID error
			=MESSAGEBOX(MESSAGE()+CHR(13))
			RETURN
		ENDCASE
		
		**** Error Dialog ******
		=MESSAGEBOX(MESSAGE(1)+CHR(13)+;
		"Error: "+STR(nError)+CHR(13)+;
		MESSAGE()+CHR(13)+;
		"Method: "+cMethod+CHR(13)+;
		"Line: "+STR(nLine))
		
		RETURN TO MASTER
		
	ENDPROC

	PROCEDURE getgridref		&& Encuentra una referencia al objeto Grid, si existe alguna.
		* Check if we have a grid
		LOCAL aMems,nTotMem,i
		THIS.GridRef = ""
		IF TYPE("THISFORM") = "O"
			DIMENSION aMems[1]
			nTotMem = AMEMBERS(aMems,THISFORM,2)
			WITH THISFORM
				FOR i = 1 TO m.nTotMem 
					IF UPPER(EVAL("."+aMems[m.i]+".BaseClass")) = "GRID"
						THIS.GridRef = aMems[m.i]
						WITH EVAL("."+THIS.GridRef)
							* Check if we have a view and get Tag property
							THIS.ViewType = CURSORGETPROP('sourcetype',.RecordSource)
							THIS.GridAlias = .RecordSource
							IF THIS.ViewType # 3
								THIS.ViewKey = .Tag
								THIS.ParentKey = .Comment
							ENDIF
						ENDWITH				
						EXIT
					ENDIF
				ENDFOR
			ENDWITH
		ENDIF
		
	ENDPROC

	PROCEDURE Init
		#DEFINE C_WIZSTYLE			"WIZSTYLE.VCX"
		#DEFINE C_WIZDIR 			"WIZARDS\"
		#DEFINE C_PROMPT1_LOC		"Buscar: "
		#DEFINE E_NOSTYLE_LOC		"No se pudo encontrar la biblioteca de clase (WIZSTYLE.VCX) necesaria para este formulario. "+"Búsquela."
		
		
		LOCAL cGridRef,cWizHomePath,separator,cWizStyFile
		
		
		IF TYPE('THIS.Parent') # "O"
			RETURN
		ENDIF
		
		IF SET("TALK") = "ON"
			SET TALK OFF
			THIS.oldTalk = "ON"
		ELSE
			THIS.oldTalk = "OFF"
		ENDIF
		
		
		IF ATC(C_WIZSTYLE,SET("CLASSLIB")) = 0
			
			* Returns just the pathname
			cWizHomePath = _WIZARD
			IF '\' $ cWizHomePath
			   cWizHomePath = SUBSTR(m.cWizHomePath,1,RAT('\',m.cWizHomePath))
			   IF RIGHT(m.cWizHomePath,1) = '\' AND LEN(m.cWizHomePath) > 1 ;
			            AND SUBSTR(m.cWizHomePath,LEN(m.cWizHomePath)-1,1) <> ':'
			         cWizHomePath = SUBSTR(m.cWizHomePath,1,LEN(m.cWizHomePath)-1)
			   ENDIF
			ELSE
			   cWizHomePath = ''
			ENDIF
		
			* Add a backslash unless there is one already there.
			separator = IIF(_MAC,":","\")
			IF !(RIGHT(m.cWizHomePath,1) $ '\:') AND !EMPTY(m.cWizHomePath)
			   m.cWizHomePath= m.cWizHomePath+ m.separator
			ENDIF
		
			DO CASE
			CASE FILE(C_WIZSTYLE)
				cWizFile = C_WIZSTYLE
			CASE FILE(m.cWizHomePath+C_WIZSTYLE)
				cWizFile = m.cWizHomePath+C_WIZSTYLE
			CASE FILE(m.cWizHomePath+C_WIZDIR+C_WIZSTYLE)
				cWizFile = m.cWizHomePath+C_WIZDIR+C_WIZSTYLE	
			CASE FILE(HOME()+C_WIZSTYLE)
				cWizFile = HOME()+C_WIZSTYLE
			CASE FILE(HOME()+C_WIZDIR+C_WIZSTYLE)
				cWizFile = HOME()+C_WIZDIR+C_WIZSTYLE
			OTHERWISE
				=MESSAGEBOX(E_NOSTYLE_LOC)
				cWizFile = GETFILE("VCX",C_PROMPT1_LOC+C_WIZSTYLE)
			ENDCASE
			
			IF ATC(C_WIZSTYLE,m.cWizFile)#0
				SET CLASS TO (m.cWizFile) ADDITIVE
			ELSE
				* Failed to get WIZSTYLE.VCX file
				RETURN .F.
			ENDIF
			
		ENDIF
		
		THIS.InitVars()
		THIS.ButtonRefresh()
		THIS.NavRefresh()
		cGridRef=THIS.GridRef
		IF !EMPTY(m.cGridRef)
			* Change this if you desire to have the grid initially selected.
			* THISFORM.&cGridRef..SetFocus()
		ENDIF
	ENDPROC

	PROCEDURE initvars		&& Guarda y establece ciertas variables de entorno.
								
		#DEFINE C_NOUPDATEVIEW_LOC	"Puede que las modificaciones en una o más de las vistas no sean permanentes."+"Para solucionarlo, asegúrese de que la casilla de verificación Enviar actualizaciones SQL de la vista está activada en el Diseñador de vistas."
		
		#DEFINE C_READONLY_LOC		"La tabla es de sólo lectura. No podrá modificarla."
		
		LOCAL aTablesUsed,nTablesUsed,i,aMems,nTotMem,cWizFile,lShowedMess,cDataEnvRef
		DIMENSION aTablesUsed[1]
		DIMENSION aMems[1]
		
		* This routine sets the member variables
		THIS.ViewKey = ""
		THIS.ParentKey = ""
		THIS.ViewType = 3
		THIS.GridAlias = ""
		THIS.TopFile = .F.
		THIS.EndFile = .F.
		THIS.AddMode = .F.
		
		THIS.nWorkArea = SELECT()
		THIS.oldSetDelete = SET("DELETED")
		SET DELETED ON
		THIS.oldReprocess = SET("REPROCESS")
		SET REPROCESS TO 0
		
		* These properties should not be used. They are reserved for use by
		* the Preview button of the Form Wizards.
		THIS.PreviewMode = IIF(TYPE("THIS.PreviewMode")#"L",.F.,THIS.PreviewMode)
		THIS.PreviewInit = IIF(TYPE("THIS.PreviewInit")#"L",.T.,THIS.PreviewInit)
		
		* Check for data environment
		DO CASE
		CASE TYPE("THISFORM.DataEnvironment") = "O"
			THIS.UseDataEnv = .T.
			nTotMem = AMEMBERS(aMems,THISFORM.DataEnvironment,2)
			cDataEnvRef = "THISFORM.DataEnvironment"
		CASE TYPE("THISFORMSET.DataEnvironment") = "O"
			THIS.UseDataEnv = .T.
			nTotMem = AMEMBERS(aMems,THISFORMSET.DataEnvironment,2)
			cDataEnvRef = "THISFORMSET.DataEnvironment"
			* let's also set the 
			IF TYPE("THISFORM")="O" AND !THISFORM.VISIBLE 
				THISFORM.VISIBLE = .T.
			ENDIF
		OTHERWISE
			THIS.UseDataEnv = .F.
		ENDCASE
		
		IF THIS.UseDataEnv
			WITH EVAL(m.cDataEnvRef)
				* Check for relation
				FOR i = 1 TO m.nTotMem
					IF UPPER(EVAL("."+aMems[m.i]+".BaseClass")) = "RELATION"
						THIS.oDataRelation = m.cDataEnvRef+"."+aMems[m.i]
						EXIT
					ENDIF
				ENDFOR
				
				* Check for Views
				FOR i = 1 TO m.nTotMem
					IF UPPER(EVAL("."+aMems[m.i]+".BaseClass")) = "CURSOR"
						WITH EVAL("."+aMems[m.i])
							IF CURSORGETPROP("SourceType",.Alias)#3 AND ;
								!CURSORGETPROP("offline",.Alias)
								* Check if we need to requery for deleted records.
								* -- Note: Parameterized views are not requeried so all
								* records will be brought over. To remedy this situation
								* you can place a SET DELETED ON command in the
								* BeforeOpenTables event of the DataEnvironment.
								IF THIS.oldSetDelete = "OFF" AND ATC("?",CURSORGETPROP("SQL",.Alias))=0
									=REQUERY(.Alias)
								ENDIF
								* Check if updates are made
								IF !CURSORGETPROP("SendUpdates",.Alias) AND !m.lShowedMess
									=MESSAGEBOX(C_NOUPDATEVIEW_LOC)
									lShowedMess = .T.
								ENDIF
							ENDIF
						ENDWITH
					ENDIF
				ENDFOR
			ENDWITH
		ENDIF
		
		THIS.EditMode = IIF(TYPE("THIS.EditMode")#"L",.F.,THIS.EditMode)
		
		IF ISREADONLY()
			WAIT WINDOW C_READONLY_LOC TIMEOUT 2
			THIS.EditMode = .F.
		ENDIF
		
		* Disable appropriate buttons
		THIS.cmdAdd.Enabled = !ISREADONLY()
		THIS.cmdEdit.Enabled = !ISREADONLY()
		THIS.cmdDelete.Enabled = !ISREADONLY()
		
		IF THIS.PreviewMode
			RETURN
		ENDIF
		
		THIS.GetGridRef()
		
		IF THIS.UseDataEnv
			RETURN
		ENDIF
		
		* The following code is here to support forms not using a DataEnvironment.
		THIS.oldSetFields = SET("FIELDS")
		SET FIELDS OFF
		THIS.oldMultiLocks = SET("MULTILOCKS")
		SET MULTILOCKS ON
		THIS.oldRefresh = SET("REFRESH")
		SET REFRESH TO 5
		IF !EMPTY(ALIAS())
			THIS.oldBuffering=CursorGetProp("buffering")
			m.nTablesUsed = AUSED(aTablesUsed)
			FOR i = 1 TO m.nTablesUsed
				IF CursorGetProp('sourcetype',aTablesUsed[m.i,1])#3	&&skip for views
					=CursorSetProp("buffering",5,aTablesUsed[m.i,1])	&&optimistic table buffering
				ENDIF
			ENDFOR
		ENDIF
		GO TOP
		
	ENDPROC

	PROCEDURE navrefresh		&& Actualiza los botones de desplazamiento por registros.
		**** Navigational Button Handling ****
		LOCAL OldLockScreen,KeyValue,cFiltExpr
		m.OldLockScreen = THISFORM.LockScreen
		THISFORM.LockScreen = .T.
		
		IF SELECT()#THIS.nWorkArea
			SELECT (THIS.nWorkArea)
		ENDIF
		
		IF !THIS.EditMode
		
			* Check for bottom of file
			THIS.EndFile = EOF() OR THIS.EndFile
		
			* Test to see we are on last record
			IF !THIS.EndFile
				SKIP
				THIS.EndFile = EOF()
				SKIP -1
			ELSE
				GO BOTTOM
			ENDIF
		
			* Check for top of file
			THIS.TopFile = BOF() OR EOF() OR THIS.TopFile
		
			* Test to see if we are on first record
			IF !THIS.TopFile
				SKIP -1
				THIS.TopFile = BOF()
				IF !THIS.TopFile
					SKIP
				ENDIF	
			ENDIF
		
			IF THIS.TopFile
				GO TOP
			ENDIF
		
		ENDIF
		
		THIS.cmdTop.Enabled = !THIS.TopFile AND !THIS.EditMode
		THIS.cmdPrev.Enabled = !THIS.TopFile AND !THIS.EditMode
		THIS.cmdNext.Enabled = !THIS.EndFile AND !THIS.EditMode
		THIS.cmdEnd.Enabled = !THIS.EndFile AND !THIS.EditMode
		
		* Check if no records in query set
		DO CASE
		CASE THIS.PreviewMode OR ISREADONLY()
			* Nothing
		CASE THIS.EditMode AND CURSORGETPROP("BUFFERING")=1
			THIS.cmdEdit.Enabled = .F.
		CASE THIS.EditMode
			THIS.cmdEdit.Enabled = .T.
		CASE RECCOUNT()=0 OR BOF() OR EOF()
			THIS.cmdEdit.Enabled = .F.
			THIS.cmdDelete.Enabled = .F.
		CASE !THIS.cmdEdit.Enabled
			THIS.cmdEdit.Enabled = .T.
			THIS.cmdDelete.Enabled = .T.
		ENDCASE
		
		
		* Update Grid for Views
		IF !THIS.EditMode AND !EMPTY(THIS.ViewKey)
			KeyValue = EVAL(THIS.ParentKey)
			DO CASE
			CASE TYPE(THIS.ParentKey) = "C"
				cFiltExpr = THIS.ViewKey + "=" + "["+m.KeyValue+"]"
			CASE TYPE(THIS.ParentKey) = "L"
				cFiltExpr = THIS.ViewKey
			CASE TYPE(THIS.ParentKey) = "D"
				cFiltExpr = THIS.ViewKey + "=" + "{"+DTOC(m.KeyValue)+"}"	
			CASE TYPE(THIS.ParentKey) = "T"
				cFiltExpr = THIS.ViewKey + "=" + "{"+TTOC(m.KeyValue)+"}"	
			OTHERWISE	
				* Numeric
				cFiltExpr = THIS.ViewKey + "=" + ALLTRIM(STR(m.KeyValue,20,18))
			ENDCASE
				
			SELECT (THIS.GridAlias)
			DO CASE
			CASE .F. &&parameterized query
				* set parameter here
				* =requery()
			CASE THIS.ViewType = 1	&&local views
				SET FILTER TO &cFiltExpr
			CASE THIS.ViewType = 2	&&remote views
			
			ENDCASE
			SELECT (THIS.nWorkArea)
		ENDIF
		
		THISFORM.Refresh()
		THISFORM.LockScreen = m.OldLockScreen
		
	ENDPROC

	PROCEDURE Refresh
		**** Special Preview Mode Handling ****
		IF THIS.PreviewMode AND THIS.PreviewInit
			THIS.PreviewInit = .F.
			THIS.cmdAdd.Enabled = .F.
			THIS.cmdEdit.Enabled = .F.
			THIS.cmdDelete.Enabled = .F.
			THIS.cmdFind.Enabled = .F.
			THIS.cmdPrint.Enabled = .F.
			THIS.cmdExit.Enabled = .F.
			THIS.nWorkArea = SELECT()
			THIS.GetGridRef()
			THIS.SetAllProp()
			THIS.NavRefresh()
		ENDIF
		
	ENDPROC

	PROCEDURE setallprop		&& Activa o desactiva la edición de objetos enlazados a datos de un formulario.
		LPARAMETER oContainer
		
		* Checks for General fields
		LOCAL i,oControlParent,nCtrlCount
		
		IF PARAMETERS() = 0
			m.oControlParent = THISFORM
		ELSE
			m.oControlParent = m.oContainer
		ENDIF
		
		DO CASE 
		CASE ATC("Pageframe",m.oControlParent.BaseClass)#0
			nCtrlCount = oControlParent.PageCount
		CASE ATC(m.oControlParent.BaseClass,"Optiongroup,Commandgroup")#0
			nCtrlCount = oControlParent.ButtonCount
		OTHERWISE
			nCtrlCount = oControlParent.ControlCount
		ENDCASE
		
		FOR i = 1 TO m.nCtrlCount 
			DO CASE
			CASE ATC("Pageframe",m.oControlParent.BaseClass)#0
				THIS.SetAllProp(m.oControlParent.Pages[m.i])
				
			CASE ATC(m.oControlParent.BaseClass,"Optiongroup,Commandgroup")#0 AND ;
				THIS.UserControlMode
				m.oControlParent.Buttons[m.i].Enabled = THIS.EditMode
		
			CASE ATC(m.oControlParent.Controls[m.i].BaseClass,"Optiongroup,Commandgroup")#0 ;
				AND THIS.UserControlMode
				THIS.SetAllProp(m.oControlParent.Controls[m.i])
		
			CASE ATC("Container",m.oControlParent.Controls[m.i].BaseClass) # 0 OR; 
				ATC("Page",m.oControlParent.Controls[m.i].BaseClass) # 0
				THIS.SetAllProp(m.oControlParent.Controls[m.i])
		
			CASE ATC(m.oControlParent.Controls[m.i].BaseClass,"ListBox,ComboBox,Spinner") # 0 AND;
				THIS.UserControlMode
				m.oControlParent.Controls[m.i].Enabled = THIS.EditMode
		
			CASE ATC(m.oControlParent.Controls[m.i].BaseClass,"CheckBox,TextBox,OleBoundControl") # 0
				m.oControlParent.Controls[m.i].Enabled = THIS.EditMode
		
			CASE ATC(m.oControlParent.Controls[m.i].BaseClass,"EditBox") # 0
				m.oControlParent.Controls[m.i].ReadOnly = !THIS.EditMode
				IF !THIS.HasMemo
					WITH m.oControlParent.Controls[m.i]
						THIS.EditForeColor = .ForeColor
						THIS.EditDisForeColor =  .DisabledForeColor
						THIS.EditBackColor = .BackColor
						THIS.EditDisBackColor =  .DisabledBackColor
						THIS.HasMemo = .T.
					ENDWITH
				ENDIF
				m.oControlParent.Controls[m.i].ForeColor = IIF(THIS.EditMode,THIS.EditForeColor,THIS.EditDisForeColor)
				m.oControlParent.Controls[m.i].BackColor = IIF(THIS.EditMode,THIS.EditBackColor,THIS.EditDisBackColor)
		
			CASE ATC(m.oControlParent.Controls[m.i].BaseClass,"Grid") # 0
				m.oControlParent.Controls[m.i].ReadOnly = !THIS.EditMode
				m.oControlParent.Controls[m.i].DeleteMark = THIS.EditMode
				
			ENDCASE
		ENDFOR
		
		
	ENDPROC

	PROCEDURE setcaption		&& Cambia el título o la imagen de botones cuando el modo de edición está activado o desactivado.
		#DEFINE ADD_CAPTION_LOC		"Ag\<regar"
		#DEFINE EDIT_CAPTION_LOC	"\<Modificar"
		#DEFINE REV_CAPTION_LOC		"Re\<vertir"
		#DEFINE SAVE_CAPTION_LOC	"\<Guardar"
		
		IF THIS.EditMode
			THIS.cmdAdd.Caption = SAVE_CAPTION_LOC
			THIS.cmdEdit.Caption = REV_CAPTION_LOC
		ELSE
			THIS.cmdAdd.Caption = ADD_CAPTION_LOC
			THIS.cmdEdit.Caption = EDIT_CAPTION_LOC
		ENDIF
		
	ENDPROC

	PROCEDURE updaterows		&& Trata operaciones de agregar, modificar y eliminar registros de tablas.
		#DEFINE	E_FAIL_LOC			"Fallo al actualizar la tabla:"
		#DEFINE	E_TRIGGERFAIL_LOC	"Falló el desencadenante."
		#DEFINE	E_FIELDNULL_LOC		"El campo no acepta NULL"
		#DEFINE	E_FIELDRULE_LOC		"Se ha infringido la regla del campo"
		#DEFINE	E_RECORDLOCK_LOC	"Hay otra persona usando ese registro"
		#DEFINE	E_ROWRULE_LOC		"Se ha infringido la regla de la fila"
		#DEFINE	E_UNIQUEINDEX_LOC	"Infracción de índice único"
		#DEFINE	E_DIRTYREC_LOC		"Otra persona ha cambiado los datos. ¿Desea sobrescribir los cambios con sus correcciones?"
		#DEFINE	E_NOFORCE_LOC		"Imposible forzar actualizaciones de tablas."
		#DEFINE E_PROMPT_LOC	 	"Error: "
		#DEFINE MSGBOX_YES			6
		
		LOCAL aErrors,cErrorMessage,aTablesUsed,nTablesUsed,nTotErr 
		LOCAL nFld,i,nOldArea,lSuccess,lInDBC,lOverwrite,lHadMessage
		
		DIMENSION aTablesUsed[1]
		DIMENSION aErrors[1]
		m.cErrorMessage=""
		m.lSuccess = .T.
		m.nOldArea = SELECT()
		m.nTablesUsed = AUSED(aTablesUsed)
		
		* Can wrap everything in transaction if using strictly DBCs
		
		FOR i = 1 TO m.nTablesUsed
		
			SELECT (aTablesUsed[m.i,1])
		
			m.lInDBC = !EMPTY(CURSORGETPROP("Database"))
			m.cErrorMessage = ""
			m.lOverwrite = .F.
			m.lHadMessage = .F.
		
			DO CASE
			CASE CURSORGETPROP("Buffering") = 1
				* Skip if buffering not on
				LOOP
			CASE GetFldState(0) = 2			&&deleted record
				* Only delete current record and force it
				m.lSuccess = TableUpdate(.F.,.T.)
				IF m.lSuccess				&&successful update
					LOOP
				ENDIF
			CASE !m.lInDBC AND (ATC("2",GetFldState(-1))#0 OR;
				 ATC("3",GetFldState(-1))#0)	
				* Field was edited - in Free Table
				* Since free tables are not supported by transactions,
				* we must process record by record
				m.nModRecord = GetNextMod(0)
				DO WHILE m.nModRecord # 0	&&loop locks all records
					GO m.nModRecord
					m.lSuccess = RLOCK()	&&try to lock record
					IF !m.lSuccess			&&failed to lock record
						m.cErrorMessage = E_RECORDLOCK_LOC
						UNLOCK ALL
						EXIT
					ENDIF
					IF !m.lHadMessage	&&so we don't repeat alert
						* See if record(s) modified by another user
						FOR m.nFld = 1 TO FCOUNT()
							IF TYPE(FIELD(m.nFld)) = "G"	&&skip for General fields
								LOOP					
							ENDIF
							IF OLDVAL(FIELD(m.nFld)) # CURVAL(FIELD(m.nFld))
								m.lHadMessage = .T.
								IF MESSAGEBOX(E_DIRTYREC_LOC,4+48) = MSGBOX_YES
									m.lOverwrite = .T.
								ELSE
									m.lSuccess = .F.
									UNLOCK ALL
									EXIT
								ENDIF
							ENDIF
						ENDFOR
					ENDIF
					m.nModRecord = GetNextMod(m.nModRecord)
				ENDDO
				IF m.lSuccess 	&&was able to lock all records
					m.lSuccess = TableUpdate(.T.,m.lOverwrite)
					IF m.lSuccess &&was able to update all records
						LOOP
					ENDIF	
					UNLOCK ALL
				ENDIF
			CASE m.lInDBC
				BEGIN TRANSACTION
				* Try to update all records in selected table
				m.lSuccess = TableUpdate(.T.,.F.)	&&successful update
				IF m.lSuccess
					END TRANSACTION
					LOOP
				ENDIF
				ROLLBACK
			ENDCASE
		
			* Handle errors
			nTotErr =AERROR(aErrors)
			DO CASE
			CASE nTotErr = 0
				
			CASE aErrors[1,1] = 1539				&& Trigger failed
				m.cErrorMessage = E_TRIGGERFAIL_LOC
			CASE aErrors[1,1] = 1581				&& Field doesn't accept NULL
				m.cErrorMessage = E_FIELDNULL_LOC
			CASE aErrors[1,1] = 1582				&& Field rule violated
				m.cErrorMessage = E_FIELDRULE_LOC
			CASE aErrors[1,1] = 1700				&& Record in use by another user
				m.cErrorMessage = E_RECORDLOCK_LOC
			CASE aErrors[1,1] = 1583				&& Row rule violated
				m.cErrorMessage = E_ROWRULE_LOC
			CASE aErrors[1,1] = 1884				&& Unique index violation
				m.cErrorMessage = E_UNIQUEINDEX_LOC
			CASE aErrors[1,1] = 1585				&& Record changed by another user
		
				IF m.lInDBC		&&handle free tables above
					* Dislpay conflict alert
					IF MESSAGEBOX(E_DIRTYREC_LOC,4+48) = MSGBOX_YES
						*Try to force update
						BEGIN TRANSACTION				
						m.lSuccess = TABLEUPDATE(.T.,.T.)
						IF m.lSuccess
							END TRANSACTION
							LOOP
						ELSE
							ROLLBACK
							=MESSAGEBOX(E_NOFORCE_LOC)
						ENDIF			
					ENDIF
				ENDIF
		
			OTHERWISE
				IF !EMPTY(m.cErrorMessage)	&&for free table handling above
					m.cErrorMessage = E_PROMPT_LOC+aErrors[1,2]
				ENDIF
			ENDCASE
		
			* Had an error we couldn't handle
			=TABLEREVERT(.T.)  &&revert all records
			m.lSuccess = .F.
			IF !EMPTY(m.cErrorMessage)
				=MESSAGEBOX(E_FAIL_LOC+m.cErrorMessage)
			ENDIF
		
		ENDFOR
		
		SELECT (m.nOldArea)
		RETURN m.lSuccess
		
	ENDPROC

	PROCEDURE cmdAdd.Click
		#DEFINE OPT_CANCEL			0
		#DEFINE OPT_ADD_PARENT		1
		#DEFINE OPT_ADD_CHILD		2
		#DEFINE OPT_ADD_BOTH		3
		#DEFINE MB_Q_YESNO			36
		#DEFINE MB_A_YES			6
		#DEFINE C_KEYFLDNOUPDATE_LOC	"El campo que relaciona la vista de la cuadrícula con el origen de datos primario no es actualizable. "+"¿Desea simplemente agregar un nuevo registro a la tabla primaria?"
		
		#DEFINE C_BADCHILDKEY_LOC		"Los campos que relacionan las tablas primaria y secundaria no tienen el mismo tipo de datos. "+"¿Desea simplemente agregar un nuevo registro a la tabla primaria?"
		
		#DEFINE C_NOCHILDUPDATE_LOC		"El origen de datos secundario es una vista y no envía actualizaciones. "+"¿Desea agregar un nuevo registro a la tabla primaria?"
		
		#DEFINE C_NOOBJ_LOC		"Falló la creación de la clase de formulario Agregar registro. Verifique o vuelva a instalar el archivo WIZSTYLE.VCX."
		#DEFINE C_NOUPDATE_LOC	"No puede agregar un nuevo registro porque la vista o las vistas seleccionadas no envían actualizaciones."
		#DEFINE C_NOUPDATE2_LOC	"No puede agregar un nuevo registro porque la vista o las vistas seleccionadas no envían actualizaciones y el origen de datos secundario tiene una clave principal."
		
		LOCAL oSearchDlog,oAddRec,cChildAlias,cPapaAlias,i,lPrimeKey
		LOCAL cPapaKey,cChildKey,nSaveSess,oRel,cTagName,lBadViewKey,nSaveRec,nSaveRec2
		LOCAL lBadChildKey,lUpdatableParentKey,lNoSendParentUpdates,lNoSendChildUpdates
		
		DO CASE
		CASE THIS.Parent.EditMode
		
			** Code for saving record
			THIS.Parent.UpdateRows()
		
		CASE EMPTY(THIS.Parent.GridRef)		&& not using Grid object
		
			** Code for adding record
			THIS.Parent.OldAlias = ALIAS()	&&save alias in case reverting
			THIS.Parent.OldRec = RECNO()	&&save record in case reverting
			IF CURSORGETPROP("SourceType")#3 AND ;
			   !CURSORGETPROP("offline") AND ;
				!CURSORGETPROP("SendUpdates")
				=MESSAGEBOX(C_NOUPDATE_LOC)
				RETURN
			ENDIF
			APPEND BLANK
		
		OTHERWISE
		
			** Code for adding record
			THIS.Parent.OldAlias = ALIAS()	&&save alias in case reverting
			THIS.Parent.OldRec = RECNO()	&&save record in case reverting
			lPrimeKey = .F.					&&is child key primary index
			
			IF !EMPTY(THIS.Parent.oDataRelation)
				oRel = EVAL(THIS.Parent.oDataRelation)
			ENDIF
				
			DO CASE
			CASE TYPE("m.oRel") = "O"	&&data environment
				WITH oRel
					cPapaAlias = .ParentAlias
					cPapaKey = .RelationalExpr
					cChildAlias = .ChildAlias
					cChildKey = .ChildOrder
				ENDWITH
				oRel = .NULL.	&&reset
			CASE !EMPTY(THIS.Parent.ViewKey)	&&using views
				cPapaAlias = ALIAS()
				cPapaKey = THIS.Parent.ParentKey
				cChildAlias = THIS.Parent.GridAlias
				cChildKey = THIS.Parent.ViewKey
				
				* Need to check if Key field is updatable
				IF CURSORGETPROP("SourceType",m.cChildAlias)#3 AND !CURSORGETPROP("offline",m.cChildAlias) AND ;
					ATC(","+m.cChildKey+",",","+CURSORGETPROP("UpdatableFieldList",m.cChildAlias)+",")=0
					lBadViewKey = .T.
				ENDIF
			OTHERWISE
				cPapaAlias = ALIAS()
				cPapaKey = RELATION(1)
				cChildAlias = THIS.Parent.GridAlias
				cChildKey = ORDER(m.cChildAlias)
			ENDCASE
			
			* Test to see if both keys are of the same data type
			SELECT (THIS.Parent.GridAlias)
			cGridKeyType = ""
		
			IF EMPTY(THIS.Parent.ViewKey) AND !EMPTY(m.cChildKey)	&&regular table used 
				* Get the Child Key field since only index tag is here
				* if these is an expression, then default to blank.
				cTagName = ""
				FOR i = 1 TO TagCount("")
					IF UPPER(TAG(m.i)) == UPPER(m.cChildKey)
						cTagName = KEY(m.i)
						lPrimeKey = PRIMARY(m.i)
						EXIT
					ENDIF
				ENDFOR
				
				* Check if we have an index expression here.
				IF ATC("(",m.cTagName)#0 OR ATC("+",m.cTagName)#0 
					cChildKey = ""
				ELSE
					cChildKey = m.cTagName
					cGridKeyType = TYPE(m.cChildKey)
				ENDIF
			ENDIF
			
			IF CURSORGETPROP("SourceType",m.cPapaAlias)#3 AND !CURSORGETPROP("offline",m.cPapaAlias) AND ;
			 !CURSORGETPROP("SendUpdates",m.cPapaAlias)
				lNoSendParentUpdates = .T.
			ENDIF
			IF CURSORGETPROP("SourceType",m.cChildAlias)#3 AND !CURSORGETPROP("offline",m.cChildAlias) AND ;
			 !CURSORGETPROP("SendUpdates",m.cChildAlias)
				lNoSendChildUpdates = .T.
			ENDIF
		
			* Check if have two views and both do not send updates	
			IF m.lNoSendParentUpdates AND m.lNoSendChildUpdates
				=MESSAGEBOX(C_NOUPDATE_LOC)
				RETURN
			ENDIF
			
			SELECT (THIS.Parent.OldAlias )
			IF !EMPTY(m.cGridKeyType) AND m.cGridKeyType # TYPE(m.cPapaKey)
				lBadChildKey = .T.
			ENDIF
		
			DO CASE
			CASE m.lNoSendParentUpdates AND (m.lBadViewKey OR m.lBadChildKey)
				=MESSAGEBOX(C_NOUPDATE_LOC)
				RETURN
			CASE m.lPrimeKey AND m.lNoSendParentUpdates
				=MESSAGEBOX(C_NOUPDATE2_LOC)
				RETURN
			CASE m.lNoSendChildUpdates	&&child view does not send updates
				IF MESSAGEBOX(C_NOCHILDUPDATE_LOC,MB_Q_YESNO) # MB_A_YES
					RETURN
				ENDIF
				APPEND BLANK
			CASE m.lBadViewKey	&&view key in not updatable
				IF MESSAGEBOX(C_KEYFLDNOUPDATE_LOC,MB_Q_YESNO) # MB_A_YES
					RETURN
				ENDIF
				APPEND BLANK
			CASE m.lBadChildKey 	&&bad child key -- different data type from parent
				IF MESSAGEBOX(C_BADCHILDKEY_LOC,MB_Q_YESNO) # MB_A_YES
					RETURN
				ENDIF
				APPEND BLANK
			OTHERWISE
				* Need to check if Key field is updatable
				lUpdatableParentKey = .T.
				IF CURSORGETPROP("SourceType",m.cPapaAlias)#3 AND !CURSORGETPROP("offline",m.cPapaAlias) AND;
					ATC(","+m.cPapaKey+",",","+CURSORGETPROP("UpdatableFieldList",m.cPapaAlias)+",")=0
					* cPapaKey = ""
					lUpdatableParentKey = .F.
				ENDIF
		
				* Check for expression in cPapaKey if so, then do not update record with keyvalue
				IF ATC("(",m.cPapaKey)#0 OR ATC("+",m.cPapaKey)#0
					cPapaKey = ""
				ENDIF
		
				nSaveSess = SET("DATASESSION")
				oAddRec = CREATE("GridAddRec")
				IF TYPE("m.oAddRec") # "O"
					=MESSAGEBOX(C_NOOBJ_LOC)
					RETURN
				ENDIF
				oAddRec.ChildPrimaryKey = m.lPrimeKey
				oAddRec.UpdatableParentKey = m.lUpdatableParentKey
				oAddRec.NoSendUpdates = m.lNoSendParentUpdates
				oAddRec.KeyField = m.cPapaKey
				oAddRec.KeyValue = 	IIF(!EMPTY(m.cPapaKey),EVAL(m.cPapaKey),"")
				oAddRec.RunAddForm()
				IF oAddRec.AddOption = OPT_CANCEL
					RETURN
				ENDIF
		
				SET DATASESSION TO nSaveSess
				SELECT (THIS.Parent.OldAlias)
				
				IF TYPE("oAddRec.KeyValue") = "C"
					oAddRec.KeyValue = TRIM(oAddRec.KeyValue)
				ENDIF
				
				* Add record to parent table
				nSaveRec = RECNO()
				IF INLIST(oAddRec.AddOption,OPT_ADD_PARENT,OPT_ADD_BOTH)
					IF EMPTY(m.cPapaKey)
						APPEND BLANK IN (m.cPapaAlias)
					ELSE
						INSERT INTO (m.cPapaAlias) ((oAddRec.KeyField)) VALUES(oAddRec.KeyValue)
					ENDIF
				ENDIF
				nSaveRec2 = RECNO()
		
				* Add child record
				IF INLIST(oAddRec.AddOption,OPT_ADD_CHILD,OPT_ADD_BOTH)
					* Need to check
					GO m.nSaveRec
					IF EMPTY(m.cChildKey) OR TYPE("m.cChildKey")#TYPE('oAddRec.KeyValue')
						APPEND BLANK IN (m.cChildAlias)
					ELSE
						INSERT INTO (m.cChildAlias) ((m.cChildKey)) VALUES(oAddRec.KeyValue)
					ENDIF
					GO m.nSaveRec2
				ENDIF
			ENDCASE
		ENDCASE
		
		THIS.Parent.EditMode = !THIS.Parent.EditMode
		THIS.Parent.AddMode = THIS.Parent.EditMode
		THIS.Parent.TopFile = .F.
		THISFORM.LockScreen = .T.
		THIS.Parent.ButtonRefresh()
		THIS.Parent.NavRefresh()
		THISFORM.LockScreen = .F.
	ENDPROC

	PROCEDURE cmdAdd.Error
		LPARAMETERS nError, cMethod, nLine
		this.parent.error(m.nError, m.cMethod, m.nLine)
	ENDPROC

	PROCEDURE cmdDelete.Click
		#DEFINE MSGBOX_YES		6
		#DEFINE C_MSGBOX1		36
		#DEFINE C_DELETE_LOC	"¿Desea eliminar este registro?"
		#DEFINE C_NOLOCK_LOC	"No se pudo eliminar el registro porque hay alguien usándolo."
		
		* Note: Cascading deletes should be handled via RI triggers in DBC!
		
		IF MESSAGEBOX(C_DELETE_LOC,C_MSGBOX1) = MSGBOX_YES
			DELETE
			IF THIS.Parent.UpdateRows()  &&success
				* Success
				IF !EOF()
					SKIP 1
				ENDIF
				IF EOF() AND !BOF()
					SKIP -1
				ENDIF
			ENDIF
			THISFORM.LockScreen = .T.
			THIS.Parent.ButtonRefresh()
			THIS.Parent.NavRefresh()
			THISFORM.LockScreen = .F.
		ENDIF
		
		IF THISFORM.ShowWindow = 2 
			Activate Window (THISFORM.Name)
		ENDIF
		
	ENDPROC

	PROCEDURE cmdDelete.Error
		LPARAMETERS nError, cMethod, nLine
		this.parent.error(m.nError, m.cMethod, m.nLine)
	ENDPROC

	PROCEDURE cmdEdit.Click
		#DEFINE C_NOUPDATE_LOC	"No puede modificar porque la vista o las vistas seleccionadas no envían actualizaciones."
		
		LOCAL lNoSendParentUpdates,lNoSendChildUpdates
		LOCAL aTablesUsed,nTablesUsed,i
		
		** Reverting record
		IF THIS.Parent.EditMode
			
			IF THIS.Parent.UseDataEnv
				SELECT (THIS.Parent.OldAlias)
				IF CURSORGETPROP("Buffering")>1
					=TableRevert(.T.)
				ENDIF
				IF !EMPTY(THIS.Parent.GridAlias)
					SELECT (THIS.Parent.GridAlias)
					IF CURSORGETPROP("Buffering")>1
						=TableRevert(.T.)
					ENDIF
				ENDIF			
			ELSE
				DIMENSION aTablesUsed[1]
				m.nTablesUsed = AUSED(aTablesUsed)
				FOR i = 1 TO m.nTablesUsed
					IF CURSORGETPROP("Buffering",aTablesUsed[m.i,1])>1
						=TableRevert(.T.,aTablesUsed[m.i,1])
					ENDIF
				ENDFOR
			ENDIF
			
			* Go back to original place
			SELECT (THIS.Parent.OldAlias)
			IF RECCOUNT() < THIS.Parent.OldRec	&&added record at EOF()
				GO TOP
			ELSE
				GO THIS.Parent.OldRec
			ENDIF
		ELSE
		
			* Check to see if view allows updates
			IF CURSORGETPROP("SourceType")#3 AND !CURSORGETPROP("offline") AND;
				!CURSORGETPROP("SendUpdates")
				lNoSendParentUpdates = .T.
			ENDIF
			IF !EMPTY(THIS.Parent.GridAlias) AND ;
			  CURSORGETPROP("SourceType",THIS.Parent.GridAlias)#3 AND ;
			  !CURSORGETPROP("offline",THIS.Parent.GridAlias) AND ;
			  !CURSORGETPROP("SendUpdates",THIS.Parent.GridAlias)
				lNoSendChildUpdates= .T.
			ENDIF
			
			IF (m.lNoSendChildUpdates AND m.lNoSendParentUpdates) OR;
				(EMPTY(THIS.Parent.GridAlias) AND m.lNoSendParentUpdates)
				=MESSAGEBOX(C_NOUPDATE_LOC)
				RETURN
			ENDIF
			
			THIS.Parent.OldAlias = ALIAS()	&&save alias in case reverting
			THIS.Parent.OldRec = RECNO()	&&save record in case reverting
		ENDIF
		
		** Editing record
		THIS.Parent.EditMode = !THIS.Parent.EditMode
		THIS.Parent.AddMode = .F.
		THISFORM.LockScreen = .T.
		THIS.Parent.ButtonRefresh()
		THIS.Parent.NavRefresh()
		THISFORM.LockScreen = .F.
	ENDPROC

	PROCEDURE cmdEdit.Error
		LPARAMETERS nError, cMethod, nLine
		this.parent.error(m.nError, m.cMethod, m.nLine)
	ENDPROC

	PROCEDURE cmdEnd.Click
		SELECT (THIS.parent.nWorkArea)
		GO BOTTOM
		THIS.Parent.TopFile = .F.
		THIS.Parent.EndFile = .T.
		THIS.Parent.NavRefresh()
	ENDPROC

	PROCEDURE cmdExit.Click
		THISFORM.Release
		
	ENDPROC

	PROCEDURE cmdFind.Click
		LOCAL oSearchDlog
		LOCAL lVisChange,lStateChange
		
		* Check if SDI Window
		IF THISFORM.ShowWindow = 2 
			IF !_VFP.Visible
				_VFP.Visible = .T.
				lVisChange = .T.
			ENDIF
			IF _SCREEN.WindowState = 1
				_SCREEN.WindowState = 0
				lStateChange = .T.
			ENDIF
		ENDIF
		
		oSearchDlog = CREATE("searchform")
		oSearchDlog.SHOW()
		
		IF m.lVisChange
			_VFP.Visible = .F.
		ENDIF
		IF m.lStateChange 
			_SCREEN.WindowState = 1
		ENDIF
		
		IF THISFORM.ShowWindow = 2 
			Activate Window (THISFORM.Name)
		ENDIF
		
		* Reset from prior
		THIS.Parent.TopFile = .F.
		THIS.Parent.EndFile = .F.
		THIS.Parent.NavRefresh()
	ENDPROC

	PROCEDURE cmdNext.Click
		SELECT (THIS.parent.nWorkArea)
		IF !EOF()
			SKIP 1
		ENDIF
		
		THIS.Parent.EndFile = EOF()
		THIS.Parent.TopFile = BOF()
		
		THIS.Parent.NavRefresh()
		
	ENDPROC

	PROCEDURE cmdPrev.Click
		SELECT (THIS.parent.nWorkArea)
		IF !BOF()
			SKIP -1
		ENDIF
		
		THIS.Parent.TopFile = BOF()
		THIS.Parent.EndFile = EOF()
		
		THIS.Parent.NavRefresh()
	ENDPROC

	PROCEDURE cmdPrint.Click
		#DEFINE C_MAKEREPO_LOC			"No se pudo encontrar un informe para imprimir. ¿Desea crear uno nuevo?"
		#DEFINE C_NOOPEN_LOC					"Error al abrir la tabla. Imposible imprimir el informe."
		#DEFINE C_GETFILEPROMPT_LOC		"Imprimir el informe:"
		
		LOCAL cRepName,nSaveSess,cSaveAlias,cSaveSource,cSaveData 
		
		cSaveAlias = ALIAS()
		cSaveSource = CURSORGETPROP("SourceName")
		cSaveData = CURSORGETPROP("Database")
		cDiffSource = ""
		cRepName = LEFT(ALIAS(),8)+".FRX"
		nSaveSess = SET("DATASESSION")
		
		* Handling for Private data sessions
		#IF 0
			IF m.nSaveSess # 1
				SET DATASESSION TO 1
				SELECT 0
				IF !EMPTY(m.cSaveData)
					OPEN DATABASE (m.cSaveData)
				ENDIF
				IF USED(m.cSaveAlias)
					SELECT (m.cSaveAlias)
					IF CURSORGETPROP("SourceName")#m.cSaveSource
						cDiffSource = CURSORGETPROP("SourceName")
						USE IN (m.cSaveAlias)
						SELECT 0
					ENDIF
				ENDIF	
				IF EMPTY(ALIAS())
					USE (m.cSaveSource) AGAIN ALIAS (m.cSaveAlias) SHARED
					IF EMPTY(ALIAS())
						=MESSAGEBOX(C_NOOPEN_LOC)
						RETURN
					ENDIF
				ENDIF
			ENDIF
		#ENDIF
		
		IF FILE(m.cRepName)
			REPORT FORM (m.cRepName) PREVIEW NOWAIT
		ELSE
			m.cRepName = GETFILE("frx",C_GETFILEPROMPT_LOC,"",1)
			IF !EMPTY(m.cRepName)
				IF FILE(m.cRepName)
					* User pressed Open button
					REPORT FORM (m.cRepName) PREVIEW NOWAIT
				ELSE
					* User pressed New button
					DO HOME()+"wizards\wzreport.app" WITH ALIAS(), "AUTOREPORT"
				ENDIF
			ENDIF
		ENDIF
		
		* Private data session code
		#IF 0
			IF !EMPTY(cDiffSource)
				USE (m.cDiffSource) IN 0
			ENDIF
			SET DATASESSION TO m.nSaveSess
			SELECT (m.cSaveAlias)
		#ENDIF
		
		IF THISFORM.ShowWindow = 2 
			Activate Window (THISFORM.Name)
		ENDIF
		
	ENDPROC

	PROCEDURE cmdTop.Click
		SELECT (THIS.parent.nWorkArea)
		LOCATE
		THIS.Parent.TopFile = .T.
		THIS.Parent.EndFile = EOF()
		THIS.Parent.NavRefresh()
	ENDPROC

ENDDEFINE

DEFINE CLASS verttxtbtns AS txtbtns OF "wizstyle.vcx" 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" ProjectClassIcon="stylebmp\textbttn.bmp" ClassIcon="stylebmp\textbttn.bmp" />

	*<PropValue>
		Height = 276
		Name = "verttxtbtns"
		Width = 68
		cmdEdit.Height = 24
		cmdEdit.Left = 4
		cmdEdit.Name = "cmdEdit"
		cmdEdit.Top = 192
		cmdEdit.Width = 62
		cmdDelete.Height = 24
		cmdDelete.Left = 4
		cmdDelete.Name = "cmdDelete"
		cmdDelete.Top = 216
		cmdDelete.Width = 62
		cmdAdd.Height = 24
		cmdAdd.Left = 4
		cmdAdd.Name = "cmdAdd"
		cmdAdd.Top = 168
		cmdAdd.Width = 62
		cmdPrint.Height = 24
		cmdPrint.Left = 4
		cmdPrint.Name = "cmdPrint"
		cmdPrint.Top = 132
		cmdPrint.Width = 62
		cmdFind.Height = 24
		cmdFind.Left = 4
		cmdFind.Name = "cmdFind"
		cmdFind.Top = 108
		cmdFind.Width = 62
		cmdEnd.Height = 24
		cmdEnd.Left = 4
		cmdEnd.Name = "cmdEnd"
		cmdEnd.Top = 72
		cmdEnd.Width = 62
		cmdTop.Height = 24
		cmdTop.Left = 4
		cmdTop.Name = "cmdTop"
		cmdTop.Top = 0
		cmdTop.Width = 62
		cmdNext.Height = 24
		cmdNext.Left = 4
		cmdNext.Name = "cmdNext"
		cmdNext.Top = 48
		cmdNext.Width = 62
		cmdPrev.Height = 24
		cmdPrev.Left = 4
		cmdPrev.Name = "cmdPrev"
		cmdPrev.Top = 24
		cmdPrev.Width = 62
		cmdExit.Height = 24
		cmdExit.Left = 4
		cmdExit.Name = "cmdExit"
		cmdExit.Top = 252
		cmdExit.Width = 62
	*</PropValue>

ENDDEFINE

DEFINE CLASS wizshape AS shape 
 	*< CLASSDATA: Baseclass="shape" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*p: wizeffect
	*</DefinedPropArrayMethod>

	*<PropValue>
		Height = 68
		Name = "wizshape"
		Width = 68
		wizeffect = 0
	*</PropValue>

ENDDEFINE
